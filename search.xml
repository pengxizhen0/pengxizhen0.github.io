<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>草稿</title>
    <url>/2020/01/01/%E8%8D%89%E7%A8%BF/</url>
    <content><![CDATA[<p>理论上，TCP滑动窗口大小设置为<code>带宽*单向时延*2</code>，乘以2的原因是可以充分利用信道。</p>
<a id="more"></a>

<p>进程间通信：</p>
<ul>
<li>共享内存</li>
<li>消息队列</li>
<li>信号量</li>
<li>Socket</li>
</ul>
<p>堆排序：第一步：自上而下建堆O(n)；第二步：输出元素并保持有序O(logn)，需要自上而下保持有序</p>
<p>堆插入：自下而上</p>
<p>final作用</p>
<p>哪些是final的</p>
<p>final对象的成员变量</p>
<p>String为什么是final</p>
<p>volatile保证单例？</p>
<p>错误重写hash函数，equals没有错。对于HashSet和HashMap，会出现什么情况。</p>
<p>逃逸分析：JVM对程序的优化，可从以下三个方面进行优化：</p>
<ol>
<li>栈上分配。不会逃逸的局部变量会被分配在栈上，减少GC。</li>
<li>同步消除。不会线程逃逸的变量，会优化掉与之相关的锁。</li>
<li>标量替换。</li>
</ol>
<p>RPC VS MQ</p>
<ol>
<li>RPC耦合，MQ解耦；</li>
<li>MQ可削峰填谷；</li>
<li>MQ可广播。</li>
</ol>
<p>测试IO/CPU耗时比例：apm工具</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LockSupport.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">            UNSAFE.unpark(thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>重复请求：幂等</li>
<li>并发请求：串行、锁</li>
<li>超量请求：扩容、限流、拒绝</li>
<li>消息乱序：锁+版本号+幂等</li>
<li>非法调用：鉴权</li>
<li>依赖不稳定：超时控制、降级、熔断</li>
</ul>
<p>阻塞队列可以用来实现池化技术</p>
<p>编译时环境：*.java -&gt; *.class（机器码）</p>
<p>运行时环境：*.class -&gt; 加载进JVM</p>
<p>对于C/C++，在编译时选择平台</p>
<p>对于Java，在运行时选择平台</p>
<p>JDK内置工具使用jps、jstack、jmap、jstat</p>
<p>Java visualVM</p>
]]></content>
      <categories>
        <category>草稿</category>
      </categories>
  </entry>
  <entry>
    <title>基于Redis的分布式锁</title>
    <url>/2019/12/30/%E5%9F%BA%E4%BA%8ERedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h1 id="基于Redis的分布式锁"><a href="#基于Redis的分布式锁" class="headerlink" title="基于Redis的分布式锁"></a>基于Redis的分布式锁</h1><a id="more"></a> 

<p>互斥性</p>
<p>防止未执行完，锁就过期（后台启动续命线程）</p>
<p>阻塞和非阻塞</p>
<p>未获取到锁的线程可阻塞（CAS），可非阻塞。</p>
<p>可重入性</p>
<p>加锁之前先查看本线程的锁ID是否已上锁</p>
<p>安全性</p>
<p>防止死锁（1.设置过期时间；2.占用锁与设置过期时间应该为原子操作）</p>
<p>防止锁被其他线程任意释放（使用UUID+线程ID作为锁ID）</p>
<p>高可用</p>
<p>防止Redis单机故障（1.Redis使用集群方案，进行数据分片；2.每次取回多个锁）</p>
<p>Redisson分布式锁使用hash作为底层数据结构，hash的key为lockName，field为UUID+threadId。</p>
<p>为了防止锁被其他线程随意释放，field应该对其他线程保密。</p>
<p>获取锁的线程会启动一个后台线程，该线程用于延长锁的过期时间，每隔10秒重新设置30秒的过期时间。</p>
<p>获取锁</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">'exists'</span>, name) == <span class="number">0</span>) <span class="keyword">then</span> <span class="comment">--判断是否存在锁</span></span><br><span class="line">	redis.call(<span class="string">'hset'</span>, lockName, UUID+threadId, <span class="number">1</span>);</span><br><span class="line">	redis.call(<span class="string">'pexpire'</span>, lockName, expireTime);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">'hexists'</span>, lockName, UUID+threadId) == <span class="number">1</span>) <span class="keyword">then</span> <span class="comment">--判断该锁是否是自己线程的锁</span></span><br><span class="line">	redis.call(<span class="string">'hincrby'</span>, lockName, UUID+threadId, <span class="number">1</span>);</span><br><span class="line">	redis.call(<span class="string">'pexpire'</span>, lockName, expireTime);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">return</span> redis.call(<span class="string">'pttl'</span>, lockName); <span class="comment">--获取锁失败，返回锁的过期时间</span></span><br></pre></td></tr></table></figure>

<p>释放锁</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">'hexists'</span>, lockName, UUID+threadId) == <span class="number">0</span>) <span class="keyword">then</span> <span class="comment">--无锁则不需要释放</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">local</span> counter = redis.call(<span class="string">'hincrby'</span>, lockName, UUID+threadId, <span class="number">-1</span>); <span class="comment">--释放锁</span></span><br><span class="line"><span class="keyword">if</span> (counter &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">	redis.call(<span class="string">'pexpire'</span>, lockName, expireTime); <span class="comment">--因锁的可重入性，还未完全释放</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	redis.call(<span class="string">'del'</span>, lockName); <span class="comment">--完全释放锁</span></span><br><span class="line">	redis.call(<span class="string">'publish'</span>, channelName, message);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br></pre></td></tr></table></figure>

<p>方案缺陷</p>
<p>在CAP理论中，Redis属于AP架构。主从架构下，可能会导致多个客户端拿到锁，失去互斥性。</p>
<p>一个客户端从master拿到了锁，在主从同步完成之前，master宕机，slave晋升为master。由于slave没有锁信息，这时第二个客户端可以进行加锁。</p>
<p>针对这个提问，Redis的作者提出了RedLock。RedLock的思想是使用奇数个Redis master，这些master完全独立，没有哨兵、主从、集群之类的关系。从其中的一个master上获取锁与上述方案一致，只要拿到半数以上的锁，视为获取分布式锁成功。如果其中一台master发生故障，切换为无锁信息的slave，也不会失去互斥性。如果如果同时宕机的数量超过半数以上，那还是会丢失互斥性，只是这种事情发生的概率较低。</p>
<p>分布式锁其他方案</p>
<p>Zookeeper属于CP架构</p>
<p>mysql锁行</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>分布式锁</tag>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2019/12/26/MySQL/</url>
    <content><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>三种常见索引：</p>
<ol>
<li>哈希表：适合等值查询，不适合区间查询；</li>
<li>有序数组：使用二分法查询等值和区间值，复杂度为O(logn)，但只适合静态数据，不再修改的数据；</li>
<li>树：Innodb的索引采用B+树，是一个N叉树，这里N大约为1200.</li>
</ol>
<a id="more"></a> 



<p>B树与B+树的区别：</p>
<ul>
<li>B+树非叶子节点不存数据，只存索引。那么就可以存储更多的索引，减小树的高度；</li>
<li>B+树叶子节点之间用链表关联，方便区间查询。</li>
</ul>
<p>聚簇索引：索引与数据存储在一起；</p>
<p>二级索引（普通索引）：数据不与索引在一起，需要回表查询（即还需要到聚簇索引中再查询一遍）；</p>
<p>联合索引：用多个字段联合建立的索引，可防止回表查询</p>
<p>建议使用自增主键，不要使用业务字段作为主键：</p>
<ol>
<li>性能方面：自增主键有序，不会造成叶子节点的分裂（业务字段往往无序）；</li>
<li>空间方面：自增主键往往占用空间小于业务字段，可减小索引占用空间。</li>
</ol>
<p>Buffer Pool</p>
<p>Innodb会在内存中开辟一块区域用以存放索引和数据。这块区域就是Buffer Pool。这块区域越大，Mysql的性能就越接近内存型数据库（如Redis等）。</p>
<p>Innodb的最小存储单位是page，在旧版本中，一个page的大小是16KB。在新版本中，page的大小可设置。Innodb以页为单位从磁盘读入数据放入Buffer Pool中。Buffer Pool使用改进的LRU算法进行缓存淘汰。主要有两点改进：</p>
<ul>
<li>对缓存进行分区域管理，参数<code>innodb_old_blocks_pct</code>可调整两区域的比例，可对预读进行优化；</li>
<li>对热数据提至头部设置时间阈值，参数<code>innodb_old_blocks_time</code>可调整时间阈值，可对全表扫描进行优化。</li>
</ul>
<p>Buffer Pool被划分为两个区域：new sublist和old sublist。新加入的页会被放到old sublist的头部。若某一页被访问到了，就会被提至new sublist的头部，说明该页是热数据。old sublist的尾部是最冷的数据，随时会被淘汰。</p>
<p><code>innodb_old_blocks_pct</code>：默认为37。该值表示old sublist占整个Buffer Pool的比例。值越小，越接近传统的LRU算法。对于预读，Innodb会将访问数据之后的页也读入Buffer Pool，如果预读的页在后续操作中没使用到，就会挤出宝贵的热点数据。Buffer Pool划分了区域后，无用的预读页对热点数据的影响会降到最低。</p>
<p><code>innodb_old_blocks_time</code>：默认为0。该值表示当新页插入old sublist中，需要停留的时间。过了这个停留时间后的访问才能将该页移动到new sublist头部。设置该参数可防止全表扫描污染热点数据的问题。对于全表扫描，会读入许多页，而这些页在后续的操作中大概率是用不到的，所以这些页不应该被移动到new sublist中。</p>
<p>悲观锁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">select status from goods where id=#&#123;id&#125; for update;</span><br><span class="line">update goods set status=#&#123;status&#125; where id=#&#123;id&#125;;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>排他锁</p>
<p><code>select ... for update</code></p>
<p>共享锁</p>
<p><code>select ... lock in share mode</code></p>
<p>乐观锁</p>
<p>通过版本号实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">select (status,version) from goods where id=#&#123;id&#125;;</span><br><span class="line"></span><br><span class="line">update goods </span><br><span class="line">set statstatus=#&#123;status&#125;, version=version+1 </span><br><span class="line">where id=#&#123;id&#125; and version=#&#123;version&#125;;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>Buffer Pool：<a href="https://dev.mysql.com/doc/refman/5.5/en/innodb-buffer-pool.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.5/en/innodb-buffer-pool.html</a> </p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
        <tag>锁</tag>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2019/12/26/Redis/</url>
    <content><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><ol>
<li>字符串：int、raw、embstr</li>
<li>列表：ziplist和linkedlist</li>
<li>哈希表：ziplist和hashtable</li>
<li>集合：intset和hashtable</li>
<li>有序集合：ziplist和skiplist</li>
</ol>
<p>ziplist是一种经过特殊编码的双向链表，不同于普通的双向链表，ziplist存储在一块连续的内存中。ziplist的特殊编码节省了数据所占用的内存。ziplist的每个数据项上都保存有本项的数据长度和上一项的数据长度。这样可以通过指针的运算跳到上一个或者下一个数据项。</p>
<a id="more"></a> 

<p>由于ziplist在一块连续内存上，对ziplist的追加操作就需要重新分配一块新的内存空间，并把旧数据搬移到新内存。</p>
<p>且对ziplist的查找操作需要遍历，效率较低，所以在数据量比较小的时候适合使用ziplist。</p>
<h2 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h2><p>惰性删除+定期删除</p>
<p>惰性删除：获取键之前检测是否过期</p>
<h2 id="RDB持久"><a href="#RDB持久" class="headerlink" title="RDB持久"></a>RDB持久</h2><p>生成RDB：SAVE和BGSAVE这两个命令都可以生成RDB文件。SAVE会阻塞服务，BGSAVE会fork子进程，在子进程中进行生成RDB。可以设置满足一定条件自动执行BGSAVE。</p>
<p>同时满足两个条件可触发BGSAVE：距离上次SAVE已经过去的时间 &amp;&amp; 距离上次SAVE修改的次数</p>
<p>系统启动时，会优先载入AOF文件，若不存在则载入RDB文件。</p>
<h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><p>AOF文件保存客户端发来的请求。先保存在程序中的缓冲区中</p>
<ol>
<li>写请求命令保存在程序中的aof_buf缓冲区中；</li>
<li>在服务器每个循环事件的结束阶段，调用flushAppendOnlyFile函数将aof写入磁盘中；</li>
<li>由于第二步是调用系统函数write进行写操作，会写到操作系统的page cache中。落盘需要调用fsync函数，具体什么时候落盘，可以通过设置appendfsync来实现。</li>
</ol>
<p><strong>aof重写</strong></p>
<p>aof文件会随着Redis的使用慢慢变大，我们可以通过aof重写来减小aof文件的大小。aof重写通过读取数据库现有数据来实现。</p>
<p>aof重写是后台进程，Redis在重写过程中，客户端可能会有新的写请求进来，这些写请求会被放到重写缓存区中。等到后台aof重写完成后，再把重写缓存区中的写请求追加到重写完成的aof文件中。</p>
<p>系统启动时，会优先载入AOF文件，若不存在则载入RDB文件。</p>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><h3 id="Redis2-8之前的复制"><a href="#Redis2-8之前的复制" class="headerlink" title="Redis2.8之前的复制"></a>Redis2.8之前的复制</h3><ol>
<li>从服务器向主服务器发送SYNC命令；</li>
<li>主服务器收到SYNC命令后开始执行BGSAVE命令以生成RDB文件，并在缓存区中记录生成过程中的写请求；</li>
<li>将RDB文件和缓冲区中的写请求发送给从服务器；</li>
<li>对于后续的写请求，都会传送至从服务器</li>
</ol>
<h3 id="Redis2-8之后的复制"><a href="#Redis2-8之后的复制" class="headerlink" title="Redis2.8之后的复制"></a>Redis2.8之后的复制</h3><p>针对2.8之前版本较为低效的复制，2.8之后的新版本做了改进。</p>
<p>在2.8之前的版本中，如果从服务器因为网络问题断线后重连，那么没有办法只补断线阶段的写请求，需要重新给主服务器发送SYNC命名，重新走一遍流程。主从服务器可以通过各自的偏移量来确定主从是否一致。</p>
<p>在2.8之后的版本中，引入了PSYNC部分同步的命令，从服务器断线重连后，发送PSYNC命令给主服务器。主服务器会将断线期间的命令从缓冲区捞出发给从服务器，若断线期间的数据量太大，导致缓冲区放不下，那么就需要发送SYNC命令，重新开始同步。</p>
<h2 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h2><p>从服务器会定期向主服务器发送心跳包进行心跳检测，有三个作用：</p>
<ol>
<li>检测主从之间的网络状态；</li>
<li>实现min-slaves，即如果少于特定数量的从服务器或者时延太大，主服务器就拒绝写入，只能读；</li>
<li>若由于主从包丢失造成的主从不一致，可进行补发。</li>
</ol>
<h2 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h2><p>在Redis中，用户可以通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制另一个服务器，被复制的服务器为主服务器，而对主服务器进行复制的服务器则被称为从服务器。</p>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>哨兵是Redis高可用的解决方案。哨兵系统由一个或多个哨兵节点组成。可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p>
<p>在主从模式下，若主机发生故障，Redis就无法对外提供服务。这时需要引入哨兵模式。</p>
<h2 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h2><p>Redis Cluster是Redis 3.0之后推出的分布式集群方案。提供数据分片、主从复制、故障转移等功能。若选用Redis Cluster方案，就不需要哨兵了。</p>
<p>一个集群由多个节点组成，整个集群的数据被分为16384个槽，不同的节点分担不同的槽。</p>
<p>在一个完成分片的集群中，我们可以通过命令重新分片。源节点会将相应的槽逐步迁移至目标节点。</p>
<p>由于集群是去中心化的，客户端可以向其中任意一个节点发起请求。客户端请求一个key，若key不在该节点上，该节点会返回MOVED错误，并把正确的节点告知客户端。客户端之后需向正确的节点再次发起请求。</p>
<p>如果请求的节点是重新分片中的源节点且没有发现相应的key，那么该节点会返回ASK错误，并返回目标节点，告知客户端可以去目标节点查询。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>渐进式哈希</tag>
        <tag>跳表</tag>
        <tag>集群</tag>
        <tag>主从</tag>
      </tags>
  </entry>
  <entry>
    <title>IO模型</title>
    <url>/2019/12/25/IO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>在Unix下有5中IO模型</p>
<ul>
<li>同步阻塞IO</li>
<li>同步非阻塞IO</li>
<li>IO多路复用</li>
<li>异步IO</li>
<li>信号驱动IO</li>
</ul>
<a id="more"></a> 

<p>一个输入操作通常包含两个阶段：</p>
<ol>
<li>等待数据。等待网络中的数据分组到达，数据会被拷贝到内核缓冲区中。</li>
<li>获取数据。将数据从内核拷贝到进程。</li>
</ol>
<p>第一阶段等待数据可以区分是否阻塞，第二阶段获取数据可以区分同步或异步。</p>
<p>根据POSIX对同步IO和异步IO的定义，在上述5种IO模型中，除了异步IO，其他都是同步IO。上述四种同步IO在第二阶段都会被阻塞。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>《UNIX网络编程》</p>
]]></content>
      <categories>
        <category>IO模型</category>
      </categories>
      <tags>
        <tag>NIO</tag>
        <tag>BIO</tag>
        <tag>AIO</tag>
      </tags>
  </entry>
  <entry>
    <title>String</title>
    <url>/2019/12/20/String/</url>
    <content><![CDATA[<h1 id="String、StringBuilder、StringBuffer"><a href="#String、StringBuilder、StringBuffer" class="headerlink" title="String、StringBuilder、StringBuffer"></a>String、StringBuilder、StringBuffer</h1><p>String类与其中的成员变量value是final的，value是一个定长的char数组，代表着String一旦初始化好就不能改变。一切对原String的修改操作都会创建新的String对象。</p>
<a id="more"></a> 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以concat和substring为例子说明修改操作都会返回一个新的String对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> otherLen = str.length();</span><br><span class="line">        <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = value.length;</span><br><span class="line">        <span class="keyword">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">        str.getChars(buf, len);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> subLen = value.length - beginIndex;</span><br><span class="line">        <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="keyword">this</span> : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StringBuilder和StringBuffer都继承了抽象类AbstractStringBuilder，在抽象类中，value是一个变长的数组，增加字符串时，若char数组空间足够，则直接添加；若空间不够，则会new一个更大的数组，将旧数据搬移过去。由于搬移数据是native方法，使用指针寻址来保证效率。</p>
<p>StringBuilder和StringBuffer的区别就在于，前者是线程不安全的，后者是线程安全的，线程安全的方法就是在整个方法上加<code>synchronized</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java知识</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Thread</title>
    <url>/2019/12/20/Thread/</url>
    <content><![CDATA[<p>Java线程共有6种状态，在Thread类中有枚举来详细定义和说明：</p>
<a id="more"></a> 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Thread.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>NEW</strong> 线程刚创建，尚未启动；</p>
</li>
<li><p><strong>RUNNABLE</strong> 线程正在正常运行中；</p>
</li>
<li><p><strong>BLOCKED</strong> 线程等待进入临界区，如等待另一个线程走出synchronized块；</p>
</li>
<li><p><strong>WAITING</strong> 线程在临界区里面等待唤醒，在临界区内调用wait()后进入WAITING状态，等待另一个调用notify()/notifyAll()；</p>
</li>
<li><p><strong>TIMED_WAITING</strong> 这个状态就是有时间限制的WAITING，如调用wait(long)、join(long)、sleep(long)；</p>
</li>
<li><p><strong>TERMINATED</strong> 线程执行完run()方法，处于该状态的线程会被GC。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java知识</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Collection_List_Set</title>
    <url>/2019/12/19/Collection-List-Set/</url>
    <content><![CDATA[<h1 id="Collection、List与Set接口"><a href="#Collection、List与Set接口" class="headerlink" title="Collection、List与Set接口"></a>Collection、List与Set接口</h1><p>Collection代表一群元素的集合，至于这群元素怎么排列、是否可重复、是否有序等特性，Collection接口没有作定义。</p>
<p>List和Set继承了Collection接口，他们都具体描述了这群集合元素的特性。</p>
<p>List描述了这群元素是有序且允许重复元素的，用户可通过序号精准地访问到元素。所以List比Collection多的方法，大多跟index有关，比如<code>void add(int index, E e)</code>。</p>
<p>Set描述了这群元素是无序且没有重复元素的，Set没有扩展Collection的方法，方法与Collection一样。</p>
]]></content>
      <categories>
        <category>Java知识</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>String_intern</title>
    <url>/2019/12/19/String_intern/</url>
    <content><![CDATA[<h1 id="String-intern"><a href="#String-intern" class="headerlink" title="String intern"></a>String intern</h1><p>String类中有个<code>intern()</code>的native，该方法会查询常量池中是否存在该字符串，若存在，则返回；若不存在则加入常量池并返回。在实现细节方面，JDK6又是与JDK7是不一样的。</p>
<a id="more"></a> 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>下面以一段常见的demo来说明问题。</p>
<p>String的创建：</p>
<ol>
<li><p>直接使用双引号声明出来的<code>String</code>对象会直接存储在常量池中。 </p>
</li>
<li><p>使用new关键字创建的<code>String</code>对象存储在堆中。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//出现了字面量"1"，这个会被存储在常量池中</span></span><br><span class="line">    <span class="comment">//s指向的对象在堆中</span></span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为常量池中已存在"1"，所以该语句无影响</span></span><br><span class="line">    s.intern();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//s2指向的对象在常量池中</span></span><br><span class="line">    String s2 = <span class="string">"1"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//false</span></span><br><span class="line">    System.out.println(s == s2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//常量池中已经存在"1"</span></span><br><span class="line">    <span class="comment">//s3指向堆中的对象，值为"11"</span></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//JDK6和7的区别点就在这里</span></span><br><span class="line">    <span class="comment">//JDK6:"11"不存在常量中，创建"11"并放入常量池</span></span><br><span class="line">    <span class="comment">//JDK7:"11"不存在常量中，在常量池中放入s3</span></span><br><span class="line">    s3.intern();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//JDK6:s4指向的对象在常量池中</span></span><br><span class="line">    <span class="comment">//JDK7:s4指向的对象就是s3</span></span><br><span class="line">    String s4 = <span class="string">"11"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//JDK6:false</span></span><br><span class="line">    <span class="comment">//JDK7:true</span></span><br><span class="line">    System.out.println(s3 == s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序在JDK6上的内存结构图</p>




<p>该程序在JDK7上的内存结构图</p>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">    s.intern();</span><br><span class="line">    String s2 = <span class="string">"1"</span>;</span><br><span class="line">    System.out.println(s == s2);</span><br><span class="line">    </span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下两句交换顺序</span></span><br><span class="line">    <span class="comment">//"11"不存在常量池中，于是创建"11"对象放入常量池</span></span><br><span class="line">    <span class="comment">//这里要与intern区分，因为是用字面量创建s4，所以会创建"11"对象</span></span><br><span class="line">    String s4 = <span class="string">"11"</span>;</span><br><span class="line">    s3.intern();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//JDK7:false</span></span><br><span class="line">    System.out.println(s3 == s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序在JDK7上的内存结构图</p>




<p>在不同的JDK中，常量池存放的地方也不同</p>
<p>JDK6：常量池在永久代中</p>
<p>JDK7：常量池在堆中</p>
<p>JDK8：常量池在元空间中</p>
<p>其中<strong>永久代</strong>和<strong>元空间</strong>都是方法区的一种HotSpot VM实现，方法区是JVM所定义的规范。</p>
<p>结合常量池的存放位置，可以更好地理解intern()行为的区别。在JDK6中，永久代和堆不一样，所以常量池无相应字符串时会创建新对象。在JDK7中，由于都在堆中，常量池会引用堆中的字符串对象，不会创建新对象。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html</a> </p>
]]></content>
      <categories>
        <category>Java知识</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS应用</title>
    <url>/2019/12/10/AQS%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="AQS的应用"><a href="#AQS的应用" class="headerlink" title="AQS的应用"></a>AQS的应用</h1> <a id="more"></a> 

<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>线程可重入锁，与synchronized的作用相同，但两者特性不同。</p>
<p>ReentrantLock可配置为公平锁和非公平锁。多个线程一起竞争AQS对象中的state变量。若state为0，说明锁目前空闲可用，需用CAS竞争锁；若state不为0，说明有线程占用着锁，需要将本线程加入队列，并挂起本线程，等待唤醒。</p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore用来控制并发数量，当数量为1时，Semaphore就退化为普通的锁。Semaphore不可重入。</p>
<p>AQS中的state变量表示允许的并发数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        semaphore.acquire();</span><br><span class="line">        <span class="comment">//do something，控制该资源访问并发数为10</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    semaphore.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch可以让线程等待某个其他线程各自执行完毕后再执行。</p>
<p>AQS中的state变量表示需要等待的数量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    latch.countDown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        latch.await();<span class="comment">//需等待线程1完成之后再继续</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2>]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Reference</title>
    <url>/2019/12/06/Reference/</url>
    <content><![CDATA[<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>Reference类有个静态的代码块，在这里面会运行一个后台线程，用于将被回收的对象放入引用队列。将对象放入引用队列便于后续进一步的清理操作。</p>
<a id="more"></a> 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    ReferenceHandler(ThreadGroup g, String name) &#123;</span><br><span class="line">        <span class="keyword">super</span>(g, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">            Reference r;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pending != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    r = pending;</span><br><span class="line">                    Reference rn = r.next;</span><br><span class="line">                    pending = (rn == r) ? <span class="keyword">null</span> : rn;</span><br><span class="line">                    r.next = r;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException x) &#123; &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Fast path for cleaners</span></span><br><span class="line">            <span class="keyword">if</span> (r <span class="keyword">instanceof</span> Cleaner) &#123;</span><br><span class="line">                ((Cleaner)r).clean();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把将要回收的对象放入引用队列</span></span><br><span class="line">            ReferenceQueue q = r.queue;</span><br><span class="line">            <span class="keyword">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class="line">    <span class="keyword">for</span> (ThreadGroup tgn = tg;</span><br><span class="line">         tgn != <span class="keyword">null</span>;</span><br><span class="line">         tg = tgn, tgn = tg.getParent());</span><br><span class="line">    Thread handler = <span class="keyword">new</span> ReferenceHandler(tg, <span class="string">"Reference Handler"</span>);</span><br><span class="line">    handler.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">    handler.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    handler.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java知识</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>GC</title>
    <url>/2019/12/05/GC/</url>
    <content><![CDATA[<h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><a id="more"></a> 

<h2 id="回收谁"><a href="#回收谁" class="headerlink" title="回收谁"></a>回收谁</h2><p>堆</p>
<h2 id="如何判断是否要回收"><a href="#如何判断是否要回收" class="headerlink" title="如何判断是否要回收"></a>如何判断是否要回收</h2><p>从GC root出发，运用可达性分析，若访问不到的对象需要被回收。</p>
<p>GC root：</p>
<ol>
<li><p>本地变量引用的对象</p>
</li>
<li><p>静态变量引用的对象</p>
</li>
<li><p>常量引用的对象</p>
</li>
<li><p>Native方法引用的对象</p>
</li>
</ol>
<p>对于弱引用，GC不会当它为引用，会进行回收</p>
<p>新生代使用复制算法</p>
<p>分为一个Eden区和两个Survivor区，大小为8:1:1。两个Survivor分别为From Survivor和To Survivor，每次GC过后，From和To会交换。新对象都出生在Eden区。</p>
<p>Partial GC：并不收集整个GC堆的模式</p>
<ul>
<li>Young GC：只收集young gen的GC</li>
<li>Old GC：只收集old gen的GC。只有CMS的concurrent collection是这个模式</li>
<li>Mixed GC：收集整个young gen以及部分old gen的GC。只有G1有这个模式</li>
</ul>
<p>Full GC：收集整个堆，包括young gen、old gen、perm gen（如果存在的话）等所有部分的模式。</p>
<p>CMS：</p>
<p>初始标记（STW）单线程</p>
<p>并发标记</p>
<p>重新标记（STW）多线程</p>
<p>清除</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发</title>
    <url>/2019/12/04/%E9%AB%98%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1 id="高并发设计"><a href="#高并发设计" class="headerlink" title="高并发设计"></a>高并发设计</h1><a id="more"></a> 

<p>高并发设计归纳起来有三种方法：</p>
<ol>
<li><p>Scale-out（横向扩展）。</p>
<p>Scale-out指的是将多个机器组成集群。该方案较复杂，需要管理集群。</p>
<p>Scale-up指的是升级单台机器的配置。该方案足够简单，用到业务发展初期。</p>
</li>
<li><p>缓存。CPU内存寻址在ns级别，从网卡上读取数据在us级别，磁盘的寻道时间在ms级别。</p>
</li>
<li><p>异步。调用方不需要等待结果就可以返回以执行其他的逻辑。</p>
</li>
</ol>
<p>架构分层设计</p>
<ol>
<li>不同的人专注做某一层次的事；</li>
<li>分层可以做到很好的复用；</li>
<li>分层可以更好地横向扩展。</li>
</ol>
<p>如何做：可参考《阿里巴巴Java开发手册》</p>
<p>高并发系统有三大目标：<strong>高性能</strong>，<strong>高可用</strong>，<strong>可扩展</strong>。</p>
<h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><p>性能优化：</p>
<ol>
<li>问题导向。不能为了技术而技术，技术服务于业务；</li>
<li>二八原则。抓住主要矛盾去解决。</li>
<li>优化需要用数据说话。</li>
</ol>
<p>阿姆达尔定律<code>加速比=1/(1-p+p/s)</code>，其中p表示任务并行部分占比，s表示并行进程数。从定律看，要想提高加速比，可以通过<strong>增加进程数</strong>、<strong>增加任务并行占比</strong>、<strong>缩短整体任务时间</strong>。</p>
<h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p>分为系统设计和系统运维两个部分。提高系统的可用性有时候会牺牲系统性能。</p>
<h4 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h4><p>“Design for failure”，在有着大量机器的集群中，是一定会出现单台机器故障的情况。针对这个特点，我们可以使用</p>
<ol>
<li><p>failover。在集群情况下将请求转移出去。</p>
</li>
<li><p>超时控制</p>
</li>
<li><p>限流：在极端情况下，损害部分用户体验来保障另一部分用户；</p>
</li>
<li><p>降级：保证核心服务稳定而牺牲非核心服务</p>
</li>
</ol>
<h4 id="系统运维"><a href="#系统运维" class="headerlink" title="系统运维"></a>系统运维</h4><ol>
<li>灰度发布。故障一般发生在系统变更时，做好灰度发布。</li>
<li>故障演练。</li>
</ol>
<h3 id="可扩展"><a href="#可扩展" class="headerlink" title="可扩展"></a>可扩展</h3><p>能通过加机器解决问题的架构是好架构。</p>
<p>机器不是简单地加上去就可以的，机器加上去后，系统瓶颈可能会转移到其他地方。</p>
<p>将系统进行<strong>拆分</strong>，可以清楚地知道目前系统瓶颈在什么地方，这样可以针对性的扩展。</p>
<h4 id="存储层拆分"><a href="#存储层拆分" class="headerlink" title="存储层拆分"></a>存储层拆分</h4><p>按照业务进行垂直拆分。</p>
<p>按照数据特征进行水平拆分。</p>
<h4 id="业务层拆分"><a href="#业务层拆分" class="headerlink" title="业务层拆分"></a>业务层拆分</h4><p>相同的业务拆到单独的业务池：扩容不影响其他业务</p>
<p>每个业务有单独的存储资源：扩容不影响其他业务</p>
<p>区分核心和非核心的业务接口：便于优先扩容核心业务。</p>
<h2 id="池化技术"><a href="#池化技术" class="headerlink" title="池化技术"></a>池化技术</h2><p>JDK原生线程池的特点决定了它比较适合CPU密集型任务。任务数量达到core之后，任务会进队列。</p>
<p>Tomcat的线程池比较适合IO密集型任务。任务数量达到core，会继续创建新线程。</p>
<h3 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a>数据库读写分离</h3><p>基于性能的考虑，在进行写操作时，写完主库就会返回，然后从库会异步更新。</p>
<p>这样会产生读写延迟的问题，写主库之后立马读从库，可能读不到新写入的值。</p>
<ol>
<li>数据冗余。写完主库后，可以将具体内容以MQ的形式发出去，就暂时不需要去读从库了。</li>
<li>使用缓存。但又会带来数据一致性的问题。</li>
<li>查询主库。可以全部请求全部强制走主库，也可以部分请求走主库。比如写操作结束后，可以将刚写的key放入缓存，设置较小的过期时间。读操作时，如果key在缓存中存在，说明可能存在延迟，需要从主库读。如果key不在缓存中，则走从库。</li>
</ol>
<h3 id="数据库分库分表"><a href="#数据库分库分表" class="headerlink" title="数据库分库分表"></a>数据库分库分表</h3><p>按照业务进行垂直拆分。</p>
<p>按照数据特征进行水平拆分：引入分区键，即需要先确认去哪张表里查询。</p>
<p>如果我们要查询的字段不是分区键该怎么办，有以下两个办法：</p>
<ol>
<li>建立以该字段为分区键的拆分存储，这会极大增加存储成本；</li>
<li>建立该字段与分区键的映射表，由于该表字段较少，可以节省存储成本。</li>
</ol>
<h4 id="迁移方案"><a href="#迁移方案" class="headerlink" title="迁移方案"></a>迁移方案</h4><ol>
<li>将新的库配置为源库的从库，那么从库里的数据会慢慢追上源库；</li>
<li>改造业务代码，写操作变为双写源库和新库，读操作还是在源库上。这里要注意的是，改为双写之前需要停止从库与源库之间的数据同步；</li>
<li>校验数据。对比源库和新库里的数据是否一致，是否有漏数据的情况。</li>
<li>灰度切读流量，将流量由源库切到从库。如果切的过程中有问题，可以安全切回至源库，因为这时两个库的数据是一样的。</li>
</ol>
<h2 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h2><h3 id="静态缓存"><a href="#静态缓存" class="headerlink" title="静态缓存"></a>静态缓存</h3><p>可放在CDN、Nginx服务器上</p>
<h3 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h3><p>如Redis</p>
<h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><p>遇到极端热点数据时，可采用本地缓存。如Guava Cache。</p>
<p>如何更新各个服务器上的缓存：</p>
<ol>
<li>使用配置中心</li>
<li>等待缓存过期之后触发加载</li>
</ol>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><ol>
<li>回种空值是一种最常见的解决思路，实现起来也最简单，如果评估空值缓存占据的缓存空间可以接受，那么可以优先使用这种方案；</li>
<li>布隆过滤器会引入一个新的组件，也会引入一些开发上的复杂度和运维上的成本。所以只有在存在海量查询数据库中，不存在数据的请求时才会使用，在使用时也要关注布隆过滤器对内存空间的消耗；</li>
<li>对于极热点缓存数据穿透造成的“狗桩效应”，可以通过设置分布式锁或者后台线程定时加载的方式来解决。</li>
</ol>
<h2 id="Redis高可用"><a href="#Redis高可用" class="headerlink" title="Redis高可用"></a>Redis高可用</h2><p>redis扩展主要两方面。主备方案以及集群方案。</p>
<ul>
<li><p>主备的话可以用redis的sentinel（哨兵）。主要解决redis主节点故障后的自动切换。哨兵负责持续监控主从节点的健康，当主节点挂掉时，自动选择一个最优的从节点切换为主节点。</p>
</li>
<li><p>Redis集群主要涉及数据分片。分片主要有三种方案：客户端分片，中间代理分片，服务端分片。</p>
<p>客户端分片方案不是在多个语言之间复用，而且升级客户端SDK需要推到业务去升级。</p>
<p>中间代理方案可以做到跨语言的使用，该方案有豌豆荚的Codis、Twitter的Twemproxy、FB的Mcrouter等。</p>
<p>服务端分片是Redis3.0推出的官方集群解决方案，在该方案中，redis中共有16384个slot，<code>slot = CRC16(key) % 16384</code>，每个实例负责其中的几个solt。主流方案有codis和官方的cluster。 </p>
</li>
</ul>
<h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><h4 id="发号器"><a href="#发号器" class="headerlink" title="发号器"></a>发号器</h4><p>leaf-segment：基于数据库，可通过id反推出主键数量。</p>
<p>leaf-snowflake：无依赖，时间戳+机器号+递增号</p>
<h2 id="缓存读写策略"><a href="#缓存读写策略" class="headerlink" title="缓存读写策略"></a>缓存读写策略</h2><ol>
<li><p>Cache Aside是我们在使用分布式缓存时最常用的策略。 </p>
<p>对于写操作，先写数据库，再删除缓存。</p>
<p>对于读操作，缓存命中则返回，未命中需读数据库然后回种缓存。</p>
<p>以上是比较标准的Cache Aside模式，实际使用中都会针对性的修改一下。如果采用标准的Cache Aside模式，会出现并发读写导致数据不一致的问题。</p>
</li>
<li><p>Read/Write Through和Write Back策略需要缓存组件的支持，所以比较适合本地缓存，如Guava Cache。</p>
</li>
<li><p>Write Back策略是计算机体系结构中的策略，不过写入策略中的只写缓存，异步写入后端存储的策略倒是有很多的应用场景。 </p>
</li>
</ol>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>高性能</tag>
        <tag>高可用</tag>
        <tag>可扩展</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP</title>
    <url>/2019/12/01/HTTP/</url>
    <content><![CDATA[<p>Http1.1虽然有着pipeline，但响应和请求还是按顺序出现的。如果前面的响应阻塞了，后面的响应也会跟着阻塞。</p>
 <a id="more"></a> 

<p>Http2引入了多路复用，每个响应带有stream id，一个连接里可以穿插着多个stream id，可以不按照顺序出现。Http流量控制可以对单个stream进行。而TCP的流控只能对一个连接进行控制，粒度没有TCP的细。</p>
]]></content>
      <categories>
        <category>网络协议</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>配置中心</title>
    <url>/2019/11/25/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    <content><![CDATA[<h1 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h1><a id="more"></a> 

<h2 id="基于Git的配置中心"><a href="#基于Git的配置中心" class="headerlink" title="基于Git的配置中心"></a>基于Git的配置中心</h2><p>在Spring Cloud中，配置中心是基于Git实现的。config-server是配置服务器，会将配置的相关操作以http的形式暴露出去。client是应用服务器，对于config-server来说，它是client。client在启动时会从config-server加载数据。</p>
<embed src="Config_Git.svg" width="100%" type="image/svg+xml">
图1是较为简单的配置中心，这个配置中心有一个问题：client端的配置不能动态更新。因为client只会在启动时加载配置，后续如果修改了git中的内容，client中的内容不会变。如果期望client获取最新数据，需要按如下步骤：

<ol>
<li>使用git push修改配置；</li>
<li>手动调用client的/bus/refresh接口主动更新配置；</li>
<li>client请求server获取配置；</li>
<li>server请求git获取配置。</li>
</ol>
<p>图2是改进版的配置中心，能够做到client端配置的动态更新。</p>
<ol>
<li>使用git push修改配置；</li>
<li>git服务器发现有push事件，于是调用server的/bus/refresh接口（这项功能需要依赖git hook）；</li>
<li>server将更新消息发送给MQ；</li>
<li>client监听MQ，发现有更新消息；</li>
<li>client请求server获取配置；</li>
<li>server请求git获取配置。</li>
</ol>
<h2 id="基于Zookeeper的配置中心"><a href="#基于Zookeeper的配置中心" class="headerlink" title="基于Zookeeper的配置中心"></a>基于Zookeeper的配置中心</h2><p>zookeeper可以理解为<strong>文件系统+监听机制</strong>，client监听zk上的节点，若节点数据发生变化，会通知client更新配置。</p>
<h2 id="基于Http长轮询的配置中心"><a href="#基于Http长轮询的配置中心" class="headerlink" title="基于Http长轮询的配置中心"></a>基于Http长轮询的配置中心</h2><p>client使用http长轮询连接上server，若配置有变化，可通过http形式推送至client。</p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>限流算法</title>
    <url>/2019/11/23/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h1><a id="more"></a> 

<h3 id="固定窗口算法"><a href="#固定窗口算法" class="headerlink" title="固定窗口算法"></a>固定窗口算法</h3><p>基于固定时间窗口的限流算法是非常简单的。首先需要选定一个时间起点，之后每次接口请求到来都累加计数器。如果在当前时间窗口内，累加访问次数超过限流值，则限流熔断拒绝接口请求。当进入下一个时间窗口之后，计数器清零重新计数。</p>
<p>这种算法的缺点在于：限流策略过于粗略，无法应对两个时间窗口临界时间内的突发流量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//固定窗口示例</span></span><br><span class="line"><span class="comment">//延时计算，在访问时再计算</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> <span class="keyword">throws</span> InternalErrorException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> updatedCount = currentCount.incrementAndGet();</span><br><span class="line">    <span class="keyword">if</span> (updatedCount &lt;= limit) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lock.tryLock(TRY_LOCK_TIMEOUT, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (stopwatch.elapsed(TimeUnit.MILLISECONDS) &gt; TimeUnit.SECONDS.toMillis(<span class="number">1</span>)) &#123;</span><br><span class="line">                    currentCount.set(<span class="number">0</span>);</span><br><span class="line">                    stopwatch.reset();</span><br><span class="line">                &#125;</span><br><span class="line">                updatedCount = currentCount.incrementAndGet();</span><br><span class="line">                <span class="keyword">return</span> updatedCount &lt;= limit;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalErrorException(<span class="string">"tryAcquire() wait lock too long:"</span> + TRY_LOCK_TIMEOUT + <span class="string">"ms"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalErrorException(<span class="string">"tryAcquire() is interrupted by lock-time-out."</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h3><p>滑动时间窗口算法是对固定时间窗口算法的一种改进，流量经过滑动时间窗口算法整形之后，可以保证任意时间窗口内，都不会超过最大允许的限流值。对比固定时间窗口限流算法，滑动时间窗口限流算法的时间窗口是持续滑动的，并且除了需要一个计数器来记录时间窗口内接口请求次数之外，还需要记录在时间窗口内每个接口请求到达的时间点，对内存的占用会比较多。 </p>
<p>实现上可以基于循环队列实现。</p>
<h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p>上面介绍了两种基于时间窗口的限流算法。这两种限流算法都无法应对细时间粒度的突发流量，对流量的整形效果在细时间粒度上不够平滑。</p>
<p>令牌桶算法试一种更滑平滑的限流算法。令牌桶算法大致思路：</p>
<ol>
<li>接口限制 t 秒内最大访问次数为 n，则每隔 t/n 秒会放一个 token 到桶中；</li>
<li>桶中最多可以存放 b 个 token，如果 token 到达时令牌桶已经满了，那么这个 token 会被丢弃；</li>
<li>接口请求会先从令牌桶中取 token，拿到 token 则处理接口请求，拿不到 token 则执行限流。</li>
</ol>
<h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>漏桶算法对流量的整形效果更加好，流量更加平滑，任何突发流量都会被限流。漏桶算法对于取令牌的频率也有限制，要按照 t/n 固定的速度来取令牌。</p>
<p>令牌桶和漏桶算法比较适合阻塞式限流，比如一些后台 job 类的限流，超过了最大访问频率之后，请求并不会被拒绝，而是会被阻塞到有令牌后再继续执行。</p>
<p>基于时间窗口的算法比较适合否决式限流，比如线上接口这种对响应时间比较敏感的限流场景。</p>
<h3 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h3><p>基于Redis+Lua实现集群限流。不需要加锁，Redis+Lua会以原子的方式运行。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> limit = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> current = <span class="built_in">tonumber</span>(redis.call(<span class="string">'incr'</span>, key))</span><br><span class="line"><span class="keyword">if</span> current &gt; limit <span class="keyword">then</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">elseif</span> current == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">   redis.call(<span class="string">'expire'</span>, key, <span class="string">'1'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4MTY5NTk4Ng==&amp;mid=2247488993&amp;idx=1&amp;sn=4b9d5deedd0e626c456744f04b499bbb&amp;source=41#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI4MTY5NTk4Ng==&amp;mid=2247488993&amp;idx=1&amp;sn=4b9d5deedd0e626c456744f04b499bbb&amp;source=41#wechat_redirect</a> </p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>限流</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap</title>
    <url>/2019/11/13/HashMap/</url>
    <content><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><a id="more"></a>

<p>equals()相同的两个对象，hashCode()一定要相同。</p>
<p>equals()不同的两个对象，hashCode()可以相同也可以不同。</p>
<p>Object的hashCode()默认实现是将Object的地址转换为一个int变量。</p>
<p>Object的equals()默认实现是比较两个对象是否指的是一个对象。</p>
<p>比较两个对象时，可以先粗略地用hashCode进行比较，若不一致，则返回结果；若一致，则用==或者equals继续比较。</p>
<h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><ol>
<li><p>对key的原始hash值进行处理，在低位bit上加入高位bit信息，目的是减少小容量map的冲突。</p>
</li>
<li><p>根据table的长度，对处理后的hash值截取低位bit。</p>
</li>
<li><p>若该table槽为null，新增节点放入table；若该table槽不为null，则表明有冲突，HashMap采用拉链法解决冲突。</p>
</li>
</ol>
<h2 id="size"><a href="#size" class="headerlink" title="size"></a>size</h2><p>HashMap有个成员变量size，求size的时间复杂度是O(1)。HashMap在put时size+1，在remove时size-1。</p>
<h2 id="ConcurrentModificationException"><a href="#ConcurrentModificationException" class="headerlink" title="ConcurrentModificationException"></a>ConcurrentModificationException</h2><p>在遍历HashMap的过程中，如果进行了写操作，例如put, remove, clear等。HashMap会报并发修改错误。</p>
<p>这个是通过modCount变量实现的。在每个写操作中，modCount都会+1，表明经过了一次修改。在遍历开始时，当前的modCount会被记录下来记作m，每次遍历到一个元素时会检查当前modCount是否等于m，不相等说明发生了并发修改。</p>
<h2 id="Java-7"><a href="#Java-7" class="headerlink" title="Java 7"></a>Java 7</h2><h3 id="非线程安全"><a href="#非线程安全" class="headerlink" title="非线程安全"></a>非线程安全</h3><p>大家都知道HashMap是非线程安全的，在多线程情况下使用会出现问题，但具体会出现什么问题呢。下面我们来看一下多线程下，HashMap会出现的两个比较典型的问题：死循环和数据丢失。其实这两个问题并不是全部，由于多线程下，HashMap在各个地方都会出现问题，问题多多，所以这里就拿这两个例子来说明。</p>
<h4 id="链表成环"><a href="#链表成环" class="headerlink" title="链表成环"></a>链表成环</h4><p>当两个线程都在进程扩容时，容易发生链表成环。线程A运行过语句<code>Entry&lt;K,V&gt; next = e.next;</code>之后就挂起。此时<strong>e和next在一个链表上且顺序相反</strong>。CPU开始运行线程B，线程B完成扩容后将CPU让出（图1）。图2\图3\图4去掉了与线程B相关的东西，专注在线程A的行为上。它们演示了经过3个循环，链表最终成环。</p>
<h4 id="数据丢失"><a href="#数据丢失" class="headerlink" title="数据丢失"></a>数据丢失</h4><p>我们调换一下原始节点在链表中的顺序，使得扩容后<strong>e和next分布在两个链表上</strong>，这样的话，e之前的节点都会丢失。</p>
<h2 id="Java-8的改进"><a href="#Java-8的改进" class="headerlink" title="Java 8的改进"></a>Java 8的改进</h2><h3 id="链表优化为树"><a href="#链表优化为树" class="headerlink" title="链表优化为树"></a>链表优化为树</h3><p>java8对table[]后面的链表进行了优化，当链表中节点个数≥8的时候，链表就会变为红黑树。当节点个数小于等于6的时候，红黑树又会变为链表。</p>
<ul>
<li>为什么是8：当节点个数小于8的时候，链表遍历的平均时间复杂度(n/2，n=8时，需遍历4个节点)高于红黑树(O(logn)，n=8时，需遍历3个节点）。</li>
<li>为什么是6：为防止节点个数频繁变化导致的链表与红黑树相互转化，该值不能设置为8，设置为6比较合适。</li>
</ul>
<h3 id="对原始hash值的处理"><a href="#对原始hash值的处理" class="headerlink" title="对原始hash值的处理"></a>对原始hash值的处理</h3><p>在java8中，对原始hash值的处理相对简单很多。较为简单的处理会导致冲突加剧，即截取低位bit后的节点会分布不均匀。那么较为严重的冲突所带来的查找效率低下可以被红黑树所缓解一些。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java7</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//java8</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="rehash逻辑变化"><a href="#rehash逻辑变化" class="headerlink" title="rehash逻辑变化"></a>rehash逻辑变化</h3><p>在java7中，扩容时rehash，采用<code>hash &amp; (length-1)</code>计算出新的数组下标，该值是绝对值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java7扩容rehash</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在java8中，采用<code>hash &amp; oldCap</code>计算出新的数组下标的相对值。rehash其实就是在原有hash基础上往高位再多取1bit。该bit位为0，rehash后数组下标不变；该bit位为1，rehash后数组下标需要加上原数组的大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java8扩容rehash（链表情况下）</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    next = e.next;</span><br><span class="line">    <span class="comment">//rehash后节点所在的数组下标不变</span></span><br><span class="line">    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">            loHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            loTail.next = e;</span><br><span class="line">        loTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//rehash后节点所在的数组下标需要加上原数组长度</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">            hiHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hiTail.next = e;</span><br><span class="line">        hiTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">    loTail.next = <span class="keyword">null</span>;</span><br><span class="line">    newTab[j] = loHead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">    hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">    newTab[j + oldCap] = hiHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩容时倒序优化为顺序"><a href="#扩容时倒序优化为顺序" class="headerlink" title="扩容时倒序优化为顺序"></a>扩容时倒序优化为顺序</h3><p>在多线程对HashMap进行扩容时，链表rehash到新的数组后，顺序与原链表相反。这样子会造成链表成环，get()元素的时候进入死循环。HashMap是非线程安全的，虽然它的实现没有问题，是使用者错误使用了HashMap，但作者还是对这个点进行了优化，这个优化减少了错误使用HashMap时的问题。   </p>
<embed src="java7_HashMap.svg" width="100%" type="image/svg+xml">

<embed src="java7_HashMap_loop.svg" width="100%" type="image/svg+xml">
<embed src="java7_HashMap_miss.svg" width="100%" type="image/svg+xml">
<embed src="java8_HashMap.svg" width="100%" type="image/svg+xml">
<embed src="扩容.svg" width="100%" type="image/svg+xml">
]]></content>
      <categories>
        <category>Java知识</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap</title>
    <url>/2019/11/12/ConcurrentHashMap/</url>
    <content><![CDATA[<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><h2 id="java7"><a href="#java7" class="headerlink" title="java7"></a>java7</h2><p>java7中的ConcurrentHashMap主要使用分段锁保证线程安全。只能有一个线程对segment中的table[]进行写操作，读操作不加锁。</p>
<a id="more"></a>

<embed src="java7_ConcurrentHashMap.svg" width="100%" type="image/svg+xml">
### put

<ol>
<li>对原始hash值进行处理，目的是减少冲突</li>
<li>取处理之后的hash值最高几位当做segment数组下标</li>
<li>用CAS对segment进行初始化</li>
<li>使用非阻塞的方式对segment尝试加锁，成功加锁则可以往里写；加锁失败则等待释放锁</li>
<li>插入链表头部</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap的put方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);<span class="comment">//处理原始hash值</span></span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;<span class="comment">//计算segment的数组下标</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject</span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>)</span><br><span class="line">        s = ensureSegment(j);<span class="comment">//初始化segment</span></span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//segment的put方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">    scanAndLockForPut(key, hash, value);<span class="comment">//写操作前对segment加锁</span></span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="comment">//需要遍历链表确认是否有相同的key</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若无相同的key，则将新节点插入链表头部</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回相应数组下标的segment，若不存在则新建</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    <span class="comment">//检查segment是否已存在</span></span><br><span class="line">    <span class="comment">//后续还会对这一点进行多次检查。在每次new之前都会检查一遍，目的是防止资源浪费</span></span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>];<span class="comment">//segment[0]在最开始已经初始化</span></span><br><span class="line">        <span class="keyword">int</span> cap = proto.table.length;</span><br><span class="line">        <span class="keyword">float</span> lf = proto.loadFactor;</span><br><span class="line">        <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">        <span class="comment">//再次检查</span></span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">            == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            <span class="comment">//while搭配CAS使用，只允许一个线程新建segment</span></span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                   == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//尝试加锁失败，则等待释放锁，在等待时还可以提前先把Node创建起来</span></span><br><span class="line"><span class="comment">//用自旋的方式等待，自旋一定次数后，若还没释放，则挂起线程等待</span></span><br><span class="line"><span class="comment">//若自旋时发现链表头结点发生变化，则重新遍历链表并重新自旋????????为什么这么设计</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>遍历segment，把每个segment中的数量累加起来。这样的遍历做两次，对比这两次的modCount结果是否一致（任何一个写操作都会使得modCount变量+1，modCount只增不减，类似于版本号）。时间复杂度为O(n)，n为segment的数量。</p>
<ul>
<li>若一致，说明没有并发操作，这个size准确。</li>
<li>若不一致，说明有并发写操作，需要做第三次的遍历。第三次的modCount结果若与第二次相同，则返回size。若不相同，说明有并发，此时会获取全部segment的锁，再计算size。这时是进行不了任何写操作的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">    <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//循环3遍，都有并发干扰计算结果，此时需要锁全部segment</span></span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock();</span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0L</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//遍历全部segment，累加每个segment的size</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//modCount不变，说明无并发干扰，可以返回结果</span></span><br><span class="line">            <span class="keyword">if</span> (sum == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="java8"><a href="#java8" class="headerlink" title="java8"></a>java8</h2><p>java8中的ConcurrentHashMap去掉了分段锁，采用了粒度更细的锁。写操作对单个链表或树进行加锁。</p>
<embed src="java8_ConcurrentHashMap.svg" width="100%" type="image/svg+xml">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());<span class="comment">//对原始hash值进行处理</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//如果table数组中该槽为空，则使用CAS新增</span></span><br><span class="line">        <span class="comment">//新增成功则返回；新增失败需要重新进入循环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果处于扩容状态，该线程会帮忙进行扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="comment">//已经存在链表或树，需要锁住头节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                              value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="size-1"><a href="#size-1" class="headerlink" title="size"></a>size</h3><p>java8推荐使用mappingCount()方法，用于代替size()。mappingCount()返回long型，范围比size()的int型要大。</p>
<p>如果ConcurrentHashMap在非并发环境下进行写操作，那么元素的计数结果都会体现在baseCount成员变量上。如果出现并发，那么就会将计数结果更新到CounterCell[]数组，每个并发线程都在数组里拥有一个自己的槽。所以整个Map的元素数量就是baseCount+CounterCell[]数组中的数。</p>
<p>需要注意的是，mappingCount()和size()计算出来的是近似数，可能在过程中，还有线程在累加CounterCell[]，这个结果未能反映到最终结果中。</p>
<p>而java7中ConcurrentHashMap的size()求得的结果就不是近似值，是准确值。因为它能保证在方法的“调用时刻”和“返回时刻”之间，无写操作进入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">mappingCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0L</span>) ? <span class="number">0L</span> : n; <span class="comment">// ignore transient negative values</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与LongAdder原理类似</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于java8的ConcurrentHashMap的size()计算与LongAdder原理类似，这里就简单介绍一下LongAdder。</p>
<p>LongAdder是java8并发包中新引入的原子类，解决的是AtomicLong在高并发情况下的性能问题。原子类中有个value的成员变量，对value的CAS操作是一个自旋锁，在冲突严重的情况下，该锁会运行较长时间。</p>
<p>LongAdder的基本思路就是<strong>分散热点</strong>，将value值分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的long值，只要将各个槽中的变量值累加返回。 </p>
<h1 id="ConcurrentHashMap扩容"><a href="#ConcurrentHashMap扩容" class="headerlink" title="ConcurrentHashMap扩容"></a>ConcurrentHashMap扩容</h1><embed src="java8_ConcurrentHashMap扩容.svg" width="100%" type="image/svg+xml">
## java7

<p>segment数组的大小在初始化后就不会改变，默认为16。只有segment里面的table可以扩容，table扩容时，会获取ReentrantLock，后续的写操作会阻塞。</p>
<p>接下来的扩容与HashMap类似。</p>
<h2 id="java8-1"><a href="#java8-1" class="headerlink" title="java8"></a>java8</h2><p>扩容时，会新建一个容量为原来2倍的nextTable数组，这个数组是多个线程共享的。</p>
<ol>
<li>A、B线程同时对table[0]进行转移，由于synchronized锁的保障，A线程在转移的同时，B线程会被synchronized锁阻塞 。</li>
<li>table[0]转移结束后，原来table[0]的地方会变为ForwardingNode(fwd，转发节点)，fwd用于表明该节点已处理完毕。对于读操作，fwd还能指引到新数组进行读操作。</li>
<li>A线程开始处理table[1]。</li>
<li>A线程处理完毕，将table[1]改为fwd。</li>
<li>B线程准备处理table[1]，发现该节点为fwd，表明已经被处理过，跳过该节点。</li>
<li>A线程处理table[2]，发现是null，于是可以直接将fwd放入table[2]。</li>
</ol>
]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>BigDecimal</title>
    <url>/2019/11/06/BigDecimal/</url>
    <content><![CDATA[<h1 id="BigDecimal和BigInteger"><a href="#BigDecimal和BigInteger" class="headerlink" title="BigDecimal和BigInteger"></a>BigDecimal和BigInteger</h1><p>在商业上进行计算的时候，如果使用float、double型变量，会造成丢失精度的问题。这种情况下应该使用BigDecimal。</p>
<a id="more"></a> 

<h2 id="double"><a href="#double" class="headerlink" title="double"></a>double</h2><p>以双精度为例，单精度原理相同。</p>
<p>64bit的双精度浮点数分为以下三个部分：</p>
<ul>
<li><p>sign bit(符号): 用来表示正负号。</p>
</li>
<li><p>exponent(指数): 用来表示次方数。</p>
</li>
<li><p>mantissa(尾数): 用来表示精确度。</p>
</li>
</ul>
<p>一个双精度浮点数的数值为：sign × 2^(exponent - 0x3ff) × 1.mantissa</p>
<p>mantissa从左到右第N位表示2^-N，从大到小依次为0.5、0.25、0.125….</p>
<p>浮点数的小数部分由2^-N组成，2^-N精度有限，并不能表示所有的小数。</p>
<h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><p>BigDecimal采用小数变整数的方法解决精度问题。既然小数不能精确表示，那么就将小数点去掉，变为整数。整数可以用二进制精确表示。整数由intCompact体现，被丢掉的小数点由scale体现。</p>
 <img src="/2019/11/06/BigDecimal/BigDecimal.png" title="BigDecimal"> 



<h2 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h2><p>如果我们要使用的数超过了long的值范围，可以使用BigInteger类。BigInteger里有int数组，它所表示的数就是由数组中的int连接起来。</p>
]]></content>
      <categories>
        <category>Java知识</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Pigeon</title>
    <url>/2019/11/05/Pigeon/</url>
    <content><![CDATA[<h1 id="Pigeon"><a href="#Pigeon" class="headerlink" title="Pigeon"></a>Pigeon</h1><p>调用者会有以下的配置，ReferenceBean是代理类，被代理的是远程服务。</p>
<a id="more"></a> 

<embed src="Pigeon.svg" width="100%" type="image/svg+xml">
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"echoService"</span> <span class="attr">class</span>=<span class="string">"com.dianping.pigeon.remoting.invoker.config.spring.ReferenceBean"</span> <span class="attr">init-method</span>=<span class="string">"init"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 服务全局唯一的标识url，默认是服务接口类名，必须设置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"http://service.dianping.com/demoService/echoService_1.0.0"</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 接口名称，必须设置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interfaceName"</span> <span class="attr">value</span>=<span class="string">"com.dianping.pigeon.demo.EchoService"</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 超时时间，毫秒，默认5000，建议自己设置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeout"</span> <span class="attr">value</span>=<span class="string">"2000"</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 序列化，hessian/fst/protostuff，默认hessian，可不设置--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serialize"</span> <span class="attr">value</span>=<span class="string">"hessian"</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 调用方式，sync/future/callback/oneway，默认sync，可不设置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"callType"</span> <span class="attr">value</span>=<span class="string">"sync"</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 失败策略，快速失败failfast/失败转移failover/失败忽略failsafe/并发取最快返回forking，默认failfast，可不设置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cluster"</span> <span class="attr">value</span>=<span class="string">"failfast"</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 是否超时重试，默认false，可不设置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeoutRetry"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 重试次数，默认1，可不设置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"retries"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ReferenceBean代理类的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(interfaceName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"invalid interface:"</span> + interfaceName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.objType = ClassUtils.loadClass(<span class="keyword">this</span>.classLoader, <span class="keyword">this</span>.interfaceName.trim());</span><br><span class="line">    InvokerConfig&lt;?&gt; invokerConfig = <span class="keyword">new</span> InvokerConfig(<span class="keyword">this</span>.objType, <span class="keyword">this</span>.url, <span class="keyword">this</span>.timeout, <span class="keyword">this</span>.callType,</span><br><span class="line">                                                       <span class="keyword">this</span>.serialize, <span class="keyword">this</span>.callback, <span class="keyword">this</span>.suffix, <span class="keyword">this</span>.writeBufferLimit, <span class="keyword">this</span>.loadBalance, <span class="keyword">this</span>.cluster,</span><br><span class="line">                                                       <span class="keyword">this</span>.retries, <span class="keyword">this</span>.timeoutRetry, <span class="keyword">this</span>.vip, <span class="keyword">this</span>.version, <span class="keyword">this</span>.protocol);</span><br><span class="line">    invokerConfig.setClassLoader(classLoader);</span><br><span class="line">    invokerConfig.setSecret(secret);</span><br><span class="line">    invokerConfig.setRegionPolicy(regionPolicy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(methods)) &#123;</span><br><span class="line">        Map&lt;String, InvokerMethodConfig&gt; methodMap = <span class="keyword">new</span> HashMap&lt;String, InvokerMethodConfig&gt;();</span><br><span class="line">        invokerConfig.setMethods(methodMap);</span><br><span class="line">        <span class="keyword">for</span> (InvokerMethodConfig method : methods) &#123;</span><br><span class="line">            methodMap.put(method.getName(), method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    checkMock(); <span class="comment">// 降级配置检查</span></span><br><span class="line">    invokerConfig.setMock(mock);</span><br><span class="line">    checkRemoteAppkey();</span><br><span class="line">    invokerConfig.setRemoteAppKey(remoteAppKey);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取被代理的服务</span></span><br><span class="line">    <span class="keyword">this</span>.obj = ServiceFactory.getService(invokerConfig);</span><br><span class="line">    configLoadBalance(invokerConfig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取被代理的服务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proxyRequest</span><span class="params">(InvokerConfig&lt;?&gt; invokerConfig)</span> <span class="keyword">throws</span> SerializationException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(ClassUtils.getCurrentClassLoader(invokerConfig.getClassLoader()),</span><br><span class="line">                                  <span class="keyword">new</span> Class[] &#123; invokerConfig.getServiceInterface() &#125;,</span><br><span class="line">                                  <span class="keyword">new</span> ServiceInvocationProxy(invokerConfig,InvokerProcessHandlerFactory.selectInvocationHandler(invokerConfig)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端请求的发送是责任链模式，发送前会经过许多的Filter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isInitialized) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Constants.MONITOR_ENABLE) &#123;</span><br><span class="line">            registerBizProcessFilter(<span class="keyword">new</span> RemoteCallMonitorInvokeFilter());</span><br><span class="line">        &#125;</span><br><span class="line">        registerBizProcessFilter(<span class="keyword">new</span> TraceFilter());</span><br><span class="line">        registerBizProcessFilter(<span class="keyword">new</span> FaultInjectionFilter());<span class="comment">//模拟故障</span></span><br><span class="line">        registerBizProcessFilter(<span class="keyword">new</span> DegradationFilter());<span class="comment">//降级</span></span><br><span class="line">        registerBizProcessFilter(<span class="keyword">new</span> ClusterInvokeFilter());</span><br><span class="line">        registerBizProcessFilter(<span class="keyword">new</span> GatewayInvokeFilter());</span><br><span class="line">        registerBizProcessFilter(<span class="keyword">new</span> ContextPrepareInvokeFilter());</span><br><span class="line">        registerBizProcessFilter(<span class="keyword">new</span> SecurityFilter());</span><br><span class="line">        registerBizProcessFilter(<span class="keyword">new</span> RemoteCallInvokeFilter());<span class="comment">//调用远程服务</span></span><br><span class="line">        bizInvocationHandler = createInvocationHandler(bizProcessFilters);</span><br><span class="line">        isInitialized = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端接收响应</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveResponse</span><span class="params">(InvocationResponse response)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//同个客户端可能同时会有多个请求在等待结果，那么如何区分返回的结果是哪个请求的呢</span></span><br><span class="line">    <span class="comment">//每个请求发送出去都会带有一个唯一标识，在响应返回时会带上这个标识</span></span><br><span class="line">    <span class="comment">//标识相同说明请求和响应是一对的</span></span><br><span class="line">    <span class="comment">//标识的实现是原子变量，在JVM维度中是唯一的</span></span><br><span class="line">    <span class="comment">//标识在集群是会重复的，但不影响配对。因为通信协议会保证响应返回对应的机器。</span></span><br><span class="line">    RemoteInvocationBean invocationBean = invocations.get(response.getSequence());<span class="comment">//</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callback callback = invocationBean.callback;</span><br><span class="line">        callback.callback(response);</span><br><span class="line">        callback.run();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        invocations.remove(response.getSequence());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock配合Condition实现等待。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SYNC、FUTURE都会使用到以下等待方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> InvocationResponse <span class="title">waitResponse</span><span class="params">(<span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!isDone()) &#123;</span><br><span class="line">            condition.await(timeoutLeft, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送请求都是调用netty的channel.write()，该方法是异步的，会在另一个线程里运行，待io结束之后会调用用户写好的listener。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//io结束，netty进行回调，释放条件锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.done = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (condition != <span class="keyword">null</span>) &#123;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
        <tag>IO模型</tag>
      </tags>
  </entry>
  <entry>
    <title>责任链模式</title>
    <url>/2019/11/03/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><p>责任链模式的定义：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系， 将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。这里就不再过多的介绍什么是责任链模式，主要来说说java中如何编写。主要从下面3个框架中的代码中介绍。</p>
<ul>
<li>servlet中的filter</li>
<li>dubbo中的filter</li>
<li>mybatis中的plugin 这3个框架在实现责任链方式不尽相同。</li>
</ul>
<h2 id="servlet中的Filter"><a href="#servlet中的Filter" class="headerlink" title="servlet中的Filter"></a>servlet中的Filter</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationFilterChain</span> <span class="keyword">implements</span> <span class="title">FilterChain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pos = <span class="number">0</span>; <span class="comment">//当前执行filter的offset</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n; <span class="comment">//当前filter的数量</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationFilterConfig[] filters;  <span class="comment">//filter配置类，通过getFilter()方法获取Filter</span></span><br><span class="line">    <span class="keyword">private</span> Servlet servlet</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; n) &#123;</span><br><span class="line">            ApplicationFilterConfig filterConfig = filters[pos++];</span><br><span class="line">            Filter filter = filterConfig.getFilter();</span><br><span class="line">            filter.doFilter(request, response, <span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// filter都处理完毕后，执行servlet</span></span><br><span class="line">            servlet.service(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码还算简单，结构也比较清晰，定义一个Chain，里面包含了Filter列表和servlet，达到在调用真正servlet之前进行各种filter逻辑。</p>
<h2 id="Dubbo中的Filter"><a href="#Dubbo中的Filter" class="headerlink" title="Dubbo中的Filter"></a>Dubbo中的Filter</h2><p>Dubbo在创建Filter的时候是另外一个方法，通过把Filter封装成 Invoker的匿名类，通过链表这样的数据结构来完成责任链，核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">buildInvokerChain</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; invoker, String key, String group)</span> </span>&#123;</span><br><span class="line">    Invoker&lt;T&gt; last = invoker;</span><br><span class="line">    <span class="comment">//只获取满足条件的Filter</span></span><br><span class="line">    List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);</span><br><span class="line">    <span class="keyword">if</span> (filters.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = filters.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            <span class="keyword">final</span> Filter filter = filters.get(i);</span><br><span class="line">            <span class="keyword">final</span> Invoker&lt;T&gt; next = last;</span><br><span class="line">            last = <span class="keyword">new</span> Invoker&lt;T&gt;() &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> filter.invoke(next, invocation);</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Mybatis中的Plugin"><a href="#Mybatis中的Plugin" class="headerlink" title="Mybatis中的Plugin"></a>Mybatis中的Plugin</h2><p>Mybatis可以配置各种Plugin，无论是官方提供的还是自己定义的，Plugin和Filter类似，就在执行Sql语句的时候做一些操作。Mybatis的责任链则是通过动态代理的方式，使用Plugin代理实际的Executor类。（这里实际还使用了组合模式，因为Plugin可以嵌套代理），核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plugin</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="keyword">private</span> Interceptor interceptor;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;      </span><br><span class="line">        <span class="keyword">if</span> (满足代理条件) &#123;</span><br><span class="line">            <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> Invocation(target, method, args));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);     </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//对传入的对象进行代理，可能是实际的Executor类，也可能是Plugin代理类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">        Class&lt;?&gt; type = target.getClass();</span><br><span class="line">        Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">        <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                    type.getClassLoader(),</span><br><span class="line">                    interfaces,</span><br><span class="line">                    <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.cnblogs.com/z-test/p/9319116.html" target="_blank" rel="noopener">https://www.cnblogs.com/z-test/p/9319116.html</a> </p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>责任链模式</tag>
        <tag>Servlet</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Guava限流</title>
    <url>/2019/10/31/Guava%E9%99%90%E6%B5%81/</url>
    <content><![CDATA[<h1 id="Guava限流"><a href="#Guava限流" class="headerlink" title="Guava限流"></a>Guava限流</h1><p>在Guava中提供的限流算法是令牌桶算法。默认是SmoothBursty模式。</p>
<a id="more"></a> 

<p>Guava实现与理论会有点不同。从理论上来看，令牌会定时地被加入到桶中，而在Guava的实现中，并没有定时器在运行，因为定时器这种实现方式太浪费资源。Guava使用的是基于时间差的令牌延时生成算法，具体来说，有以下两点：</p>
<ol>
<li><strong>延时</strong>：只有到需要使用限流器时，才去计算。如果新建了限流器，但一直没使用，这个限流器是不会去生成令牌的。</li>
<li><strong>时间差</strong>：需要生成令牌时，会拿当前时间与最后一次生成的时间做一个是时间差，然后根据生成速率可以计算出这段时间应该有多少个令牌生成。</li>
</ol>
<p>另外，Guava提供的限流器是不保证公平的。因为Guava使用synchronized来锁操作，而synchronized锁是非公平的。</p>
<p>创建限流器的时候会启动一个计时器，记录下创建时的时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//限流器获取令牌</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将令牌数转换为需要等待的时间</span></span><br><span class="line">    <span class="comment">//返回0代表不需要等待</span></span><br><span class="line">    <span class="keyword">long</span> microsToWait = reserve(permits);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果需要等待，会调用Thread.sleep(time)进行休眠</span></span><br><span class="line">    stopwatch.sleepMicrosUninterruptibly(microsToWait);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * microsToWait / SECONDS.toMicros(<span class="number">1L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//限流器核心流程</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserveEarliestAvailable</span><span class="params">(<span class="keyword">int</span> requiredPermits, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//生产令牌</span></span><br><span class="line">    resync(nowMicros);</span><br><span class="line">    <span class="keyword">long</span> returnValue = nextFreeTicketMicros;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算本次需消耗多少令牌</span></span><br><span class="line">    <span class="keyword">double</span> storedPermitsToSpend = min(requiredPermits, <span class="keyword">this</span>.storedPermits);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算本次需等待多少令牌</span></span><br><span class="line">    <span class="keyword">double</span> freshPermits = requiredPermits - storedPermitsToSpend;</span><br><span class="line">    <span class="keyword">long</span> waitMicros = storedPermitsToWaitTime(<span class="keyword">this</span>.storedPermits, storedPermitsToSpend)</span><br><span class="line">        + (<span class="keyword">long</span>) (freshPermits * stableIntervalMicros);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.nextFreeTicketMicros = LongMath.checkedAdd(nextFreeTicketMicros, waitMicros);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">        <span class="keyword">this</span>.nextFreeTicketMicros = Long.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.storedPermits -= storedPermitsToSpend;</span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//令牌生成</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resync</span><span class="params">(<span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nowMicros &gt; nextFreeTicketMicros) &#123;</span><br><span class="line">        <span class="comment">//生产令牌，用时间差除以生产速率，可以得到现在应该有多少令牌</span></span><br><span class="line">        storedPermits = min(maxPermits,</span><br><span class="line">                            storedPermits</span><br><span class="line">                            + (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros());</span><br><span class="line">        nextFreeTicketMicros = nowMicros;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Guava</tag>
        <tag>限流</tag>
      </tags>
  </entry>
  <entry>
    <title>algorithms</title>
    <url>/2019/10/20/algorithms/</url>
    <content><![CDATA[<h2 id="摊还分析法"><a href="#摊还分析法" class="headerlink" title="摊还分析法"></a>摊还分析法</h2> <a id="more"></a> 

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p><strong>常见题目</strong>：实现浏览器前进后退功能，表达式求解，括号匹配</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列可用在池化技术中，用于请求的排队等待</p>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>实现的要点是确定好队满和队空的判定条件</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>生产者-消费者模型</p>
<h3 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h3><p>基于CAS实现无锁并发队列</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>满足以下三个条件的问题可以使用递归：</p>
<ol>
<li><p>一个问题可以分解为多个子问题</p>
</li>
<li><p>该问题与子问题的数据规模不一样，但解决思路一样</p>
</li>
<li><p>存在递归终止条件</p>
</li>
</ol>
<p>我们找出问题与子问题的关系，写出<strong>递推公式</strong>，找出<strong>终止条件</strong>，根据这两项就可以直接得出代码。</p>
<p>我们思考递归时，不用去想每一层的调用关系和每一个步骤，因为这样的思考人脑很难去抽象。我们需要去<strong>假定子问题已经被解决</strong>，在子问题被解决的基础上去思考新问题。</p>
<p>递归是借助栈来实现的，所以用递归实现的地方都能改为迭代循环的方式来实现。</p>
<p><strong>常见题目</strong>：斐波那契数列、跳蛙跳台阶、二叉树遍历</p>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>a&amp;(a-1)：相当于将a最右边的1变成0</p>
<p><strong>常见题目</strong>：统计二进制中1的个数、判断是否2的幂次、m变成n需要变动几个二进制</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>当我们对数组内的元素进行删除时，可以不去删除和搬移元素，可以先标记该元素已被删除，等到数组没有更多空间时再一起处理。</p>
<p>这个思想与JVM标记清除的GC算法一样。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>写完链表代码后，需要检查边界条件是否正确：</p>
<ol>
<li>链表为空</li>
<li>链表只有1个节点</li>
<li>链表只有2个节点</li>
<li>代码处理头尾节点是否正确</li>
</ol>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>单链表的操作比较简单，遍历只能单向从头到尾。</p>
<p><strong>快慢指针</strong>常作为单链表解决问题的辅助手段。</p>
<p><strong>常见题目</strong>：链表反转，环的检测，求入环点，有序链表合并，求倒数第k个节点，回文单链表，求链表中间节点</p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p> <strong>常见问题</strong>：约瑟夫问题</p>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>工程中双向链表较为常用，因为它能在O(1)时间找到前驱节点。</p>
<p>例如Java中的LinkedList、LinkedHashMap中都涉及到双向链表。</p>
<p><strong>常见题目</strong>：LRU缓存（LinkedHashMap与LRU缓存原理是一样的，实现上有个小技巧：双端链表加一个header，双端链表其实是一个循环链表，这么做就不用判断表头表尾，相当于哨兵）</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>可以利用稳定排序算法对多个字段排序。比如对订单按照时间先后排序，相同时间的订单按照金额大小再排序。可以先按照金额进行排序，再按照时间进行稳定排序。</p>
<h3 id="O-n-2"><a href="#O-n-2" class="headerlink" title="O(n^2)"></a>O(n^2)</h3><ul>
<li>插入排序。工程上针对小规模数据较常用，相比冒泡排序，插入有着较少的交换次数；相比选择排序，插入是稳定的。</li>
<li>冒泡排序。比较并交换相邻两个元素。</li>
<li>选择排序。</li>
</ul>
<h3 id="O-n-logn"><a href="#O-n-logn" class="headerlink" title="O(n*logn)"></a>O(n*logn)</h3><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>优点是不管什么情况下，时间复杂度都稳定在O(n*logn)。缺点是空间复杂度为O(n)，需要辅助空间，工程中较少使用。</p>
<p><strong>*常见题目</strong>： 现在有10个接口访问日志文件，每个日志文件大小约300MB，每个文件里的日志都是按照时间戳从小到大排序的。希望将这10个较小的日志文件，合并为1个日志文件，合并之后的日志仍然按照时间戳从小到大排列。机器内存只有1GB。 </p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>工程上较为常用。分区点的选择是关键，如果每次都能选择到中间节点，时间复杂度是O(n*logn)。如果每次分区点都是头尾节点，那么时间复杂度就会退化为O(n^2)。工程中可以使用三数取中法或者随机法选择分区点。</p>
<p><strong>常见题目</strong>：求第K大的数</p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><h3 id="O-n"><a href="#O-n" class="headerlink" title="O(n)"></a>O(n)</h3><p>排序能做到线性时间是因为这些排序不是基于比较的。</p>
<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p>桶排序对排序数据的要求非常严格，要求数据能平均地分配到各个桶中。</p>
<p>桶排序比较适合用在外部排序中。</p>
<p><strong>常见题目</strong>： 有10GB的订单数据，希望按订单金额进行排序，但是内存有限，只有几百MB，没办法一次性把10GB的数据都加载到内存中。</p>
<p>根据年龄给100万用户排序。</p>
<h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p>计数排序属于桶排序，这里把它单独拎出来是因为它是特殊的桶排序。</p>
<p>相比于桶排序，计数排序中桶的粒度更小，小到只有一个单位，就省去了桶内排序。</p>
<p>计数排序适用于数据范围不大的情况。</p>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>基数排序要求数据可以分割出“位”来比较，且“位”的数据范围不能太大。对每一“位”使用桶排序，从低位一直排序到高位。</p>
<p><strong>常见题目</strong>：对10万个手机号码从小到大排序</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>二分查找对数据有以下要求：</p>
<ol>
<li>数据需要是有序的</li>
<li>数据存储在数组中</li>
<li>数据集太小（顺序遍历即可）或太大（数组占用连续空间）都不合适二分查找</li>
</ol>
<p>二分查找时间复杂度是O(logn)，对数级有时比常数级还要高效，因为常数级中的常数可能会很大。</p>
<p>能用二分查找解决的问题，一般也能用动态数据结构散列表和二叉树解决，他们有一个区别是：二分查找由于依赖数组，因此它的占用内存会小一点，不需要存储指针等额外数据。</p>
<p>如果用链表来实现二分查找，时间复杂度会是O(n)。</p>
<p>二分查找适合查找近似的数值，它有4种变体问题：</p>
<ol>
<li>查找第一个值等于给定值的元素</li>
<li>查找最后一个值等于给定值的元素</li>
<li>查找第一个大于等于给定值的元素</li>
<li>查找最后一个小于等于给定值的元素</li>
</ol>
<p><strong>常见题目</strong>： 有12万条IP区间与归属地的对应关系，如何快速定位出一个IP地址的归属地。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[202.102.133.0, 202.102.133.255]  山东东营市 </span><br><span class="line">[202.102.135.0, 202.102.136.255]  山东烟台</span><br></pre></td></tr></table></figure>

<p>循环数据的二分查找</p>
<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>跳表可以理解为链表版的“二分”查找。时间复杂度为O(logn)，空间复杂度为O(n)。跳表出现得比红黑树晚，在类库中有现成的红黑树代码，但没有跳表。</p>
<p><strong>常见题目</strong>：为什么redis使用跳表而不是红黑树。（1.跳表实现比较简单；2.在区间查找上，跳表效率比红黑树高）</p>
<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>散列表来源于数组，它借助散列函数对数组这种数据结构进行扩展。散列表有三个核心问题：<strong>散列函数设计</strong>、<strong>散列冲突解决</strong>、<strong>扩容策略</strong>。 </p>
<p>冲突解决方法：开放寻址法和链表法。</p>
<p>当数据量比较小、装载因子小的时候，适合采用开放寻址法。</p>
<p>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表</p>
<p> ThreadLocalMap通过线性探测的开放寻址解决冲突。</p>
<p><strong>常见题目</strong>：</p>
<ol>
<li>Word单词拼写检查</li>
<li>假设有10万条URL访问日志，如何按照访问次数给URL排序</li>
<li>有两个字符串数组，每个数组大约有10万条字符串，如何快速找出两个数组中相同的字符串</li>
<li>LRU缓存</li>
<li>配合跳表组成Redis有序集合</li>
</ol>
<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>哈希算法有以下特点：</p>
<ul>
<li>从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；</li>
<li>对输入数据非常敏感，哪怕原始数据只修改了一个Bit，最后得到的哈希值也大不相同；</li>
<li>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；</li>
<li>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。</li>
</ul>
<p>常用的哈希算法有MD5、SHA、DES、AES等。根据鸽巢原理，哈希算法一定是会有冲突的。</p>
<p>哈希算法有以下几点应用：</p>
<ol>
<li><p>安全加密</p>
</li>
<li><p>唯一标识</p>
</li>
<li><p>数据校验</p>
</li>
<li><p>散列函数</p>
</li>
<li><p>负载均衡。同一客户端请求路由到同一机器。</p>
</li>
<li><p>数据分片。</p>
<p>统计1T的搜索词日志，计算每个搜索词被搜索次数。</p>
<p>判断某张图片是否在图库中，图库有1亿张图片。</p>
</li>
<li><p>分布式存储。</p>
<p>对数据提取哈希，决定存储在哪台机器上。若新增机器，所有的数据都需要重新计算哈希。为了解决这个问题，可以使用一致性哈希算法，该算法不需要搬移全部数据，只需要将某几个小区间的数据搬移到新机器中。</p>
</li>
</ol>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p>除叶子节点外，每个节点都有左右两个子节点。</p>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>有一种二叉树，叶子节点都在最底下两层，最后一层叶子节都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做完全二叉树。 </p>
<p>完全二叉树比较适合用数组来存储，由于不需要存储左右子节点，比较节省空间。单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。</p>
<h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</p>
<p>二叉查找树相比散列表的优势：</p>
<ol>
<li>散列表是无序的，二叉查找树中序遍历可输出有序。</li>
<li>散列表需要扩容。</li>
<li>在冲突较严重的情况下，散列表性能不稳定。</li>
<li>散列表的构造比二叉树复杂，要考虑散列函数、扩容、缩容、冲突解决等，而二叉树只需要考虑平衡性。</li>
<li>由于装载因子的存在，散列表较为消耗空间。</li>
</ol>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于1。 </p>
<h3 id="平衡二叉查找树"><a href="#平衡二叉查找树" class="headerlink" title="平衡二叉查找树"></a>平衡二叉查找树</h3><p>结合平衡树和查找树的二叉树就是平衡查找二叉树了。 平衡二叉查找树是为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的。 </p>
<p>最先被发明的平衡二叉查找树是<strong>AVL树</strong>，它严格符合平衡二叉查找树的定义。</p>
<p>在工程中，红黑树要比AVL树更加常用。红黑树不是严格的平衡树。它的根节点到各个叶子节点的最长路径，有可能会比最短路径大一倍。</p>
<p>红黑树做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比AVL树要低。</p>
<p><strong>常见题目</strong>：</p>
<ol>
<li>前中后序遍历；</li>
<li>层序遍历（用队列）；</li>
<li>按层输出（用队列，且使用两个辅助变量）；</li>
<li></li>
</ol>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆是一种特殊的数，满足以下两个条件的树可以称之为堆：</p>
<ol>
<li>堆是一个完全二叉树；</li>
<li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。 </li>
</ol>
<p>既然堆是完全二叉树，那么堆就适合使用数组存储。从下标为1开始，假设一个节点下标为n，那么左右两个子节点的下标分别为2n和2n+1.</p>
<p>堆排序可分为两个阶段：<strong>建堆</strong>和<strong>排序</strong>。堆排序的时间复杂度是O(n*logn)</p>
<p>建堆：可以采用从下至上的<strong>插入数据</strong>的方法，假设刚开始数组里只有一个元素，每次往里插入一个元素，然后堆化。</p>
<p>排序：可以采用从上至下的<strong>删除数据</strong>的方法，将堆顶数据与最末尾的数据交换，然后重新堆化。</p>
<p>在工程中，堆排序没有快速排序快，有以下原因：</p>
<ol>
<li>堆排序是跳着访问元素的，对CPU缓存不友好；</li>
<li>由于堆排序需要建堆，建堆后的数据可能比之前更加无序。所以堆排序需要的交换次数会大于快速排序</li>
</ol>
<p>优先级队列是堆的一个应用方向。Java中PriorityQueue就是基于堆实现的。 </p>
<p><strong>常见题目</strong>：</p>
<ol>
<li><p>topK</p>
<p>维护一个大小为K的堆，每次新来数据就堆化数组，每次插入时间复杂度为O(logn)，取topK时间复杂度为O(1)（需要区别Partition方法的求第K大数）。</p>
</li>
<li><p>数据流的中位数</p>
<p>不仅仅可以求中位数，只要改变两个堆中的数据比例，就可以求类似“接口99响应时间”等问题了。</p>
</li>
<li><p>合并有序小文件</p>
<p>有100个小文件，每个文件的大小是100MB，每个文件中存储的都是有序的字符串。希望将这些100个小文件合并成一个有序的大文件。</p>
</li>
</ol>
<h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h2><h3 id="单模式匹配"><a href="#单模式匹配" class="headerlink" title="单模式匹配"></a>单模式匹配</h3><h4 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h4><p>BF算法中的BF是Brute Force，暴力匹配。时间复杂度是O(n*m)，其中n是主串长度，m是模式串长度。</p>
<p>BF算法简单简单朴素，效率低，但在实际开发中却较为常用。因为实际使用场景下，一般的字符串都比较小，选用BF效率影响不大。且BF算法简单不易出错。</p>
<h4 id="RK算法"><a href="#RK算法" class="headerlink" title="RK算法"></a>RK算法</h4><p>RK算法的全称叫Rabin-Karp算法，是由它的两位发明者Rabin和Karp的名字来命名的。 </p>
<p> RK算法的思路是这样的：我们通过哈希算法对主串中的n-m+1个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。哈希算法的选择很重要，理想情况下，时间复杂度是O(n)，n为主串长度。</p>
<h4 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h4><p>BM（Boyer-Moore）算法是一种非常高效的字符串匹配算法，在工程非常常用。有实验统计，它的性能是著名的KMP算法的3到4倍。我们可以在BF算法的基础上理解BM算法。</p>
<p>在BF算法中，模式串在匹配失败后会往后移动一位。BM算法就是找到规律，让模式串每次多往后移动几位，减少不必要的字符比较。</p>
<p>BM算法的时间复杂度分析起来是非常复杂，这篇论文“<a href="http://dl.acm.org/citation.cfm?id=127830" target="_blank" rel="noopener">Tight bounds on the complexity of the Boyer-Moore string matching algorithm</a>”证明了在最坏情况下，BM算法的比较次数上限是3n。 </p>
<p><strong>常见题目</strong>：文本编辑器的查找功能。</p>
<h4 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h4><p>KMP算法是根据三位作者（D.E.Knuth，J.H.Morris和V.R.Pratt）的名字来命名的。KMP算法的核心思想，跟BM算法非常相近。在模式串与主串匹配的过程中，当遇到不可匹配的字符的时候，我们希望找到一些规律，可以将模式串往后多滑动几位。</p>
<p>KMP算法的时间复杂度就是O(m+n) 。</p>
<h3 id="多模式匹配"><a href="#多模式匹配" class="headerlink" title="多模式匹配"></a>多模式匹配</h3><h4 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h4><p>Trie树，也叫“字典树”。顾名思义，它是一个树形结构。它是一种专门处理字符串匹配的数据结构， 用来解决<strong>在一组字符串集合中快速查找某个字符串</strong>的问题。Trie树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起。构建Tire树的时间复杂度是O(m)，m表示所有字符串的长度和。</p>
<p>将多个模式串构建成Tire树。Tire树构建完成后，就可以用主串来走这个Tire树了。时间复杂度为O(n)，n为要查询的主串长度。</p>
<p>Tire的存储是比较浪费空间的，我们需要在效率和空间中找到平衡。</p>
<p>实际上，字符串的匹配问题，笼统上讲，其实就是数据的查找问题。对于支持动态数据高效操作的数据结构，比如散列表、红黑树、跳表等等。这些数据结构也可以实现在一组字符串中查找字符串的功能。我们拿散列表和红黑树，跟Trie树比较一下。Tire树对多个模式串有一定的要求，若不满足以下要求，Tire树的空间消耗会比较大：</p>
<ol>
<li><p>字符串中包含的字符集尽量要小；</p>
</li>
<li><p>字符串的前缀重合尽量要多。</p>
</li>
</ol>
<p>Trie树更加适合查找前缀匹配的字符串问题。散列表或者红黑树更加适合精确匹配查找问题。</p>
<p><strong>常见题目</strong>：</p>
<ol>
<li>手机英文输入自动提示单词（ACM题目：POJ1451 T9 <a href="http://poj.org/problem?id=1451）；" target="_blank" rel="noopener">http://poj.org/problem?id=1451）；</a></li>
<li>搜索引擎的搜索关键词提示功能</li>
</ol>
<h4 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h4><p>AC自动机算法，全称是Aho-Corasick算法。其实，Trie树跟AC自动机之间的关系，就像单串匹配中朴素的串匹配BF算法，跟KMP算法之间的关系一样。<strong>AC自动机实际上就是在Trie树之上，加了类似KMP的next数组，只不过此处的next数组是构建在树上罢了</strong>。AC自动机适合大量文本中多模式串的精确匹配查找，时间复杂度可以到O(n*len)。len是模式串的平均长度。</p>
<p><strong>常见题目</strong>：论坛中的敏感词过滤。 </p>
<p>动态数据结构：散列表、二叉树、跳表</p>
<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><p>子问题之间没有相关性</p>
<p><strong>常见题目</strong>：求逆序对数量（借助归并排序）</p>
<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>回溯是一种在一组可能的解中，找到符合要求解的算法。剪枝操作可以增加回溯的效率。</p>
<p><strong>常见问题</strong>：深度优先遍历、01背包、8皇后、旅行商问题、全排列等。</p>
<h2 id="位运算-1"><a href="#位运算-1" class="headerlink" title="位运算"></a>位运算</h2><p>二进制1的个数（n&amp;(n-1)）</p>
<h2 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h2><p>杨氏矩阵是否存在某树（leetcode 74）</p>
<p>单峰值数组寻找峰值</p>
<p>多峰值数组寻找峰值</p>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>字符串翻转（单词，旋转）</p>
<h2 id="堆-1"><a href="#堆-1" class="headerlink" title="堆"></a>堆</h2><p>数据流中位数</p>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>二维矩阵中找字符串，不能重复（leetcode 79）</p>
<p>全排列</p>
<h2 id="二叉树-1"><a href="#二叉树-1" class="headerlink" title="二叉树"></a>二叉树</h2><ol>
<li><p>二叉树深度（leetcode 104后序遍历）</p>
</li>
<li><p>判断是否平衡二叉树（leetcode 110后序遍历）</p>
</li>
<li><p>判断是否为另一棵树的子结构（leetcode 572）</p>
</li>
<li><p>判断是否镜像树（leetcode 101）</p>
</li>
<li><p>二叉树的最大直径（与深度有关）</p>
</li>
<li><p>合并二叉树</p>
</li>
<li><p>求两个节点的最低公共祖先（leetcode 236）</p>
</li>
<li><p>前中后序遍历</p>
</li>
<li><p>中序遍历的下一个节点（优先考虑右子树最左节点，若不存在，则考虑父节点）</p>
</li>
</ol>
<h2 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h2><ol>
<li>判断是否单链表回文</li>
<li>奇偶链表反转</li>
<li>两个链表的第一个交叉点（交换遍历）</li>
</ol>
<h2 id="Bit-Map"><a href="#Bit-Map" class="headerlink" title="Bit Map"></a>Bit Map</h2><ol>
<li>使用10MB内存，找出40亿个整数的中位数</li>
<li>40亿个非负整数中找到出现两次的数</li>
<li>40亿个非负整数中找到没出现的数</li>
</ol>
<h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><p>连续子数组的最大和（DP）</p>
<p>下一个排列</p>
<ol>
<li>范围[1,n]共n+1个数，找唯一一个重复的数（使用环检测）</li>
<li>范围[0,n-1]共n个数，找重复的数（下标位置互换）</li>
<li>滑动窗口中的最大值</li>
<li>数组中找第K大的数（使用快排中的partition，O(n)，特例：找出出现次数超过一半的数，计数法？）</li>
<li>数组中找出TopK（1.使用partition，会修改数组；2.使用堆O(n*logk)，不会修改数组，适合大数据）</li>
<li>某数字在排序数组中出现的次数（两次二分查找找头尾，O(logn)）</li>
<li>数组中只出现一次的数/数组中出现两次的数（使用异或位运算）</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>MESI</title>
    <url>/2019/10/19/MESI/</url>
    <content><![CDATA[<h1 id="MESI"><a href="#MESI" class="headerlink" title="MESI"></a>MESI</h1><p>CPU运算速度很快，内存运算速度很慢，它们在运算速度上有着较大的差距，如果让CPU等待内存处理完数据再进行下一步操作，会造成CPU资源浪费，为了解决这个问题，CPU高速缓存应运而生。</p>
<a id="more"></a> 

<p>在多核CPU系统中，就会存在多个一级缓存，那么相同的数据就会出现副本，可能会造成缓存数据不一致，为了不让系统数据混乱。这里引入MESI来协议保证系统正常运行。</p>
<p>MESI是4种状态的首字母，它们分别是修改态（Modified）、独占态（Exclusive）、共享态（Shared）、无效态（Invalid）。代表了缓存中数据可能处于的状态。</p>
<h3 id="双核读取"><a href="#双核读取" class="headerlink" title="双核读取"></a>双核读取</h3><p>①CPU A发出了一条指令，从主内存中读取x：<br>    CPU A从主内存通过bus读取到 cache a中并将该cache line设置为E状态。<br>②CPU B发出了一条指令，从主内存中读取x：<br>    CPU B试图从主内存中读取x时，CPU A检测到了地址冲突，将x标记为S状态。此时x存储于cache a和cache b中，其状态都为S。</p>
<img src="/2019/10/19/MESI/1.png" title="双核读取"> 



<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>①CPU A发指令修改x：<br>    CPU A将x设置为M状态并通知缓存了x的CPU B，CPU B将cache b中的x设置为I状态。<br>    CPU A对x进行赋值。</p>
<img src="/2019/10/19/MESI/2.png" title="修改数据"> 



<h3 id="同步数据"><a href="#同步数据" class="headerlink" title="同步数据"></a>同步数据</h3><p>①CPU B发出指令读取x：<br>    CPU B通知CPU A，CPU A将修改后的数据同步到主内存和CPU B的cache，x的状态变为S。</p>
<img src="/2019/10/19/MESI/3.png" title="同步数据"> 



<p>MESI的状态转移中有两个需要特别注意的地方：</p>
<p>1.<strong>I–&gt;M，S–&gt;M</strong>。当CPU A对S状态的数据进行写操作时，需要在总线上发送invalidate请求，并等待其他CPU的invalidate acknowledge。同样地，对I状态的数据进行写操作，需要发送read invalidate请求并等待结果。这会降低CPU A的性能。</p>
<p>2.<strong>MES–&gt;I</strong>。CPU A发送invalidate请求给CPU B，CPU B收到请求后，并不能立即回复invalidate acknowledge，主要原因是invalidate cacheline的操作没有那么快完成，特别是cache比较繁忙的时候。这时，CPU往往进行密集的loading和storing的操作，而来自其他CPU的，对本CPU local cacheline的操作需要和本CPU密集的cache操作进行竞争，只要完成了invalidate操作之后，本CPU才会发送invalidate acknowledge。</p>
<p>针对以上两个地方，MESI协议使用Store Buffer和Invalidate Queue来优化性能。</p>
<img src="/2019/10/19/MESI/4.png" title="Store Buffer与Invalidate Queue"> 



<h4 id="Store-Buffer"><a href="#Store-Buffer" class="headerlink" title="Store Buffer"></a>Store Buffer</h4><p>一旦增加了Store Buffer，那么CPU A无需等待其他CPU的响应，只需要将要修改的内容放入Store Buffer，然后就可以继续执行。当cacheline完成bus transaction后，就可以将修改的数据将从Store Buffer写进cacheline。</p>
<h5 id="引入Store-Buffer之后的问题"><a href="#引入Store-Buffer之后的问题" class="headerlink" title="引入Store Buffer之后的问题"></a>引入Store Buffer之后的问题</h5><ol>
<li><p>CPU A运行foo()，CPU B运行bar()，a在CPU A中，b在CPU B中。</p>
</li>
<li><p>CPU A将a=1写进Store Buffer，发送read invalidate请求，然后执行b=1。</p>
</li>
<li><p>CPU B通过read请求读到b=1，循环。</p>
</li>
<li><p>在CPU B这端，a的值为0，并不是预期的1。这时invalidate请求还未到达CPU B，a不会变成I状态。</p>
</li>
</ol>
<p>具体过程可参考文献。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CPU A</span></span><br><span class="line"><span class="comment">//cacheline b</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CPU B</span></span><br><span class="line"><span class="comment">//cacheline a</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    assert(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Invalidate-Queues"><a href="#Invalidate-Queues" class="headerlink" title="Invalidate Queues"></a>Invalidate Queues</h4><p>CPU在响应invalidate请求时，其实不需要完成invalidate操作就可以回送acknowledgement消息。CPU可以将invalidate message放入Invalidate Queues，然后直接回应acknowledgement，表示自己已经收到请求，随后会慢慢处理。当然，再慢也要有一个度，例如在对x变量的invalidate处理完成之前，不会发送有关x的请求出去。</p>
<h5 id="引入Invalidate-Queues之后的问题"><a href="#引入Invalidate-Queues之后的问题" class="headerlink" title="引入Invalidate Queues之后的问题"></a>引入Invalidate Queues之后的问题</h5><p>与Store Buffer所带来的问题类似。在CPU B这端，invalidate操作并没有被真正执行，所以变量a的值为0且状态有效，并不会得到预期的1.</p>
<h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>硬件工程师为了将CPU性能发挥到极致，引入了Store Buffer和Invalidate Queues，那么相应地也带来了可见性和有序性的问题。于是硬件工程师又加入了Memory Barrier指令来解决上述问题。</p>
<p>看到这里，可能会有一个问题：硬件为什么不把这些底层的信息屏蔽掉呢，帮我们自动加上Memory Barrier就可以了？回答是不能的，因为软件经过编译处理变成硬件指令，硬件是不知道顶层业务逻辑的。</p>
<h4 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h4><p>CPU收到写Memory Barrier指令，要等到收到invalidate ack，并将store buffer中所有数据写到cacheline之后才会执行后续指令。</p>
<h3 id="读屏障"><a href="#读屏障" class="headerlink" title="读屏障"></a>读屏障</h3><p>CPU收到读Memory Barrier指令，要等到执行完Invalidate Queue中的所有invalidate命令之后才会执行后续指令。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CPU A</span></span><br><span class="line"><span class="comment">//cacheline b</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//写屏障</span></span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CPU B</span></span><br><span class="line"><span class="comment">//cacheline a</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">//读屏障</span></span><br><span class="line">    assert(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><p>MESI：<a href="https://www.cnblogs.com/yanlong300/p/8986041.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanlong300/p/8986041.html</a></p>
</li>
<li><p>Linux内核同步机制之（三）: <a href="http://www.wowotech.net/kernel_synchronization/memory-barrier.html" target="_blank" rel="noopener">http://www.wowotech.net/kernel_synchronization/memory-barrier.html</a></p>
</li>
<li><p>《Memory Barriers: a Hardware View for Software Hackers》</p>
</li>
<li><p>《Memory Barriers: a Hardware View for Software Hackers》翻译：<a href="http://www.wowotech.net/kernel_synchronization/Why-Memory-Barriers.html" target="_blank" rel="noopener">http://www.wowotech.net/kernel_synchronization/Why-Memory-Barriers.html</a></p>
</li>
<li><p>《深入理解并行编程》作者Paul E. McKenney：<a href="http://www2.rdrop.com/users/paulmck/" target="_blank" rel="noopener">http://www2.rdrop.com/users/paulmck/</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java知识</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>CPU缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>CAS</title>
    <url>/2019/10/16/CAS/</url>
    <content><![CDATA[<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>比较并交换(CompareAndSwap, CAS)是原子性更新变量的一种方式。Java中将对变量的原子性操作封装成原子类。</p>
<a id="more"></a> 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AtomicInteger.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//valueOffset是偏移地址</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndSetInt(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Unsafe.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSetInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//获取旧值var5,compareAndSwapInt是个native方法</span></span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么<code>this.compareAndSwapInt(var1, var2, var5, var4)</code>再往下是什么呢？</p>
<p>最终在这个目录（<code>/hotspot/src/os_cpu/linux_x86/vm/atomic_linux_x86.inline.hpp</code>）可以看到compareAndSwapInt使用了CPU的底层指令。以下是linux_x86平台的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果是多核处理器的环境，需要在指令前加lock前缀</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) <span class="meta-string">"cmp $0, "</span> #mp <span class="meta-string">"; je 1f; lock; 1: "</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> jint Atomic::cmpxchg (jint exchange_value, <span class="keyword">volatile</span> jint* dest, jint compare_value) &#123;</span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  __<span class="function">asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>) <span class="string">"cmpxchgl %1,(%3)"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"=a"</span> (exchange_value)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"r"</span> (exchange_value), <span class="string">"a"</span> (compare_value), <span class="string">"r"</span> (dest), <span class="string">"r"</span> (mp)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于Intel平台，CPU使用cmpxchgl指令来完成该功能，但它并不是原子的。在多核环境下，需要加lock指令来保证原子性。那么lock指令会产生什么动作呢。在老CPU上面（486 &lt; CPU &lt; P6），Lock指令会锁总线，这样来自其他处理器的请求会被阻塞；在新CPU上面（CPU &gt; P6），Lock指令不会锁总线，而是会使用缓存一致性协议（MESI）来保证原子性。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>Intel开发手册：<a href="https://software.intel.com/en-us/articles/intel-sdm" target="_blank" rel="noopener">https://software.intel.com/en-us/articles/intel-sdm</a></p>
]]></content>
      <categories>
        <category>Java知识</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2019/10/16/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式，即对于一个类，只能有一个实例。由于构造函数可以新增实例，所以在所有的单例实现中，构造函数必须是private。以下列出四种常见的单例模式的实现方式。</p>
<a id="more"></a> 

<h2 id="1、枚举"><a href="#1、枚举" class="headerlink" title="1、枚举"></a>1、枚举</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类经过编译也会生成一个类，一个class文件。这个类会继承抽象类Enum，由于java不能多继承，所以枚举类是不能继承别的类的。枚举类中的枚举值，会变成该类中的静态常量，有几个枚举值，就会有几个静态常量。枚举能实现单例，本质上是使用了静态常量来达成的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反编译Singleton.class</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//编译器新增的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态代码块，非延时加载</span></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> Singleton(<span class="string">"INSTANCE"</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、静态常量"><a href="#2、静态常量" class="headerlink" title="2、静态常量"></a>2、静态常量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非延时加载，会浪费内存。</p>
<h2 id="3、静态内部类"><a href="#3、静态内部类" class="headerlink" title="3、静态内部类"></a>3、静态内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>延时加载，对内存友好。</p>
<h2 id="4、双重检查"><a href="#4、双重检查" class="headerlink" title="4、双重检查"></a>4、双重检查</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意变量singleton需要用volatile修饰，保证不被重排序和对其他线程的可见性。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
        <tag>volatile关键字</tag>
        <tag>synchronized关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>LockSupport</title>
    <url>/2019/10/15/LockSupport/</url>
    <content><![CDATA[<h1 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h1><a id="more"></a> 

<p>LockSupport类是基本的线程阻塞组件，在锁和其他同步器中都会使用到。park和unpark是它最核心的两个方法。</p>
<p>LockSupport替代了Thread.suspend和Thread.resume的功能，Thread的suspend和resume方法已经在JDK2中被弃用，原因是suspend方法在挂起线程时，并不会释放该线程持有的锁，这样可能会导致死锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LockSupport.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">        UNSAFE.unpark(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果已经存在一个许可的话（这里的许可可以通过调用unpark获取），调用park会立即返回。</p>
<p>如果没有许可的话，调用park会阻塞，需等待其他地方调用unpark唤醒。</p>
<p>许可不能累加，也就是说如果多次调用unpark，许可还是只有一个，只能允许后面一个park调用立即返回，第二个park会阻塞。</p>
<p>park方法应该放在一个循环中使用，因为会存在虚假唤醒的情况。</p>
<p>在LockSupport的实现中，UNSAFE.park()和UNSAFE.unpark()是native方法。在openjdk/hotspot/src/share/vm/prims/unsafe.cpp可以找到UNSAFE的实现，<code>thread-&gt;parker()-&gt;park(isAbsolute != 0, time);</code>在UNSAFE中调用了Parker类的方法。以下为linux下park、unpark的实现。有关许可的部分，是借助了_counter变量来实现的。</p>
<p>该实现主要使用了Pthread中的条件变量。有关Pthread可参考。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//openjdk/hotspot/src/os/linux/vm/os_linux.cpp</span></span><br><span class="line"><span class="comment">//已删去本次不关注的部分</span></span><br><span class="line"><span class="keyword">void</span> Parker::park(<span class="keyword">bool</span> isAbsolute, jlong time) &#123;</span><br><span class="line">  <span class="comment">//检查是否调用过unpark，若是，则不阻塞</span></span><br><span class="line">  <span class="keyword">if</span> (Atomic::xchg(<span class="number">0</span>, &amp;_counter) &gt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//条件等待时，需要加锁</span></span><br><span class="line">  <span class="keyword">if</span> (Thread::is_interrupted(thread, <span class="literal">false</span>) || pthread_mutex_trylock(_mutex) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//再次检查是否调用过unpark</span></span><br><span class="line">  <span class="keyword">int</span> status ;</span><br><span class="line">  <span class="keyword">if</span> (_counter &gt; <span class="number">0</span>)  &#123;</span><br><span class="line">    <span class="comment">//之前调用过unpark，存在一个许可，可立即返回</span></span><br><span class="line">    _counter = <span class="number">0</span>;</span><br><span class="line">    status = pthread_mutex_unlock(_mutex);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//进行条件等待</span></span><br><span class="line">  <span class="keyword">if</span> (time == <span class="number">0</span>) &#123;</span><br><span class="line">    status = pthread_cond_wait (&amp;_cond[_cur_index], _mutex) ;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    status = os::Linux::safe_cond_timedwait (&amp;_cond[_cur_index], _mutex, &amp;absTime) ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//等待到某个条件，释放锁</span></span><br><span class="line">  _counter = <span class="number">0</span> ;</span><br><span class="line">  status = pthread_mutex_unlock(_mutex) ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Parker::unpark() &#123;</span><br><span class="line">  <span class="comment">//加锁</span></span><br><span class="line">  status = pthread_mutex_lock(_mutex);</span><br><span class="line">  s = _counter;</span><br><span class="line">  <span class="comment">//将_counter设置为1，即使unpark在park之前被调用，park阻塞的线程也能被唤醒</span></span><br><span class="line">  _counter = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (s &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//如果s&lt;1，说明有线程阻塞，需要发信号唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (_cur_index != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (WorkAroundNPTLTimedWaitHang) &#123;</span><br><span class="line">        status = pthread_cond_signal (&amp;_cond[_cur_index]);</span><br><span class="line">        status = pthread_mutex_unlock(_mutex);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        status = pthread_mutex_unlock(_mutex);</span><br><span class="line">        status = pthread_cond_signal (&amp;_cond[_cur_index]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pthread_mutex_unlock(_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//s&gt;=1，说明当前无线程阻塞</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pthread_mutex_unlock(_mutex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java知识</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS原理</title>
    <url>/2019/10/13/AQS%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><h2 id="AQS的设计"><a href="#AQS的设计" class="headerlink" title="AQS的设计"></a>AQS的设计</h2><p>AQS（AbstractQueuedSynchronizer）是JDK1.5并发包引入的一个小型框架。它为并发包中的许多同步器提供了底层实现。</p>
 <a id="more"></a> 

<p>同步器的基本思路很简单，它有两个基本操作：获取锁和释放锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">获取锁(acquire):</span><br><span class="line"><span class="keyword">while</span> (synchronization state does not allow acquire) &#123;</span><br><span class="line">	enqueue current thread <span class="keyword">if</span> not already queued;</span><br><span class="line">	possibly block current thread;</span><br><span class="line">&#125;</span><br><span class="line">dequeue current thread <span class="keyword">if</span> it was queued;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">释放锁(release):</span><br><span class="line">update synchronization state;</span><br><span class="line"><span class="keyword">if</span> (state may permit a blocked thread to acquire)</span><br><span class="line">	unblock one or more queued threads;</span><br></pre></td></tr></table></figure>

<embed src="AQS_queue.svg" width="100%" type="image/svg+xml">

<p>AQS需要以下三个重要的部分协调工作：</p>
<h3 id="同步状态"><a href="#同步状态" class="headerlink" title="同步状态"></a>同步状态</h3><p>AQS类中有一个int型的变量，该变量是volatile的，保证了同步状态在线程间的可见性。AQS提供了三个方法来操作同步状态：getState、setState、compareAndSetState。</p>
<h3 id="线程阻塞"><a href="#线程阻塞" class="headerlink" title="线程阻塞"></a>线程阻塞</h3><p>AQS使用LockSupport.park阻塞线程，使用LockSupport.unpark解锁线程。有关LockSupport的详情，具体可参考这里。</p>
<h3 id="线程队列"><a href="#线程队列" class="headerlink" title="线程队列"></a>线程队列</h3><p>队列是AQS的核心，该队列是FIFO队列（FIFO队列不支持对线程进行优先级排序），用于维护处于等待锁状态的线程。关于队列，有CLH队列和MCS队列，两种队列的详情可参考这里。因为CLH队列能比较好地处理timeout和cancel线程这两种情况，因此AQS以CLH队列为基础，对其进行了改造。</p>
<p>CLH队列在刚被提出时，是用于自旋锁的，而在AQS中，它不再用于自旋锁。AQS对CLH做的最大的修改是新增了指向后继节点的变量。因为AQS在线程释放锁时，需要显式地去唤醒下一个在等待的线程。</p>
<p>修改后的队列就变成了双向链表。在不加锁的情况下，无法原子性地操作双向链表的前、后节点，那么可能会存在next指向null的情况，这个时候就需要从tail往前找。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>在AQS中，有以下方法可以被重写，且重写这些方法是唯一使用AQS的方法。AQS是一个抽象类，但其中没有抽象方法，它作为抽象类是希望有子类去继承它并重写以下几个方法。以下几个方法都不是抽象方法，如果把他们都定为抽象方法的话，每个子类都需要重写全部5个方法，但对于某些锁而言，只要重写其中tryAcquire和tryRelease两个方法即可。</p>
<ul>
<li>tryAcquire</li>
<li>tryRelease</li>
<li>tryAcquireShared</li>
<li>tryReleaseShared</li>
<li>isHeldExclusively</li>
</ul>
<p>除了以上几个方法外，AQS中其他都是final方法，表示不能被子类修改。这么设计的原因是，AQS是一个整体性的框架，只修改其中某个方法没有意义，会使得整个框架无法按照预期工作。</p>
<p>下面是一个使用AQS实现互斥锁Mutex的例子。在类中新建内部类Sync继承AQS，这是一种比较建议的方法。这样的话，不会把AQS的细节对外暴露，而且对外暴露的公有方法可以取合适的名字。比如CountDownLatch的await()、ReentrantLock的lock()、Semaphore的acquire()。</p>
<p>tryAcquire:当能获取同步状态时，该方法需返回true</p>
<p>tryRelease:当新的同步状态可以被别的线程获取，该方法需返回true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> ignore)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> compareAndSetState(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> ignore)</span> </span>&#123;</span><br><span class="line">            setState(<span class="number">0</span>); <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; sync.acquire(<span class="number">0</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; sync.release(<span class="number">0</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>《The java.util.concurrent Synchronizer Framework》</p>
]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadPoolExecutor</title>
    <url>/2019/09/20/ThreadPoolExecutor/</url>
    <content><![CDATA[<h1 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h1><a id="more"></a> 

<p>线程池共有7个参数可设置</p>
<ul>
<li><strong>corePoolSize</strong> 线程池核心线程数</li>
<li><strong>maximumPoolSize</strong> 线程池最大线程池</li>
<li><strong>keepAliveTime</strong> 空闲线程存活时间</li>
<li><strong>unit</strong> 存活时间单位</li>
<li><strong>workQueue</strong> 工作队列</li>
<li><strong>threadFactory</strong> 创建线程的工厂</li>
<li><strong>handler</strong> 拒绝策略</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<embed src="ThreadPoolExecutor.svg" width="100%" type="image/svg+xml">


<p>当线程数量大于core时，满足以下两个条件，线程池会开始回收线程：</p>
<ol>
<li>任务队列为空；</li>
<li>线程等待任务超过一定时间。</li>
</ol>
<p>ThreadPoolExecutor</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ThreadPoolExecutor.java</span></span><br><span class="line"><span class="comment">//execute的参数是Runnable，如果准备执行Callable，Callable会被包装成Runnable再调用该方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池中的线程数量小于corePoolSize，此时新增线程</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程数量已达到corePoolSize，此时将任务放入队列，不新增线程</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列已满，此时再次新增线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Worker</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ThreadPoolExecutor.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock();</span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//对于接收Runnable任务的线程池而言，这里的task.run就是运行任务本身</span></span><br><span class="line">                    <span class="comment">//对于Callable而言，run的是Futuretask。Futuretask将Callable包装成了Runnable</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FutureTask.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//这里包装了用户的Callable任务</span></span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FutureTask.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//waiters是一个线程安全的栈，里面保存了正在等待future结果的线程</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//唤醒在future.get等待着的线程</span></span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    done();</span><br><span class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FutureTask.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                q.thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">            q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            <span class="comment">//若任务还在执行中，则将该线程作为等待节点压入栈中</span></span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                 q.next = waiters, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//阻塞线程，等待FutureTask完成</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在FutureTask的set(result)中，除了改变任务的状态外，还唤醒了在等待的节点。</p>
]]></content>
      <categories>
        <category>Java知识</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal</title>
    <url>/2019/09/09/ThreadLocal/</url>
    <content><![CDATA[<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><a id="more"></a> 

<p>ThreadLocal类提供了thread-local的变量，即每个线程都持有一份各自独立的变量。每个线程都有一个ThreadLocalMap类型的变量，在Thread类中。</p>
<p>具体的ThreadLocalMap实例并不是ThreadLocal持有的，而是每个Thread持有，且不同的Thread持有不同的ThreadLocalMap实例, 因此它们不存在竞争。</p>
<p>下面是ThreadLocal对象引用图，下面的内容参考这张图看会更加容易理解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">    	map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建议使用static的ThreadLocal。既然是给整个线程使用的，那么将ThreadLocal定义成static就比较合理。</p>
<p>当使用局部变量结束后，ref指向ThreadLocal这个引用会消失，相应Entry的key会被回收。如果我们要再次使用ThreadLocal，那么就会new一个Entry。旧的Entry会在后续的操作中被回收。</p>
<p>ThreadLocal典型的应用是在web上。对于一个用户请求，web服务器会使用一个线程来服务这个请求。在web服务器中，线程的使用方式一般是线程池。我们一般可以在ThreadLocal中保存该用户的相关信息。</p>
<h2 id="为什么使用弱引用"><a href="#为什么使用弱引用" class="headerlink" title="为什么使用弱引用"></a>为什么使用弱引用</h2><p>ThreadLocalMap中的key是弱引用，value是强引用。使用弱引用的原因是提高内存利用率，防止内存泄露（只能防止特定情况下的内存泄露）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        Object value;</span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果key和value都是强引用的话，那么在整个线程活动中，Map中的对象是一直存在的，不能回收。换成弱引用的话，如果ThreadLocal ref这个强引用（如方法中的局部变量）消失的话，那么Map中的key就会被回收，key变为null。在后续对ThreadLocal的操作中（set/get/remove），ThreadLocal会检查key为null的Entry，并清除该Entry。但是，如果后续不对ThreadLocal进行操作，那个Entry中的value就会一直滞留，造成内存泄露。</p>
<p>如果使用了static的ThreadLocal，那么这条强引用就会一直存在，Entry中的弱引用就不会产生作用。</p>
<h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><h3 id="线程池的场景"><a href="#线程池的场景" class="headerlink" title="线程池的场景"></a>线程池的场景</h3><p><strong>在线程池场景下，必须使用remove</strong>。在该场景下，线程使用完毕并不会销毁，而是会回到池中等待下一次使用。如果在每次使用都set新对象的话，那么在Map中存储的值就会越来越多。由于指向Entry中的value的引用链一直是可到达的，旧的value不能回收，新的value不断往里放，导致内存泄露。</p>
<h3 id="非线程池的场景"><a href="#非线程池的场景" class="headerlink" title="非线程池的场景"></a>非线程池的场景</h3><p><strong>在非线程池的场景下，可以不使用remove</strong>。在该场景下，线程使用完毕会销毁，指向Entry的引用链不可达，这条链上的对象都会被回收。</p>
<embed src="ThreadLocal.svg" width="100%" type="image/svg+xml">]]></content>
      <categories>
        <category>Java知识</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven依赖</title>
    <url>/2019/08/05/Maven%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<h1 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h1><a id="more"></a> 

<h2 id="依赖传递性"><a href="#依赖传递性" class="headerlink" title="依赖传递性"></a>依赖传递性</h2><p>一般情况下，一个项目的依赖会从它的parent pom和dependency中得到。在允许依赖传递的情况下，整个项目的依赖关系会膨胀得非常快。以下几个因素为影响依赖的传递：</p>
<ol>
<li>依赖仲裁：一个artifact有多个版本的情况下，Maven会选择距离本项目最近的版本，如果两个依赖的距离是一样的，那么就选择第一个加载的依赖（这个加载顺序视情况而定）。A -&gt; B(1.0)和A -&gt; C -&gt; B(2.0)，这两种情况下，项目A会使用依赖B1.0版本。</li>
<li><em>Dependency management</em>： A -&gt; B和A -&gt; C -&gt; B，如果我们在A中新增Dependency management，不管这两个B使用什么版本，都以Dependency management中的版本为准。</li>
<li><em>Dependency scope</em>: 我们可以为依赖指定scope，每个scope的依赖传递性不同。</li>
<li><em>Excluded dependencies</em>: 我们可以Exclude掉依赖的依赖。</li>
<li><em>Optional dependencies</em>: 如果将一个pom A中的依赖B指定为optional，那么在其他项目中引用pom A，依赖B不会被自动引入，需要显式地引入B。</li>
</ol>
<h2 id="Dependency-management"><a href="#Dependency-management" class="headerlink" title="Dependency management"></a>Dependency management</h2><p>Dependency management主要用于统一管理依赖的版本。在项目中要引用Dependency management里面的依赖，最小的坐标是<strong>{groupId, artifactId, type, classifier}</strong>，在默认情况下，type=jar，classifier=null。一般情况下使用<strong>{groupId, artifactId}</strong>即可。</p>
<p>由于一个pom只有一个parent，在小规模项目中，可以在parent pom中设置Dependency management。对于多模块项目，就不能引入多个parent pom了。可以利用scope的import引入多个Dependency management。这里的每个pom可以被称为”bill of materials” (BOM)，我们将一组相关的依赖打包成bom pom。下面例举了两个项目的bom以及他们的使用方法。对于import的scope，只是将该依赖用该依赖的内容进行替换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-framework-bom&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.0.1.RELEASE&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.jboss.bom&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jboss-javaee-6.0-with-tools&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;some.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>效率工具</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven依赖</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/2019/06/28/Spring/</url>
    <content><![CDATA[<h1 id="Spring中如何避免bean别名循环依赖"><a href="#Spring中如何避免bean别名循环依赖" class="headerlink" title="Spring中如何避免bean别名循环依赖"></a>Spring中如何避免bean别名循环依赖</h1><p>在Spring bean的配置中，可以为bean配置一个别名。但在配置别名时，开发人员可能会不小心将别名配置成一个循环。Spring会检测出这种情况并且抛出一个异常。</p>
<a id="more"></a> 

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这种循环的别名配置会抛异常 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"demoService"</span> <span class="attr">alias</span>=<span class="string">"alias1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"alias1"</span> <span class="attr">alias</span>=<span class="string">"alias2"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"alias2"</span> <span class="attr">alias</span>=<span class="string">"demoService"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名"></a>设置别名</h2><p>在Spring中，与此相关的有两个Map。一个用于保存beanName与BeanDefinition的映射信息，一个用于保存aliasName与beanName的映射信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Map of bean definition objects, keyed by bean name. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Map from alias to canonical name. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; aliasMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>例如，当我们需要为A新增一个别名B时，为避免成环，会检测A是否是B的别名。若是的话，则会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Determine whether the given name has the given alias registered.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> name the name to check</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> alias the alias to look for</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 4.2.1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasAlias</span><span class="params">(String name, String alias)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : <span class="keyword">this</span>.aliasMap.entrySet()) &#123;</span><br><span class="line">        String registeredName = entry.getValue();</span><br><span class="line">        <span class="keyword">if</span> (registeredName.equals(name)) &#123;</span><br><span class="line">            String registeredAlias = entry.getKey();</span><br><span class="line">            <span class="keyword">if</span> (registeredAlias.equals(alias) || hasAlias(registeredAlias, alias)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h2><p>bean的别名可能会组成一列，即A的别名是B，B的别名是C。Spring用以下方式去找到别名的正式名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Determine the raw name, resolving aliases to canonical names.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> name the user-specified name</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the transformed name</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">canonicalName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    String canonicalName = name;</span><br><span class="line">    <span class="comment">// Handle aliasing...</span></span><br><span class="line">    String resolvedName;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        resolvedName = <span class="keyword">this</span>.aliasMap.get(canonicalName);</span><br><span class="line">        <span class="keyword">if</span> (resolvedName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            canonicalName = resolvedName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (resolvedName != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> canonicalName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>别名依赖</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2019/06/18/git/</url>
    <content><![CDATA[<h1 id="合并多个commit"><a href="#合并多个commit" class="headerlink" title="合并多个commit"></a>合并多个commit</h1> <a id="more"></a> 

<h2 id="在push之前合并"><a href="#在push之前合并" class="headerlink" title="在push之前合并"></a>在push之前合并</h2><p>情景：查看master分支的commit历史信息，会看到不同feature分支合并进来的许多commit。这么多粒度较小的commit，我们怎么知道哪些commit属于同一个feature。如果在master分支上，一个feature一个commit，这样会清晰很多，feature对外屏蔽掉开发过程中各种细小的commit，对外就体现出一个大commit。</p>
<p>假设目前的commit如下图所示，我们希望将这三个commit合并成一个commit（代码不改变）。例如我们在向开源社区提交一个较大的PR时，不可避免地会出现许多修修补补的commit，这些commit如果提交到master上面会非常难看且没有重点。因此，我们需要将开发过程中的多个commit合并成一个有明确含义的commit提交给reviewer。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">commit b2acc4d4aa5ca9bb21c0a62cd36de1911a3a2931 (HEAD -&gt; develop)</span><br><span class="line">Date:   Thu Jun 13 09:35:48 2019 +0800</span><br><span class="line"></span><br><span class="line">    develop33</span><br><span class="line"></span><br><span class="line">commit 329f9878306ed7f1d37638f9a32564f393347811</span><br><span class="line">Date:   Thu Jun 13 09:35:35 2019 +0800</span><br><span class="line"></span><br><span class="line">    develop22</span><br><span class="line"></span><br><span class="line">commit d6a56b89d4f6c7312837625766d6679aefe59816</span><br><span class="line">Date:   Thu Jun 13 09:20:46 2019 +0800</span><br><span class="line"></span><br><span class="line">    develop11</span><br></pre></td></tr></table></figure>

<p>下面我们使用<code>git rebase -i HEAD~3</code>将最近的3个commit合并成一个，<code>-i</code>表明这是一个交互的操作，接下去需要我们去指示要如何操作这3个commit。一般场景下，推荐使用以下操作：将最早的commit（最上方）标识为r，代表修改commit信息，将其他较新的commit标识为fixup，代表丢弃commit信息，且代码合并进之前的commit。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">r develop11  d6a56</span><br><span class="line">fixup develop22  329f9</span><br><span class="line">fixup develop33  b2acc</span><br></pre></td></tr></table></figure>

<p>合并完成后会生成一个新的commit，这个commit包含了以上3个commit的所有改动，且会生成一个全新的hash，不同于以上被合并的3个commit。</p>
<h2 id="在push之后合并"><a href="#在push之后合并" class="headerlink" title="在push之后合并"></a>在push之后合并</h2><p>情景：在提交PR之后，同事进行Code Review，给出了一些修改意见。我在本地修改后，会多出一个commit。使用上述方法可以将其合并，这时使用<code>git push</code>，会提示错误。提示本地分支落后于远程分支，这时我们可以使用<code>git push -f</code>强制更新远程分支。</p>
<h1 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h1><p>这里我们可以拿git merge和git rebase来做对比。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">M1--M2--M3(master)</span><br><span class="line">     \</span><br><span class="line">      \</span><br><span class="line">       D1(develop)</span><br></pre></td></tr></table></figure>

<h2 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h2><p>这个时候如果在develop分支上使用<code>git merge master</code>，则会将master分支合并至develop分支，且会保留原记录，形成非线性的commit记录。这种方式不太推荐。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">M1--M2----M3--D2(develop)</span><br><span class="line">        \    /</span><br><span class="line">         \  /</span><br><span class="line">          D1</span><br></pre></td></tr></table></figure>

<h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h2><p><code>git rebase master</code>，会将master分支合并进develop分支，且记录是线性的，新生成的D1’这个commit的hash不同于D1。可以理解为D1’这个分支是基于M3进行修改的，而不是基于M2。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">M1--M2--M3--D1&apos;(develop)</span><br></pre></td></tr></table></figure>

<h1 id="拉取新分支"><a href="#拉取新分支" class="headerlink" title="拉取新分支"></a>拉取新分支</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull = git fetch + git merge FETCH_HEAD </span><br><span class="line">git pull --rebase =  git fetch + git rebase FETCH_HEAD</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>效率工具</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习笔记之构造函数</title>
    <url>/2017/04/21/JS-NewObject/</url>
    <content><![CDATA[<p>我们选择new一个函数的时候，会经历以下3个步骤，以<code>new Foo()</code>为例：</p>
<a id="more"></a>

<ol>
<li>创建一个新对象，继承自<code>Foo.prototype</code></li>
<li>执行构造函数，并将this指向新对象</li>
<li>返回新对象（若构造函数没有返回值，也照样返回新对象）</li>
</ol>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JS构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习笔记之闭包</title>
    <url>/2017/04/19/JS-Closures/</url>
    <content><![CDATA[<h2 id="1-什么是闭包"><a href="#1-什么是闭包" class="headerlink" title="1. 什么是闭包"></a>1. 什么是闭包</h2><p>简单的说，闭包是指<strong>一个函数</strong>和<strong>这个函数的执行环境</strong>。下面是一个最简单的闭包。函数test()根据作用域链的规则访问到了函数外面的value变量。</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="string">"pxz"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述例子跟我们常见的闭包不太一样，常见的闭包形式是<strong>函数嵌套函数</strong>并且<strong>返回函数</strong>。我们再看上面那个例子，变量value赋给了全局对象，我们希望避免全局变量污染，就要把这个闭包放进函数中。如果是一次性的函数，就写成立即执行函数；如果需要调用，就写成返回函数形式。</p>
<p>一般创建闭包的方式，是在一个函数中创建另一个函数，<strong>并将该函数作为返回值返回</strong>。一般情况下，一个函数返回了，那么这个函数的活动对象（变量对象）就会被销毁，这个变量对象就不在当前作用域链上了，但是闭包跟一般情况不同。</p>
<h2 id="2-闭包用途"><a href="#2-闭包用途" class="headerlink" title="2.闭包用途"></a>2.闭包用途</h2><p>闭包可用来实现私有变量，具体可参考JS学习笔记——私有变量。</p>
<h2 id="3-一个闭包常见的错误"><a href="#3-一个闭包常见的错误" class="headerlink" title="3.一个闭包常见的错误"></a>3.一个闭包常见的错误</h2><p>在<strong>1.经典闭包例子</strong>中，test函数的返回值是一个匿名函数组ary，咋一看，匿名函数组里的每一个函数返回各自的索引值。但其实并不是这样的。匿名函数组里的每一个函数返回的值一样且都为n。我们调用了test函数，返回还是函数，赋给fun。在fun里可以访问到fun外test函数中的变量，比如<code>var i</code>，即使此时已经从test函数中返回。我们可以形象地把这个过程理解为<strong>返回函数ary闭包了外层函数的变量i</strong>。由于变量i在外层函数只有一份拷贝，所以函数组ary返回的i都是一个i，test函数执行完毕后，i变成了n。</p>
<p>要使得返回的函数组里的每个函数都不一样，我们需要为每个返回函数拷贝一份变量i。在<strong>2.立即执行函数</strong>中，没有直接使用外层函数变量i，而是将i作为函数参数传入，这样就能在函数内部拷贝一份变量了。</p>
<p>在<strong>3.返回函数</strong>中，我们在<strong>2.立即执行函数</strong>的基础上外包一层函数，使得满足闭包要求，返回函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//1.经典闭包例子</span><br><span class="line">function test(n) &#123;</span><br><span class="line">    ary = [];</span><br><span class="line">    for(var i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        ary[i] = function() &#123;return i;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return ary;</span><br><span class="line">&#125;</span><br><span class="line">var fun = test(5)[4];</span><br><span class="line">console.log(fun());//5</span><br><span class="line"></span><br><span class="line">//2.立即执行函数-拷贝变量</span><br><span class="line">//每一份i都有拷贝，但这不是闭包，返回值不是函数</span><br><span class="line">function test(n) &#123;</span><br><span class="line">    ary = [];</span><br><span class="line">    for(var i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        ary[i] = (function(x) &#123;return x;&#125;)(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return ary;</span><br><span class="line">&#125;</span><br><span class="line">console.log(test(5)[4]);//4</span><br><span class="line"></span><br><span class="line">//3.返回函数</span><br><span class="line">//在2的基础上，在外面套一层函数</span><br><span class="line">function test(n) &#123;</span><br><span class="line">    ary = [];</span><br><span class="line">    for(var i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        ary[i] = (function(x) &#123;</span><br><span class="line">        	return function() &#123;</span><br><span class="line">        		return x;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;)(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return ary;</span><br><span class="line">&#125;</span><br><span class="line">console.log(test(5)[4]());//4</span><br></pre></td></tr></table></figure>

<p>【Reference】</p>
<ol>
<li>《javascript高级程序设计》（第3版）</li>
<li>大部分人都会做错的经典JS闭包面试题 <a href="http://www.cnblogs.com/xxcanghai/p/4991870.html" target="_blank" rel="noopener">http://www.cnblogs.com/xxcanghai/p/4991870.html</a></li>
<li>「每日一题」JS 中的闭包是什么？ <a href="https://zhuanlan.zhihu.com/p/22486908" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/22486908</a></li>
</ol>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习笔记之跨域</title>
    <url>/2017/04/17/JS-CrossOrigin/</url>
    <content><![CDATA[<p>现在的web应用越来越丰富，一个web上的内容往往会抓取其他web上的数据。在默认情况下，web上的交互需要遵循同源策略（Same-origin policy），即同协议、同域名、同端口。在URL<code>http://store.company.com/dir2/other.html</code>中，协议是Http、域名是store.company.com，端口是80。当不符合同源策略时，这时的通信就可以叫做跨域通信。跨域通信有许多奇奇怪怪的方法可以做到，这里就简单介绍几种。</p>
<a id="more"></a>

<h3 id="document-domain-iframe"><a href="#document-domain-iframe" class="headerlink" title="document.domain + iframe"></a>document.domain + iframe</h3><p><code>http://www.a.com</code>和<code>http://script.a.com</code>的交互是跨域交互，因为两者域名不同，虽然主域名都为<code>a.com</code>。
对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决。具体的做法是可以在<a href="http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上`document.domain" target="_blank" rel="noopener">http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上`document.domain</a> = ‘a.com’<code>；然后通过在a.html文件中创建一个</code><iframe>`，去控制iframe的contentDocument，这样两个js文件就可以跨域通信了。当然这种办法只能解决主域相同而二级域名不同的情况。</iframe></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//www.a.com/a.html</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'a.com'</span>;</span><br><span class="line"><span class="keyword">var</span> ifr = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">ifr.src = <span class="string">'http://script.a.com/b.html'</span>;</span><br><span class="line">ifr.style.display = <span class="string">'none'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(ifr);</span><br><span class="line">ifr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> doc = ifr.contentDocument || ifr.contentWindow.document;</span><br><span class="line">    <span class="comment">// 在这里操纵script.a.com/b.html，可以对doc进行各种DOM操作</span></span><br><span class="line">    alert(doc.getElementsByTagName(<span class="string">"h1"</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//script.a.com/b.html</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'a.com'</span>;</span><br></pre></td></tr></table></figure>

<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP(JSON with padding)利用<code>&lt;script&gt;</code>跨域加载脚本的原生能力来做到跨域通信。</p>
<p>我们知道，如果要引用JQuery库，除了下载到本地引入外，还可以这么引入：<code>&lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;</code>，这个就是JSONP的基本原理。JSONP是一种非正式的传输协议，可以说是劳动人民的智慧。在JSONP的跨域通信中，客户端和服务器都需要遵循一定的规则。</p>
<p><code>&lt;script&gt;</code>的src属性应该填入所需服务的URL，URL中有查询字符串<code>code=CA998&amp;jsoncallback=callbackFunction</code>，<code>code=CA998</code>是传送给服务器的数据，<code>jsoncallback=callbackFunction</code>是传送给服务器的回调函数。前者jsoncallback由服务器定义，可能是callback、callbackFunc等等，双方约定好即可。后者callbackFunction由客户端定义，这是一个回调函数。将这样一个查询字符串发送给服务器之后，服务器会做两件事：1.根据查询字符串中的数据，准备好客户端需要的结果数据；2.将数据传入回调函数，把执行函数的字符串返回给客户端。客户端加载入这样一个js文件后，会执行该js文件中的执行语句。</p>
<p>服务器返回了带有执行语句的js，在客户端这边，需要定义或者声明这个回调函数<code>callbackFunction()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callbackFunction</span>(<span class="params">data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"http://www.runoob.com/try/ajax/jsonp.php?jsoncallback=callbackFunction"</span>;</span><br><span class="line"><span class="comment">// 创建script标签，设置其属性</span></span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">script.setAttribute(<span class="string">'src'</span>, url);</span><br><span class="line"><span class="comment">// 把script标签加入head，此时调用开始</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(script);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务器根据查询字符串的请求，用服务器端的语言，生成并返回js文件，该js文件大概内容如下</span></span><br><span class="line">callbackFunction([<span class="string">"customername1"</span>, <span class="string">"customername2"</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="HTML5-postMessage"><a href="#HTML5-postMessage" class="headerlink" title="HTML5 postMessage"></a>HTML5 postMessage</h3><p>HTML5为window对象新增了一个postMessage方法，该方法用于解决跨域通信的问题。<br>在<code>http://test.com</code>下，向<code>http://lslib.com</code>发送信息的步骤：<br>1.在发送方建立<code>&lt;iframe&gt;</code>，<code>src</code>属性填写接收方的url<br>2.调用frame的postMessage()方法，该方法接收两个参数：<br>message：只支持字符串信息，若要发送对象，可用JSON.stringify转换成字符串；<br>targetOrigin：目标域<br>3.在接收端为window对象绑定message事件，MessageEvent对象有三个重要的属性：<br>data：获取字符串<br>source：发送消息的窗口对象<br>origin：发送消息的源</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">http://test.com/index.html</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://lsLib.com/lsLib.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.frames[<span class="number">0</span>].postMessage(<span class="string">'getcolor'</span>,<span class="string">'http://lslib.com'</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">http://lslib.com/lslib.html</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//e.data = "getcolor"</span></span></span><br><span class="line"><span class="javascript">    &#125;,<span class="literal">false</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="图像ping"><a href="#图像ping" class="headerlink" title="图像ping"></a>图像ping</h3><p>一个网页可以从其他任何网页中加载图，那么图像ping主要通过<code>&lt;img&gt;</code>标签的src属性来进行跨域。客户端的请求通过查询查询字符串发送给服务器。这种方式主要有两点不足：1.只能用Get请求；2.只能进行客户端至服务器的单向通信（通过查询字符串），无法访问服务器的响应文本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var img = new Image();</span><br><span class="line">img.onload = function() &#123;</span><br><span class="line">    alert(&quot;onload!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">img.onerror = function() &#123;</span><br><span class="line">    alert(&quot;onerror!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//img.src=&quot;http://xxx.jpg&quot;;</span><br><span class="line">img.src=&quot;http://www.example.com/test?name=pxz&quot;;//name=pxz是就是客户端发送给服务器的请求</span><br></pre></td></tr></table></figure>

<p>【Reference】</p>
<ol>
<li><a href="https://earthsplitter.github.io/2017/03/21/%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96%E4%B8%8E%E8%B7%A8%E5%9F%9F%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener"> 同源政策与跨域详解 </a></li>
<li>说说JSON和JSONP，也许你会豁然开朗，含jQuery用例  <a href="http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html" target="_blank" rel="noopener">http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html</a></li>
<li><a href="http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html#m3" target="_blank" rel="noopener">http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html#m3</a></li>
</ol>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习笔记之ajax</title>
    <url>/2017/04/16/JS-AJAX/</url>
    <content><![CDATA[<p>Ajax（Asynchronous JavaScript + XML）在2005年被Jesse James Garrett引入，他综合了许多当时现有技术，产生了ajax。ajax使得浏览器可以额外地向服务器请求数据而不用重新刷新页面，ajax从服务器或许到数据后，可用javascript操作DOM以改变页面。虽然ajax中的x代表XML，但目前JSON的使用要更加广泛一点。JSON更加轻量级以及是原生javascript的一部分。</p>
<a id="more"></a>

<p>实现ajax的核心是XMLHttpRequest对象，其使用主要是<code>open()</code>、<code>send()</code>等函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//1.new</span><br><span class="line">//2.event</span><br><span class="line">//3.open</span><br><span class="line">//4.send</span><br><span class="line"></span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">//为了兼容性，事件回调需在open之前定义</span><br><span class="line">xhr.onreadystatechange = function() &#123;</span><br><span class="line">    if(xhr.readyState == 4) &#123;</span><br><span class="line">        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 | xhr.status == 304) &#123;</span><br><span class="line">            alert(xhr.responseText);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            alert(&quot;Request was failed.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//以get的方式请求example.txt，这里用相对路径，相对当前页面；最后一个参数代表是否异步。调用open之后，请求并没有发送，只是启动一个请求以备发送。</span><br><span class="line">xhr.open(&quot;get&quot;, &quot;example.txt&quot;, true);</span><br><span class="line"></span><br><span class="line">//请求主体无数据。调用send之后，请求就会被发送出去。</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure>

<p>对象xhr中有一个readyState属性，这个属性表示目前ajax处于哪个状态，一般我们多使用<code>4:已经接收到全部响应数据</code>。当readyState状态改变时，会触发<code>readystatechange事件</code>。我们将该事件以DOM0级的方式添加到xhr对象上。在这个事件中，我们要检测readyState是否等于4，还要检测status。<br>还有一个在使用上比readystatechange事件要简单一点的是<code>load事件</code>，该事件就是在响应接收完毕后触发的，也就没有必要去检测readyState了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xhr.onload = function() &#123;</span><br><span class="line">    if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 | xhr.status == 304) &#123;</span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        alert(&quot;Request was failed.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习笔记之私有变量</title>
    <url>/2017/04/15/JS-PrivateValue/</url>
    <content><![CDATA[<h2 id="0-本章提要"><a href="#0-本章提要" class="headerlink" title="0.本章提要"></a>0.本章提要</h2><ul>
<li><p>使用立即执行函数实现块级作用域</p>
</li>
<li><p>使用<code>构造函数</code>实现<strong>实例</strong>私有变量：私有变量函数和公有特权方法每个实例都有独立的一份</p>
</li>
<li><p>使用<code>原型模式+块级作用域</code>实现<strong>静态</strong>私有变量：私有变量函数和公有特权方法每个实例都共享一份</p>
</li>
</ul>
<a id="more"></a>

<h2 id="1-块级作用域"><a href="#1-块级作用域" class="headerlink" title="1.块级作用域"></a>1.块级作用域</h2><p>javascript不像其他语言有块级作用域，比如C、java的块级作用域。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C、java块级作用域</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;...&#125;</span><br><span class="line"><span class="comment">//i无效</span></span><br></pre></td></tr></table></figure>

<p>javascript是以函数进行区分作用域的（具体可参考JS学习笔记——作用域链）。如果需要使用到像java一样的块级作用域，可以用函数的形式实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i;</span><br><span class="line">    ...</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>这个函数是立即执行函数，变量i的作用域仅限于匿名函数内，就不会对全局造成污染。而且该立即执行函数没有引用，一经执行完，作用域链就可以立即销毁。</p>
<h2 id="2-实例私有变量"><a href="#2-实例私有变量" class="headerlink" title="2.实例私有变量"></a>2.实例私有变量</h2><p>javascript没有像java一样的对象成员访问权限的设置（private、public等）。如果要实现私有变量，可以通过构造函数的方式。下面是一种实现实例私有变量的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;<span class="comment">//name私有变量</span></span><br><span class="line">    <span class="keyword">var</span> privateVar;<span class="comment">//私有变量</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunc</span>(<span class="params"></span>)</span>&#123;...&#125;<span class="comment">//私有函数</span></span><br><span class="line">    <span class="keyword">this</span>.getName() &#123;<span class="comment">//特权方法</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.setName(value) &#123;<span class="comment">//特权方法</span></span><br><span class="line">        name = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Season"</span>);</span><br></pre></td></tr></table></figure>

<p>将需要私有的变量和函数放到函数作用域中，外界就认为是私有的了，但我们需要一种手段去访问它们，于是<code>特权方法(privileged method)</code>就出现了，它是有权访问私有变量和函数的公有方法。<br>私有变量或函数使用表达式定义时，一定要加<code>var</code>，不然这个变量或函数就会被加到全局作用域中，就不是私有变量了。其中函数也可以使用函数声明，因为函数声明只会提升到当前作用域，不会到全局作用域中。<br>我们使用<code>this</code>把公有的特权方法定义成对象的成员，可供函数作用域外的变量访问。<br>任何函数都可以被用作构造函数，只要使用了new操作符。<code>Person()</code>函数中的私有变量没有赋值给this对象，那么这些私有变量就是局部变量，通过闭包的方式被特权方法访问，被放入到其作用域链中。所以每次new之后，特权方法和私有变量都会被再复制一份，前者属于this对象，当然会复制一份；后者通过闭包被加入到特权方法的作用域链中，也会复制一份。</p>
<h2 id="3-静态私有变量"><a href="#3-静态私有变量" class="headerlink" title="3.静态私有变量"></a>3.静态私有变量</h2><p>使用<code>原型模式+块级作用域</code>实现<strong>静态</strong>私有变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    var privateVar = 0;</span><br><span class="line">    function privateFunc()&#123;return false;&#125;</span><br><span class="line">    MyObject = function()&#123;&#125;;</span><br><span class="line">    MyObject.prototype.publicMethod = function()&#123;</span><br><span class="line">        privateVar++;</span><br><span class="line">        return privateFunc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">var Obj = new MyObject();</span><br></pre></td></tr></table></figure>

<p>这个立即执行的匿名函数不会随着new的执行而执行，因此私有变量和函数只有一份，它们的作用域仅限于匿名函数内。<code>MyObject</code>定义的时候不能加<code>var</code>，否则匿名函数外就访问不到了。特权方法定义在<code>MyObject</code>的原型上，因此特权方法也只有一个。</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JS私有变量</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习笔记之数据类型</title>
    <url>/2017/04/13/JS-DataType/</url>
    <content><![CDATA[<h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h2><p>ECMAScript一共有6种数据类型：<strong>5种</strong>基本数据类型和<strong>1种</strong>引用数据类型。<br>基本数据类型：Number\String\Boolean\Null\Undefined<br>引用数据类型：Object</p>
<a id="more"></a>

<h2 id="2-tyepof操作符"><a href="#2-tyepof操作符" class="headerlink" title="2.tyepof操作符"></a>2.tyepof操作符</h2><p>typeof是操作符，不是函数。typeof返回<strong>字符串</strong>。使用typeof返回的数据类型跟第1节是不一样的。typeof一共返回6种，也是6种，只不过是<strong>4种</strong>基本数据类型和<strong>2种</strong>引用数据类型。Null被归为Object，原本属于Object的Function被单独拎出来。</p>
<p>基本数据类型：Number\String\Boolean\Undefined<br>引用数据类型：Object\Function</p>
<h2 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h2><h3 id="3-1-声明变量时显式初始化"><a href="#3-1-声明变量时显式初始化" class="headerlink" title="3.1 声明变量时显式初始化"></a>3.1 声明变量时显式初始化</h3><p>已声明未赋值变量<code>myTest</code>与未声明变量<code>test</code>的值都是<code>undefined</code>。这是两个本质不一样的变量，typeof之后的值却是一样的，我们应该避免这种情况的出现：声明变量的时候显式地初始化变量，让上述<code>typeof(test)</code>的情况不要出现，所以只要出现undefined，我们就可以认为这是一个未声明的变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//var test;</span><br><span class="line">var myTest;</span><br><span class="line">console.log(typeof(test));//undefined</span><br><span class="line">console.log(typeof(myTest));//undefined</span><br></pre></td></tr></table></figure>

<h3 id="3-2-对象变量显式初始化为null"><a href="#3-2-对象变量显式初始化为null" class="headerlink" title="3.2 对象变量显式初始化为null"></a>3.2 对象变量显式初始化为null</h3><p>如果声明的变量将来要用来保存对象的，应该初始化成<code>null</code>(之前我一直初始化成<code>{}</code>，这样是不好的)</p>
<h3 id="3-3-undefined-null是关键字-可当变量用"><a href="#3-3-undefined-null是关键字-可当变量用" class="headerlink" title="3.3 undefined\null是关键字 可当变量用"></a>3.3 undefined\null是关键字 可当变量用</h3><p>我们可以显式地把变量初始化为undefined<code>var test = undefined</code>，表示把test赋值成基本数据类型中的undefined。这里不是把undefined字符串赋值给变量，<code>undefined</code>是关键字，所以可以当做变量来用，如果写<code>var test = myundefined</code>是会报错的。js会认为myundefined是变量，然后去找，发现未定义。如果myundefined加上引号就是String，赋值就不会报错了。</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JS数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习笔记之对象属性判断</title>
    <url>/2017/04/12/JS-ObjectProperty/</url>
    <content><![CDATA[<h2 id="1-判断对象是否为空"><a href="#1-判断对象是否为空" class="headerlink" title="1. 判断对象是否为空"></a>1. 判断对象是否为空</h2><p>我们可以使用<code>fon-in</code>语句来枚举对象的属性，属性被枚举是没有顺序的。使用for-in语句就可以判断对象是否为空，<code>for-in</code>语句还会枚举对象<strong>原型</strong>上的属性。当对象是<code>null</code>或者<code>undefined</code>时，函数<code>isEptObj()</code>也返回true，表示对象是空的。</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEptObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> t <span class="keyword">in</span> o) &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">s1 = <span class="literal">null</span>;</span><br><span class="line">s2 = <span class="literal">undefined</span>;</span><br><span class="line">s3 = [];</span><br><span class="line">s4 = &#123;&#125;;</span><br><span class="line">isEptObj(s1);<span class="comment">//true</span></span><br><span class="line">isEptObj(s2);<span class="comment">//true</span></span><br><span class="line">isEptObj(s3);<span class="comment">//true</span></span><br><span class="line">isEptObj(s4);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.age = <span class="number">24</span>;</span><br><span class="line">isEptObj(s1);<span class="comment">//true</span></span><br><span class="line">isEptObj(s2);<span class="comment">//true</span></span><br><span class="line">isEptObj(s3);<span class="comment">//flase</span></span><br><span class="line">isEptObj(s4);<span class="comment">//flase</span></span><br></pre></td></tr></table></figure>

<h2 id="2-判断对象是否包含某属性"><a href="#2-判断对象是否包含某属性" class="headerlink" title="2. 判断对象是否包含某属性"></a>2. 判断对象是否包含某属性</h2><p>使用对象的<code>hasOwnProperty()</code>方法可以判断属性是否在实例上。如果该属性不在实例上，会有两种情况：1.该属性在原型上； 2.该属性不在原型上。所以我们还要配合<code>in</code>语句（<code>for-in</code>的非循环版本）继续判断该属性，进而可以得出该属性在实例上，在原型上，还是都不在。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">s1 = &#123;&#125;;</span><br><span class="line">s1.name = <span class="string">"abc"</span>;</span><br><span class="line"><span class="built_in">Object</span>.prototype.age = <span class="number">24</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s1.hasOwnProperty(<span class="string">'age'</span>)); <span class="comment">// flase</span></span><br><span class="line"><span class="built_in">console</span>.log(s1.hasOwnProperty(<span class="string">'name'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(s1.hasOwnProperty(<span class="string">'salary'</span>)); <span class="comment">// flase</span></span><br></pre></td></tr></table></figure>

<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>配合使用<code>in</code>语句和<code>hasOwnProperty()</code>函数，可以判断属性在实例上，在原型上，还是都不在。</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JS对象判断</tag>
      </tags>
  </entry>
</search>
