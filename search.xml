<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>并发设计模式</title>
    <url>/2020/02/12/%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Immutability模式"><a href="#Immutability模式" class="headerlink" title="Immutability模式"></a>Immutability模式</h1><p>不变性（Immutability）模式，即对象一旦被创建之后，状态就不再发生变化。我们知道多个线程同时读写同一共享变量会存在并发问题，如果我们把这里的共享变量改为只读，就不会有并发问题。</p>
<p>我们常用的Integer、Long、Double、String等类都使用了该模式，这些类本身和属性都使用final关键字修饰，使得类不能被继承，属性不能被修改。</p>
<p>当我们对这些类进行修改时，实际上是创建一个新的对象并返回，并不会对旧对象进行修改。</p>
<p>如果我们每次修改都创建新对象的话，是不是有点浪费内存了。针对这点，人们又提出享元模式（Flyweight Pattern）。享元模式可以理解为对象池，对于Long、Integer、Short、Byte等包装类，会预先缓存好常用的数据，之后需要使用到该数据就从缓存中拿。例如Long缓存了数字[-128,127]，这个对象池在JVM启动时就会创建好。</p>
<p>若final修饰变量a，说明a的引用不可变，但并不约束引用内容的可变性。例如引用的是对象A，那么对象A的属性是否可变不受该final约束。</p>
<h1 id="Copy-on-Write模式"><a href="#Copy-on-Write模式" class="headerlink" title="Copy on Write模式"></a>Copy on Write模式</h1><p>在Immutability模式中，对只读对象的修改会创建新的对象，这种方法是写时复制（Copy on Write, Cow）。CoW是解决不可变对象写操作的一个方法。</p>
<p>Copy on Write在许多领域都有广泛的应用，例如Linux中的<code>fork()</code>、Redis中的BGSAVE（本质也是<code>fork()</code>）、Java中的CopyOnWriteArrayList等。</p>
<p>CoW的缺点是会消耗较多内存，所以在写操作频繁以及数据量较大时不适合使用。</p>
<h1 id="线程本地存储模式"><a href="#线程本地存储模式" class="headerlink" title="线程本地存储模式"></a>线程本地存储模式</h1><p>线程本地存储模式是指不共享数据，每个线程有一份自己的数据备份。例如ThreadLocal和局部变量。</p>
<h1 id="Guarded-Suspension模式"><a href="#Guarded-Suspension模式" class="headerlink" title="Guarded Suspension模式"></a>Guarded Suspension模式</h1><p>Guarded Suspension模式本质上是一种等待唤醒机制的实现，典型的实现就是管程。</p>
<p>该模式与Balking模式都是多线程的if版本，区别是该模式会一直等待if条件变为真。</p>
<h1 id="Balking模式"><a href="#Balking模式" class="headerlink" title="Balking模式"></a>Balking模式</h1><p>Balking模式是指在多线程之间共享一个状态变量，业务逻辑依赖于这个状态变量的状态：当状态满足某个条件时，执行某个业务逻辑。在Java中实现Balking模式的关键是可见性，可见性可以通过互斥锁和volatile解决。</p>
<p>双重检查的单例模式就是Balking模式的一个应用。</p>
<p>该模式与Guarded Suspension模式都是多线程的if版本，区别是该模式只会判断一次条件，不会等待。</p>
<h1 id="Thread-Per-Message模式"><a href="#Thread-Per-Message模式" class="headerlink" title="Thread-Per-Message模式"></a>Thread-Per-Message模式</h1><p>Thread-Per-Message模式，即为每个任务分配一个独立的线程。Thread-Per-Message模式的一个最经典的应用场景是网络编程里服务端的实现，服务端为每个客户端请求创建一个独立的线程。</p>
<h1 id="Work-Thread模式"><a href="#Work-Thread模式" class="headerlink" title="Work Thread模式"></a>Work Thread模式</h1><p>Worker Thread模式可以类比现实世界里车间的工作模式：车间里的工人，有活儿了，大家一起干，没活儿了就聊聊天等着。Worker Thread对应到现实世界里，其实指的就是车间里的工人。</p>
<p>Java中的线程池采用了这种模式。</p>
<h1 id="两阶段终止模式"><a href="#两阶段终止模式" class="headerlink" title="两阶段终止模式"></a>两阶段终止模式</h1><p>两阶段终止模式，即将终止过程分成两个阶段。用于优雅地终止线程，其中第一阶段主要是线程T1向线程T2发送终止指令，第二阶段则是线程T2响应指令。</p>
<h1 id="生产者-消费者模式"><a href="#生产者-消费者模式" class="headerlink" title="生产者-消费者模式"></a>生产者-消费者模式</h1><ul>
<li>解耦</li>
<li>异步</li>
<li>平衡生产者、消费者之间的速度差异</li>
</ul>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Copy on Write</tag>
        <tag>生产者-消费者</tag>
        <tag>两阶段终止</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程之互斥</title>
    <url>/2020/02/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E4%BA%92%E6%96%A5/</url>
    <content><![CDATA[<p>并发编程领域可以抽象为3个核心问题：分工、协作、互斥。</p>
<p>本文介绍互斥。</p>
<p>互斥是为了保证程序的正确性，用专业术语叫“线程安全”。并发程序里，当多个线程同时访问同一个共享变量的时候，结果是不确定的。而导致不确定的主要源头是可见性问题、有序性问题和原子性问题，为了解决这三个问题，Java 语言引入了内存模型，内存模型提供了一系列的规则，利用这些规则，我们可以避免可见性问题、有序性问题，但是还不足以完全解决线程安全问题。解决线程安全问题的核心方案还是互斥。所谓互斥，指的是同一时刻，只允许一个线程访问共享变量。加锁方案有Java语言里的synchronized、并发包里的各种Lock。无锁方案有Java并发包里提供的原子类。除此之外，还有一些其他的方案，原理是不共享变量或者变量只允许读。这方面，Java提供了Thread Local和final关键字，还有一种Copy-on-write的模式。</p>
<a id="more"></a> 



<h1 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h1><p>锁是实现互斥的一种通用技术方案，如Java提供的synchronized关键字和并发包里面的各种Lock，都是锁的实现。</p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock是可重入锁，与synchronized的作用相同，但两者特性不同。</p>
<p>ReentrantLock可配置为公平锁和非公平锁。多个线程一起竞争AQS对象中的state变量。若state为0，说明锁目前空闲可用，需用CAS竞争锁；若state不为0，说明有线程占用着锁，需要将本线程加入队列，并挂起本线程，等待唤醒。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ReentrantLock使用示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ReadWriteLock和StampedLock"><a href="#ReadWriteLock和StampedLock" class="headerlink" title="ReadWriteLock和StampedLock"></a>ReadWriteLock和StampedLock</h2><p>读多写少是一个比较常见的并发场景，例如利用缓存优化性能。在这种场景下，如果使用读写不区分的锁（如ReentrantLock），性能会比较差。针对这种场景，Java并发包提供了读写锁（ReadWriteLock）。</p>
<p>读写锁应该遵守以下三条基本原则：</p>
<blockquote>
<ol>
<li><p>允许多个线程同时读共享变量；</p>
</li>
<li><p>只允许一个线程写共享变量；</p>
</li>
<li><p>如果一个写线程正在执行写操作，此时禁止读线程读共享变量。</p>
</li>
</ol>
</blockquote>
<p>读写锁与互斥锁的一个重要区别就是读写锁允许多个线程同时读共享变量，而互斥锁是不允许的，这是读写锁在读多写少场景下性能优于互斥锁的关键。但读写锁的写操作是互斥的，当一个线程在写共享变量的时候，是不允许其他线程执行写操作和读操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ReadWriteLock使用例子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;K, V&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> ReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="comment">// 读锁</span></span><br><span class="line">    <span class="keyword">final</span> Lock r = rwl.readLock();</span><br><span class="line">    <span class="comment">// 写锁</span></span><br><span class="line">    <span class="keyword">final</span> Lock w = rwl.writeLock();</span><br><span class="line">    <span class="comment">// 读缓存</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.get(key); &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123; r.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写缓存</span></span><br><span class="line">    <span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.put(key, v); &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123; w.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReadWriteLock在使用中可能会造成写操作的饥饿。在非公平模式下，写操作需要等所有读操作都结束后才能进行，但在读操作大量涌入的情况下，写操作可能会一直阻塞，获取不到锁。为了解决这个问题，Java8引入了新读写锁StampedLock。</p>
<p>StampedLock支持三种锁模式，分别是：写锁、悲观读锁和乐观读。前两种锁与ReadWriteLock相同。StampedLock的性能之所以比ReadWriteLock要好，关键在于乐观读方式。ReadWriteLock支持多个线程同时读，但是当多个线程同时读的时候，所有的写操作会被阻塞；而StampedLock提供的乐观读，允许一个线程获取写锁，也就是说不是所有的写操作都被阻塞。</p>
<p>StampedLock的乐观读与数据库中的乐观锁思想一样，都是通过版本号的方式实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//StampedLock使用例子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">final</span> StampedLock sl = <span class="keyword">new</span> StampedLock();</span><br><span class="line">    <span class="comment">//计算到原点的距离  </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//乐观读</span></span><br><span class="line">        <span class="keyword">long</span> stamp = sl.tryOptimisticRead();</span><br><span class="line">        <span class="comment">//读入局部变量</span></span><br><span class="line">        <span class="keyword">int</span> curX = x, curY = y;</span><br><span class="line">        <span class="comment">//读的过程，数据可能被修改</span></span><br><span class="line">        <span class="comment">//需要判断这期间是否存在写操作</span></span><br><span class="line">        <span class="comment">//如果存在，则sl.validate返回false</span></span><br><span class="line">        <span class="keyword">if</span> (!sl.validate(stamp))&#123;</span><br><span class="line">            <span class="comment">//升级为悲观读锁</span></span><br><span class="line">            stamp = sl.readLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                curX = x;</span><br><span class="line">                curY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//释放悲观读锁</span></span><br><span class="line">                sl.unlockRead(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(</span><br><span class="line">            curX * curX + curY * curY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h1><p>加锁往往会带来较大的开销，为了优化这部分性能，可以使用无锁方案。Java中的原子类就是无锁的，比较并交换（CAS）是无锁方案的常用实现。</p>
<p>Java并发包里提供的原子类可分为五个类别：</p>
<ol>
<li>原子化的基本数据类型</li>
<li>原子化的对象引用类型</li>
<li>原子化数组</li>
<li>原子化对象属性更新器</li>
<li>原子化的累加器</li>
</ol>
<h2 id="原子化的基本数据类型"><a href="#原子化的基本数据类型" class="headerlink" title="原子化的基本数据类型"></a>原子化的基本数据类型</h2><p>相关实现有AtomicBoolean、AtomicInteger和AtomicLong，较为简单。</p>
<h2 id="原子化的对象引用类型"><a href="#原子化的对象引用类型" class="headerlink" title="原子化的对象引用类型"></a>原子化的对象引用类型</h2><p>相关实现有AtomicReference、AtomicStampedReference和AtomicMarkableReference，利用它们可以实现对象引用的原子化更新。对象引用的更新需要重点关注ABA问题，AtomicStampedReference和 AtomicMarkableReference这两个原子类可以解决 ABA 问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AtomicStampedReference</span></span><br><span class="line"><span class="comment">//利用版本号解决ABA</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  V expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">  V newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> newStamp)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//AtomicMarkableReference</span></span></span><br><span class="line"><span class="function"><span class="comment">//版本号为boolean型</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  V expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">  V newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">boolean</span> expectedMark,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">boolean</span> newMark)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="原子化数组"><a href="#原子化数组" class="headerlink" title="原子化数组"></a>原子化数组</h2><p>相关实现有AtomicIntegerArray、AtomicLongArray和AtomicReferenceArray，这些原子类可以原子化地更新数组里面的每一个元素。</p>
<h2 id="原子化对象属性更新器"><a href="#原子化对象属性更新器" class="headerlink" title="原子化对象属性更新器"></a>原子化对象属性更新器</h2><p>相关实现有AtomicIntegerFieldUpdater、AtomicLongFieldUpdater和AtomicReferenceFieldUpdater，它们可以原子化地更新对象的属性，这三个方法都是利用反射机制实现的。更新的对象属性必须是volatile类型，这样才能保证可见性。 </p>
<h2 id="原子化的累加器"><a href="#原子化的累加器" class="headerlink" title="原子化的累加器"></a>原子化的累加器</h2><p>相关实现有DoubleAccumulator、DoubleAdder、LongAccumulator和LongAdder，这四个类仅仅用来执行累加操作，相比原子化的基本数据类型，速度更快。</p>
<h1 id="并发需要注意的问题"><a href="#并发需要注意的问题" class="headerlink" title="并发需要注意的问题"></a>并发需要注意的问题</h1><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>安全性指的是多个线程读写同一份数据可能会导致程序不正确。</p>
<p>安全性的问题可使用互斥解决。</p>
<h2 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h2><p>活跃性指的是某个操作无法执行下去，又包括死锁、活锁、饥饿。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁指的是两个线程阻塞且在互相等待对方的锁。</p>
<p>死锁的产生需要同时满足以下四个条件：</p>
<ol>
<li><strong>互斥</strong>。共享资源X和Y只能被一个线程占用；</li>
<li><strong>占有且等待</strong>。线程T1已经取得共享资源X，在等待共享资源Y的时候，不释放共享资源X；</li>
<li><strong>不可抢占</strong>。其他线程不能强行抢占线程T1占有的资源；</li>
<li><strong>循环等待</strong>。线程T1等待线程T2占有的资源，线程T2等待线程T1占有的资源，就是循环等待。</li>
</ol>
<p>只要破坏其中的一个条件即可解除死锁。</p>
<p>我们加锁就是为了互斥，所以条件1不可破坏，我们考虑余下的三个条件。</p>
<ul>
<li><p>条件2-占有且等待：在一个临界区内申请所有的资源。例如在一个单例的同步方法中申请全部资源；</p>
</li>
<li><p>条件3-不可抢占：锁住某个资源的线程可主动释放该资源。例如Lock接口可以支持中断、超时和非阻塞；</p>
</li>
<li><p>条件4-循环等待：所有线程对资源的加锁都应该按照某个特定的顺序。</p>
</li>
</ul>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>活锁指的是两个线程未阻塞，但也存在执行不下去的情况。例如以太网采用CSMA/CD协议解决冲突问题。 </p>
<p>解决方案：等待随机的时间</p>
<h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>饥饿指的是线程得不到资源而一直执行不了。</p>
<p>解决方案：公平锁</p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>我们可以用Amdahl定律来描述性能，该定律代表了处理器并行运算之后效率提升的能力。我们可以从以下两个方面来提升并发编程的性能：</p>
<ol>
<li>减少锁持有的时间</li>
<li>无锁技术：线程本地存储、写时复制、乐观锁</li>
</ol>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>总的来说，并发策略可以总结为以下三方面：避免共享、不变模式、管程及其他同步工具</p>
<p>Java并发包的作者Doug Lea在《Java并发编程：设计原则与模式》一书中给出了用锁的最佳实践：</p>
<blockquote>
<p>1.永远只在更新对象的成员变量时加锁</p>
<p>2.永远只在访问可变的成员变量时加锁</p>
<p>3.永远不在调用其他对象的方法时加锁</p>
</blockquote>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>锁</tag>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务</title>
    <url>/2020/01/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>单数据源的一致性可以使用单机事务来保证，多数据源的一致性需要使用分布式事务来保证。</p>
<p>ACID（A原子性、C一致性、I隔离性、D持久性）是单机事务的特性。</p>
<p>CAP、BASE理论是分布式领域的理论。</p>
<a id="more"></a> 



<h1 id="XA协议"><a href="#XA协议" class="headerlink" title="XA协议"></a>XA协议</h1><p>在XA协议中有两个角色：<strong>事务协调者</strong>和<strong>事务参与者</strong> </p>
<h2 id="两阶段提交（2PC）"><a href="#两阶段提交（2PC）" class="headerlink" title="两阶段提交（2PC）"></a>两阶段提交（2PC）</h2><p>Prepare阶段</p>
<p>Commit阶段</p>
<h2 id="三阶段提交（3PC）"><a href="#三阶段提交（3PC）" class="headerlink" title="三阶段提交（3PC）"></a>三阶段提交（3PC）</h2><p>Prepare阶段</p>
<p>Cancommit阶段</p>
<p>Commit阶段</p>
<h1 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h1><p>关于TCC（Try-Confirm-Cancel）的概念，最早是由Pat Helland于2007年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。</p>
<p>TCC事务机制相对于传统事务机制（X/Open XA Two-Phase-Commit），其特征在于它不依赖资源管理器(RM)对XA的支持，而是通过对（由业务系统提供的）业务逻辑的调度来实现分布式事务。</p>
<p>对于业务系统中一个特定的业务逻辑S，其对外提供服务时，必须接受一些不确定性，即对业务逻辑执行的一次调用仅是一个临时性操作，调用它的消费方服务M保留了后续的取消权。如果M认为全局事务应该rollback，它会要求取消之前的临时性操作，这将对应S的一个取消操作；而当M认为全局事务应该commit时，它会放弃之前临时性操作的取消权，这对应S的一个确认操作。</p>
<p>每一个初步操作，最终都会被确认或取消。因此，针对一个具体的业务服务，TCC事务机制需要业务系统提供三段业务逻辑：初步操作Try、确认操作Confirm、取消操作Cancel。</p>
<h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>ByteTCC:<a href="https://www.bytesoft.org/tcc-intro/" target="_blank" rel="noopener">https://www.bytesoft.org/tcc-intro/</a> </p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>TCC</tag>
        <tag>XA</tag>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程之分工</title>
    <url>/2020/01/21/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%88%86%E5%B7%A5/</url>
    <content><![CDATA[<p>并发编程领域可以抽象为3个核心问题：分工、协作、互斥。</p>
<p>本文介绍分工。</p>
<p>所谓分工，类似于现实中完成一个项目，项目经理要拆分任务，安排合适的成员去完成。在并发编程领域，线程就是成员，分工直接决定了并发程序的性能。Java并发包里的Executor、Fork/Join、Future本质上都是一种分工方法。除此之外，并发编程领域还总结了一些设计模式，基本上都是和分工方法相关的，例如生产者-消费者、Thread-Per-Message、Worker Thread模式等都是用来指导如何分工的。</p>
<a id="more"></a> 



<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>虽然在Java语言中创建线程看上去就像创建一个对象一样简单，只需要new Thread()就可以了，但实际上创建线程远不是创建一个对象那么简单。创建对象，仅仅是在JVM的堆里分配一块内存而已；而创建一个线程，却需要调用操作系统内核的API，然后操作系统要为线程分配一系列的资源，这个成本就很高了，所以线程是一个重量级的对象，应该避免频繁创建和销毁。我们可以使用线程池来避免创建销毁线程的开销。</p>
<p>Java线程池采用的是生产者-消费者模式。线程池的使用方是生产者，线程池本身是消费者。Java提供的线程池相关的工具类中，最核心的是ThreadPoolExecutor。</p>
<p>ThreadPoolExecutor共有7个参数可设置</p>
<ul>
<li><strong>corePoolSize</strong> 线程池核心线程数</li>
<li><strong>maximumPoolSize</strong> 线程池最大线程池</li>
<li><strong>keepAliveTime</strong> 空闲线程存活时间</li>
<li><strong>unit</strong> 存活时间单位</li>
<li><strong>workQueue</strong> 工作队列</li>
<li><strong>threadFactory</strong> 创建线程的工厂</li>
<li><strong>handler</strong> 拒绝策略</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<embed src="ThreadPoolExecutor.svg" width="100%" type="image/svg+xml">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 线程池的生产者-消费者模式示意图</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 任务生产   |---------------|  多线程消费任务</span></span><br><span class="line"><span class="comment"> * -------&gt;   task task task   ------------&gt;</span></span><br><span class="line"><span class="comment"> * 投入队列   |---------------|</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>同时满足以下三个条件，线程池会开始回收线程：</p>
<ol>
<li>线程数量大于corePoolSize；</li>
<li>任务队列为空；</li>
<li>线程等待任务超过keepAliveTime。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ThreadPoolExecutor.java</span></span><br><span class="line"><span class="comment">//Class ThreadPoolExecutor</span></span><br><span class="line"><span class="comment">//execute的参数是Runnable，如果准备执行Callable，Callable会被包装成Runnable再调用该方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池中的线程数量小于corePoolSize，此时新增线程</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程数量已达到corePoolSize，此时将任务放入队列，不新增线程</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列已满，此时再次新增线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ThreadPoolExecutor.java</span></span><br><span class="line"><span class="comment">//Class Worker</span></span><br><span class="line"><span class="comment">//线程池消费者，一个Worker对应一个线程</span></span><br><span class="line"><span class="comment">//Worker的工作是从队列拿任务并消费，然后不断重复这个循环</span></span><br><span class="line"><span class="comment">//如果Worker跳出这个循环，说明线程的run()方法结束，线程要销毁</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock();</span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//从队列拿任务</span></span><br><span class="line">        <span class="comment">//若该线程需要销毁，则会跳出这个while循环</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//对于接收Runnable任务的线程池而言，这里的task.run就是运行任务本身</span></span><br><span class="line">                    <span class="comment">//对于Callable而言，run的是Futuretask。Futuretask将Callable包装成了Runnable</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FutureTask.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//这里包装了用户的Callable任务</span></span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FutureTask.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//waiters是一个线程安全的栈，里面保存了正在等待future结果的线程</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//唤醒在future.get等待着的线程</span></span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    done();</span><br><span class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FutureTask.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                q.thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">            q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            <span class="comment">//若任务还在执行中，则将该线程作为等待节点压入栈中</span></span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                 q.next = waiters, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//阻塞线程，等待FutureTask完成</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在FutureTask的set(result)中，除了改变任务的状态外，还唤醒了在等待的节点。</p>
<h2 id="设置线程数量"><a href="#设置线程数量" class="headerlink" title="设置线程数量"></a>设置线程数量</h2><p>对于IO密集型：CPU逻辑核数*[]</p>
<p>对于CPU密集型：CPU逻辑核数+1</p>
<p>如何界定一个程序是IO密集还是CPU，如何测量IO耗时与CPU耗时的比值，这些数据不是很容易就能拿到。再者，就算我们给出了理论值，这个值也仅供参考，实际上多少线程数是合理的还是需要在环境中进行压测。</p>
<p>工程上比较常用的经验值：2*CPU逻辑核数+1</p>
<h1 id="任务分工"><a href="#任务分工" class="headerlink" title="任务分工"></a>任务分工</h1><p>CompletionStage接口负责多任务的分工，用于异步执行中的阶段处理，该接口是Java8新增的一个接口，其大量用在Lambda表达式计算过程中。CompletableFuture是该接口的官方实现，目前只有这一个实现类。</p>
<p>在Java8之前，我们常使用Future来进行异步计算。那么在已经有Future的情况下，为什么要引入CompletionStage呢。</p>
<p>Future的局限性：Future的结果需要手动通过<code>get()</code>获取，以进行下一步操作。</p>
<p>CompletableFuture可以定义多个任务之间的关系，上一步的结果可以自动传递给下一步的任务。</p>
<p>CompletableFuture对象的创建主要通过<code>supplyAsync(Supplier&lt;U&gt;)</code>，<code>runAsync(Runnable)</code>这两个静态方法完成。这两个方法都是异步的，会在新线程中运行任务，不会阻塞调用线程。这两个方法还有一个带Executor参数的版本，可以传入自定义的线程池。</p>
<h2 id="任务关系"><a href="#任务关系" class="headerlink" title="任务关系"></a>任务关系</h2><p>任务之间的关系大致可总结为以下三类：串行关系、并行关系、汇聚关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">串行关系（先执行任务A，再执行任务B）</span><br><span class="line">--A--&gt;  --B--&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">汇聚关系（先执行任务AB，C需要等待AB）</span><br><span class="line">AND汇聚：C需要等待AB都执行完成</span><br><span class="line">OR汇聚：AB中任意一个完成，C即可开始执行</span><br><span class="line">--A--&gt;|</span><br><span class="line">      |--C--&gt;</span><br><span class="line">--B--&gt;|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">并行关系（任务AB同时运行）</span><br><span class="line">--A--&gt;</span><br><span class="line">--B--&gt;</span><br></pre></td></tr></table></figure>

<p>根据任务之间的依赖关系，CompletableFuture中的方法大致可分为以下三类。为什么没有并行关系的方法呢，因为只要在这些方法后面加上<strong>Async</strong>，就可以实现并行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">串行关系:</span><br><span class="line">thenApply(Function)</span><br><span class="line">thenAccept(Consumer)</span><br><span class="line">thenRun(Runnable)</span><br><span class="line">thenCompose(Function)</span><br><span class="line"></span><br><span class="line">AND汇聚关系:</span><br><span class="line">thenCombine(CompletionStage, BiFunction)</span><br><span class="line">thenAcceptBoth(CompletionStage, Consumer)</span><br><span class="line">runAfterBoth(CompletionStage, Runnable)</span><br><span class="line"></span><br><span class="line">OR 汇聚关系:</span><br><span class="line">applyToEither(CompletionStage, Function)</span><br><span class="line">acceptEither(CompletionStage, Consumer)</span><br><span class="line">runAfterEither(CompletionStage, Runnable)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; f1 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"runAsync: "</span> + Thread.currentThread().getId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//thenRun()具体在哪个线程中运行</span></span><br><span class="line"><span class="comment">//取决于调用thenRun()时，runAsync()中的任务状态</span></span><br><span class="line"><span class="comment">//当f1 runAsync()中的任务在执行时，thenRun()中的任务会在相同的异步线程中运行</span></span><br><span class="line"><span class="comment">//当f1 runAsync()中的任务结束时，thenRun()中的任务会在调用线程中运行</span></span><br><span class="line">f1.thenRun(() -&gt; </span><br><span class="line">           System.out.println(<span class="string">"thenRun: "</span> + Thread.currentThread().getId()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//不带Executor参数的异步回调</span></span><br><span class="line"><span class="comment">//会从ForkJoinPool.commonPool()获取线程来运行任务</span></span><br><span class="line"><span class="comment">//若是带Executor参数的异步回调</span></span><br><span class="line"><span class="comment">//会从Executor线程池获取线程来执行</span></span><br><span class="line">f1.thenRunAsync(() -&gt; </span><br><span class="line">           System.out.println(<span class="string">"thenRun: "</span> + Thread.currentThread().getId()));</span><br></pre></td></tr></table></figure>

<h2 id="任务批处理"><a href="#任务批处理" class="headerlink" title="任务批处理"></a>任务批处理</h2><p>CompletableFuture中还提供了批量处理任务的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当所有的CompletableFuture都执行完后执行计算</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt;  <span class="title">allOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//最快的那个CompletableFuture执行完之后执行计算</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Object&gt;  <span class="title">anyOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>在CompletableFuture调用链中，前面的任务抛出异常，后面的任务就不会被执行，Future将以异常状态结束，即调用<code>get()</code>的时候会抛异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;).thenApply(result -&gt; &#123;</span><br><span class="line">    <span class="comment">//不会执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"thenApply"</span>;</span><br><span class="line">&#125;).thenAccept(result -&gt; &#123;</span><br><span class="line">    <span class="comment">//不会执行</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>CompletableFuture提供了<code>exceptionally()</code>、 <code>handle()</code>、<code>whenComplete()</code>等多个方法来对任务进行扫尾处理，这三个方法都可以感知到异常。</p>
<p>其中<code>exceptionally(Function)</code>只有在抛异常时会被调用。<code>handle(BiFunction)</code>和<code>whenComplete(BiConsumer)</code>会在任务结束时被调用（不管以什么方式结束）。</p>
<p>如果在<code>exceptionally(Function)</code>、<code>handle(BiFunction)</code>中对异常进行处理，那么后续调用<code>get()</code>、<code>join()</code>就不会抛出异常。如果只有<code>whenComplete(BiConsumer)</code>，后续还是会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.whenComplete((s, e) -&gt; &#123;</span><br><span class="line">	<span class="comment">//s是上一步的结果，若无结果，则是null</span></span><br><span class="line">    <span class="comment">//e是异常信息，若无异常，则是null</span></span><br><span class="line">&#125;)</span><br><span class="line">.handle((s, e) -&gt; &#123;</span><br><span class="line">    <span class="comment">//同whenComplete</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a>获取结果</h2><p>CompletableFuture实现了Future接口，提供<code>get()</code>方法来获取结果。除了<code>get()</code>外，CompletableFuture还提供了<code>join()</code>和<code>getNow()</code>。<code>join()</code>可能会抛出unchecked异常。<code>getNow()</code>无论如何都会返回一个结果，如果任务完成，就返回任务的结果；如果未完成，就返回指定的结果。</p>
<h1 id="批量任务"><a href="#批量任务" class="headerlink" title="批量任务"></a>批量任务</h1><p>CompletionService接口解耦了任务的生产和消费，该接口将线程池Executor和阻塞队列BlockingQueue功能融合在了一起，能够让批量异步任务的管理更简单。ExecutorCompletionService是CompletionService接口的官方实现。<br>CompletionService能够让异步任务的执行结果有序化，先执行完的先进入阻塞队列，先进行后续处理，避免无谓的等待。</p>
<p>RPC框架Dubbo中有一种叫做Forking的集群模式，这种集群模式下，支持并行地调用多个服务，只要有一个成功返回结果，整个服务就可以返回了。这个特性也可以借助CompletionService来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CompletionService使用例子</span></span><br><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">CompletionService&lt;Integer&gt; cs = <span class="keyword">new</span> ExecutorCompletionService&lt;&gt;(executor);</span><br><span class="line"></span><br><span class="line"><span class="comment">//批量提交任务</span></span><br><span class="line">cs.submit(()-&gt;task(<span class="number">1</span>));</span><br><span class="line">cs.submit(()-&gt;task(<span class="number">2</span>));</span><br><span class="line">cs.submit(()-&gt;task(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//按照执行完成的顺序取结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">    Integer r = cs.take().get();</span><br><span class="line">    <span class="comment">//其他业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>CompletionStage</tag>
        <tag>CompletionService</tag>
        <tag>Executor</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis数据源与连接池</title>
    <url>/2020/01/11/Mybatis%E6%95%B0%E6%8D%AE%E6%BA%90%E4%B8%8E%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<p>对于ORM（Object Relational Mapping）框架而言，数据源的组织是一个非常重要的一部分，这直接影响到框架的性能问题。本文将通过对MyBatis框架的数据源结构进行详尽的分析，并且深入解析MyBatis的连接池。</p>
<p>本文首先会讲述MyBatis的数据源的分类，然后会介绍数据源是如何加载和使用的。紧接着将分类介绍UNPOOLED、POOLED和JNDI类型的数据源组织；期间我们会重点讲解POOLED类型的数据源和其实现的连接池原理。</p>
<a id="more"></a> 


<p>MyBatis将数据源分为三种类型：</p>
<ol>
<li>unpooled，不使用连接池的数据源</li>
<li>pooled，使用连接池的数据源</li>
<li>JNDI，使用JNDI实现的数据源<br>相关的类分别在以下路径中：<br>org.apache.ibatis.datasource.unpooled<br>org.apache.ibatis.datasource.pooled<br>org.apache.ibatis.datasource.jndi</li>
</ol>
<h1 id="不使用连接池"><a href="#不使用连接池" class="headerlink" title="不使用连接池"></a>不使用连接池</h1><p>每次获取连接的时候都需要新建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//unpooled数据源</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Connection <span class="title">doGetConnection</span><span class="params">(Properties properties)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    initializeDriver();</span><br><span class="line">    <span class="comment">//通过drive创建新的连接</span></span><br><span class="line">    Connection connection = DriverManager.getConnection(url, properties);</span><br><span class="line">    configureConnection(connection);</span><br><span class="line">    <span class="keyword">return</span> connection;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用连接池"><a href="#使用连接池" class="headerlink" title="使用连接池"></a>使用连接池</h1><p>对于pooled数据源，它有两个队列：空闲队列和活跃队列。</p>
<p>空闲队列中保存的是空闲的连接，活跃队列中保存的是正在被使用的连接。</p>
<p>当我们需要获取连接时，会按照以下步骤获取：</p>
<ol>
<li><p>从空闲队列中获取连接；</p>
</li>
<li><p>空闲队列为空，则去查看活跃队列：</p>
<ol start="21">
<li><p>活跃队列未满，则新建连接并放入活跃队列；</p>
</li>
<li><p>活跃队列满，则挑选最早的连接查看是否过期：</p>
<ol start="221">
<li><p>最早的连接已过期，替换掉该连接；</p>
</li>
<li><p>最早的连接未过期，线程阻塞，等待唤醒。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pooled数据源，代码经过简化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> PooledConnection <span class="title">popConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> countedWait = <span class="keyword">false</span>;</span><br><span class="line">    PooledConnection conn = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">long</span> t = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">int</span> localBadConnectionCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//从连接池中拿连接是互斥的</span></span><br><span class="line">      <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!state.idleConnections.isEmpty()) &#123;</span><br><span class="line">          <span class="comment">//1. 若空闲队列中有连接，则直接使用该连接</span></span><br><span class="line">          conn = state.idleConnections.remove(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (state.activeConnections.size() &lt; poolMaximumActiveConnections) &#123;</span><br><span class="line">            <span class="comment">//2.1 活跃队列未满，则新建连接并放入活跃队列</span></span><br><span class="line">            conn = <span class="keyword">new</span> PooledConnection(dataSource.getConnection(), <span class="keyword">this</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            PooledConnection oldestActiveConnection = state.activeConnections.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">long</span> longestCheckoutTime = oldestActiveConnection.getCheckoutTime();</span><br><span class="line">            <span class="keyword">if</span> (longestCheckoutTime &gt; poolMaximumCheckoutTime) &#123;</span><br><span class="line">              <span class="comment">//2.2.1 活跃队列已满，最早的连接已过期</span></span><br><span class="line">              <span class="comment">//善后最早的连接并替换掉该连接</span></span><br><span class="line">              state.claimedOverdueConnectionCount++;</span><br><span class="line">              state.accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime;</span><br><span class="line">              state.accumulatedCheckoutTime += longestCheckoutTime;</span><br><span class="line">              state.activeConnections.remove(oldestActiveConnection);</span><br><span class="line">              <span class="keyword">if</span> (!oldestActiveConnection.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  oldestActiveConnection.getRealConnection().rollback();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                </span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              conn = <span class="keyword">new</span> PooledConnection(oldestActiveConnection.getRealConnection(), <span class="keyword">this</span>);</span><br><span class="line">              conn.setCreatedTimestamp(oldestActiveConnection.getCreatedTimestamp());</span><br><span class="line">              conn.setLastUsedTimestamp(oldestActiveConnection.getLastUsedTimestamp());</span><br><span class="line">              oldestActiveConnection.invalidate();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//2.2.2 活跃队列已满，最早的连接未过期</span></span><br><span class="line">              <span class="comment">//线程进入阻塞等待唤醒</span></span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!countedWait) &#123;</span><br><span class="line">                  state.hadToWaitCount++;</span><br><span class="line">                  countedWait = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> wt = System.currentTimeMillis();</span><br><span class="line">                state.wait(poolTimeToWait);</span><br><span class="line">                state.accumulatedWaitTime += System.currentTimeMillis() - wt;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line">    <span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pushConnection</span><span class="params">(PooledConnection conn)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">        state.activeConnections.remove(conn);</span><br><span class="line">        <span class="keyword">if</span> (conn.isValid()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (state.idleConnections.size() &lt; poolMaximumIdleConnections &amp;&amp; conn.getConnectionTypeCode() == expectedConnectionTypeCode) &#123;</span><br><span class="line">                PooledConnection newConn = <span class="keyword">new</span> PooledConnection(conn.getRealConnection(), <span class="keyword">this</span>);</span><br><span class="line">                state.idleConnections.add(newConn);</span><br><span class="line">                conn.invalidate();</span><br><span class="line">                state.notifyAll();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                conn.getRealConnection().close();</span><br><span class="line">                conn.invalidate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>池化技术</tag>
      </tags>
  </entry>
  <entry>
    <title>CopyOnWrite</title>
    <url>/2020/01/04/CopyOnWrite/</url>
    <content><![CDATA[<p>写时复制（Copy On Write，CoW）是一种计算机程序设计领域的优化策略。核心思想是，多个调用者同时请求相同资源时，他们会共同获得相同的指针指向相同的资源。直到某个调用者试图修改资源的内容时，系统才会真正复制一份给该调用者只读同一块资源，而其他调用者所见到的最初的资源仍然保持不变。<strong>之后根据策略的不同，复制出的资源可以覆盖旧资源，也可以仅供写资源的调用者使用</strong>。</p>
<a id="more"></a> 

<h1 id="Linux中的CoW"><a href="#Linux中的CoW" class="headerlink" title="Linux中的CoW"></a>Linux中的CoW</h1><p>在类Unix操作系统中创建进程的API是<code>fork()</code>，传统的fork()函数会创建父进程的一个完整副本，例如父进程的地址空间现在用到了1G的内存，那么子进程就要复制父进程整个1G地址空间，这个过程是很耗时的。</p>
<p>在Linux中，fork()子进程并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。而后只在父进程或者子进程需要写入的时候（如调用<code>exec()</code>系列函数，该函数会装载一个新的程序，替换掉当前进程的地址空间），才会复制地址空间，从而使父子进程拥有各自的地址空间。</p>
<p>fork()之后，内核把父进程中所有内存页的权限设为read-only，然后子进程的地址空间指向父进程。当父子进程都只读内存时，相安无事。当其中某个进程写内存时，CPU检测到内存页是read-only，于是触发页异常中断（page-fault），陷入内核的一个中断例程。中断例程中，内核会把触发异常的页复制一份，于是父子进程各自持有独立的一页。</p>
<h1 id="Redis中的CoW"><a href="#Redis中的CoW" class="headerlink" title="Redis中的CoW"></a>Redis中的CoW</h1><p>Redis的哈希表在rehash时，会根据BGSAVE命令或BGREWRITEAOF命令是否正在执行，决定要不要提高负载因子。</p>
<p>这是因为在执行上述命令的过程中，Redis会执行<code>fork()</code>创建子进程，而大多数操作系统都采用Copy on Write技术来优化子进程的使用效率，所以在子进程存在期间，Redis会提高负载因子，从而尽可能地避免在此期间进行哈希表扩容。这可以避免不必要的内存写入操作，避免不必要的资源复制。</p>
<h1 id="Java中的CoW"><a href="#Java中的CoW" class="headerlink" title="Java中的CoW"></a>Java中的CoW</h1><p>并发包中的CopyOnWriteArrayList和CopyOnWriteArraySet使用了CoW的思想实现了线程安全的List。相比较于对所有方法加了锁的Vector来说，CoW性能更好。CopyOnWriteArrayList对于读不加锁，性能很好；对于写加锁。</p>
<p>CopyOnWriteArrayList也有一些限制：</p>
<ol>
<li>每次写操作需要创建新的数组，容量较大时易频繁GC。</li>
<li>数据实时性不高，读取数据时，可能会拿到旧的数组。</li>
</ol>
<p>因此CopyOnWriteArrayList比较适合读多写少且对一致性要求不高的场景。例如RPC框架中保存在客户端的路由表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CopyOnWriteArrayList.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Linux中的fork()和Java中的CopyOnWriteArrayList都使用了写时复制（Copy on Write， CoW）的思想。fork()在写时会复制出两份资源，而CopyOnWriteArrayList会将新复制出的资源覆盖掉旧资源。</p>
<p>CoW的缺点是会消耗较多内存，所以在写操作频繁以及数据量较大时不适合使用。</p>
]]></content>
      <categories>
        <category>并发设计模式</category>
      </categories>
      <tags>
        <tag>CopyOnWrite</tag>
        <tag>CopyOnWriteArrayList</tag>
        <tag>fork</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>草稿</title>
    <url>/2020/01/01/%E8%8D%89%E7%A8%BF/</url>
    <content><![CDATA[<p>理论上，TCP滑动窗口大小设置为<code>带宽*单向时延*2</code>，乘以2的原因是可以充分利用信道。</p>
<a id="more"></a>

<p>进程间通信：</p>
<ul>
<li>共享内存</li>
<li>消息队列</li>
<li>信号量</li>
<li>Socket</li>
</ul>
<p>堆排序：第一步：自上而下建堆O(n)；第二步：输出元素并保持有序O(logn)，需要自上而下保持有序</p>
<p>堆插入：自下而上</p>
<p>逃逸分析：JVM对程序的优化，可从以下三个方面进行优化：</p>
<ol>
<li>栈上分配。不会逃逸的局部变量会被分配在栈上，减少GC。</li>
<li>同步消除。不会线程逃逸的变量，会优化掉与之相关的锁。</li>
<li>标量替换。</li>
</ol>
<p>RPC VS MQ</p>
<ol>
<li>RPC耦合，MQ解耦；</li>
<li>MQ可削峰填谷；</li>
<li>MQ可广播。</li>
</ol>
<p>测试IO/CPU耗时比例：apm工具</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LockSupport.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">            UNSAFE.unpark(thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>重复请求：幂等</li>
<li>并发请求：串行、锁</li>
<li>超量请求：扩容、限流、拒绝</li>
<li>消息乱序：锁+版本号+幂等</li>
<li>非法调用：鉴权</li>
<li>依赖不稳定：超时控制、降级、熔断</li>
</ul>
<p>阻塞队列可以用来实现池化技术</p>
<p>编译时环境：*.java -&gt; *.class（机器码）</p>
<p>运行时环境：*.class -&gt; 加载进JVM</p>
<p>对于C/C++，在编译时选择平台</p>
<p>对于Java，在运行时选择平台</p>
<p>JDK内置工具使用jps、jstack、jmap、jstat</p>
<p>Java visualVM</p>
<p>计算机领域的所有问题都可以通过加一个中间层解决。</p>
<p>All problems in computer science can be solved by another level of indirection. –David Wheeler(世界上第一个计算机博士，剑桥大学)</p>
<p><a href="https://en.wikipedia.org/wiki/David_Wheeler_(computer_scientist)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/David_Wheeler_(computer_scientist)</a> </p>
<h1 id="Java-函数式接口"><a href="#Java-函数式接口" class="headerlink" title="Java 函数式接口"></a>Java 函数式接口</h1><p>函数式接口：有且仅有一个抽象方法，但可以有多个非抽象方法。</p>
<p>Java8新增了函数式接口，新增的类在<code>java.util.function</code>这个路径下。函数式接口可以被隐式转换为 lambda 表达式。在Java8引入函数式接口之前，其实Java中已经有函数式接口了，就是我们比较熟悉的Runnable和Callable。函数式接口会用注解<code>@FunctionalInterface</code>修饰，该注解主要作用是检查接口是否满足函数式接口的要求，即只有一个抽象方法。</p>
<table>
<thead>
<tr>
<th align="left">接口</th>
<th>是否需要输入参数</th>
<th>是否有返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Consumer</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td align="left">Function</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td align="left">Supplier</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td align="left">Predicate</td>
<td>1</td>
<td>Boolean</td>
</tr>
<tr>
<td align="left">Runnable</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td align="left">Callable</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<p>操作系统：</p>
<p>信号量模型</p>
<p>管程模型（管程与信号量是等价的）</p>
<p>并发问题的三个核心问题：分工、同步、互斥。</p>
<p>分工：如何高效地拆解任务并分配给线程，哪些任务可并行，哪些任务需串行，任务的分工影响着程序的并发性能；</p>
<p>同步：线程之间如何协作，即一个线程执行完了一个任务，如何通知下一个线程执行；</p>
<p>互斥：保证同一时刻只允许一个线程访问共享资源，互斥解决的是线程安全性的问题。</p>
<img src="/2020/01/01/草稿/并发思维导图.png" title="并发思维导图"> 



<h1 id="并发问题的根源"><a href="#并发问题的根源" class="headerlink" title="并发问题的根源"></a>并发问题的根源</h1><p>计算机中的CPU、内存、IO设备这三者的速度差异一直都在，为了充分榨干CPU的性能，平衡这三者的性能差异，人们采取了以下方法：</p>
<ol>
<li>引入CPU缓存，平衡CPU和内存之间的速度差异；</li>
<li>对CPU进行分时复用，平衡CPU与IO设备之间的速度差异（多线程）；</li>
<li>编译程序时对指令进行重排序，更加充分利用缓存。</li>
</ol>
<p>但是这些优化措施会带来其他方面的一些问题，需要</p>
<p>引入缓存会带来可见性的问题，线程切换会带来原子性的问题，编译优化会带来有序性的问题。</p>
<p>解决这些问题的思路也比较简单，就是禁用相应的优化机制，例如要解决可见性的问题，就按需禁用缓存；解决原子性的问题，就按需禁止线程切换；解决有序性的问题，就按需禁用编译优化。</p>
<p>其中可见性和有序性的解决依靠的是Java内存模型，具体来说涉及到<strong>volatile</strong>、<strong>synchronized</strong>、<strong>final</strong>三个关键字以及六项<strong>Happens-Before</strong>规则。 原子性利用互斥锁解决。</p>
<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><p>Java8添加了一个新的接口Stream，该接口支持以串行或者并行的方式处理数据。</p>
<p>Stream将要处理的元素看作流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选、排序、聚合等。</p>
<p>元素流在管道中的操作分为两种类型：经过中间操作（intermediate operation）和最终操作(terminal operation)。</p>
<ul>
<li>中间操作：中间操作会返回一个新的流，交给下一个操作使用，一个流后面可以跟随零个或多个中间操作。中间操作都是惰性化的（lazy），即调用中间操作时不进行执行动作，在调用最终操作时才真正开始执行动作。</li>
<li>最终操作：最终操作会返回最终的结果。一个流只能有一个最终操作，当这个操作执行后，流就被消费完了，无法再被操作。</li>
</ul>
<p>中间操作：</p>
<ul>
<li>filter()</li>
<li>map()</li>
<li>flatMap()</li>
<li>distinct()</li>
<li>sorted()</li>
<li>peek()</li>
<li>limit()</li>
<li>skip()</li>
</ul>
<p>最终操作：</p>
<ul>
<li>forEach()</li>
<li>forEachOrdered()</li>
<li>toArray()</li>
<li>reduce()</li>
<li>collect()</li>
<li>min()</li>
<li>max()</li>
<li>count()</li>
<li>anyMatch()</li>
<li>allMatch()</li>
<li>noneMatch()</li>
<li>findFirst()</li>
<li>findAny()</li>
</ul>
<p>串行与并行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">10000</span>).forEach(list1::add);<span class="comment">//串行</span></span><br><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">10000</span>).parallel().forEach(list2::add);<span class="comment">//并行，但线程不安全</span></span><br></pre></td></tr></table></figure>

<p>Java中有三种方式可以做并行：</p>
<ul>
<li><p>ThreadPoolExecutor线程池</p>
</li>
<li><p>Fork/Join框架</p>
</li>
<li><p>Stream并行流</p>
</li>
</ul>
<p>关于这三个方式的性能比较，具体可参见参考资料。</p>
<p><a href="https://blog.overops.com/forkjoin-framework-vs-parallel-streams-vs-executorservice-the-ultimate-benchmark/" target="_blank" rel="noopener">https://blog.overops.com/forkjoin-framework-vs-parallel-streams-vs-executorservice-the-ultimate-benchmark/</a> </p>
<p>Java Stream性能测试</p>
<p>三种方式遍历集合：</p>
<ul>
<li>显式for循环</li>
<li>串行Stream</li>
<li>并行Stream</li>
</ul>
<p>并行Stream在任何时候好于其他两者。简单操作for循环好于串行Stream，复杂操作for循环与串行Stream相当。</p>
<p><a href="https://www.cnblogs.com/secbro/p/11653574.html" target="_blank" rel="noopener">https://www.cnblogs.com/secbro/p/11653574.html</a></p>
<p><a href="https://www.cnblogs.com/CarpenterLee/p/6675568.html" target="_blank" rel="noopener">https://www.cnblogs.com/CarpenterLee/p/6675568.html</a></p>
<p> Java线程是和操作系统线程一一对应的，这种做法本质上是将Java线程的调度权完全委托给操作系统，而操作系统在这方面非常成熟，所以这种做法的好处是稳定、可靠，但是也继承了操作系统线程的缺点：创建成本高。为了解决这个缺点，Java并发包里提供了线程池等工具类。</p>
<p>除了线程一一对应的方案外。业界还有另外一种方案：<strong>轻量级线程</strong>（协程）。这个方案在Java领域知名度并不高，但是在Go、Lua等语言中较为知名。轻量级线程的创建成本很低，基本上和创建一个普通对象的成本相似；并且创建的速度和内存占用相比操作系统线程至少有一个数量级的提升。</p>
<p>OpenJDK有个Loom项目，就是要解决Java轻量级线程问题，在这个项目中，轻量级线程被叫做<strong>Fiber</strong>。</p>
<p>在JDK中有ArrayBlockingQueue和LinkedBlockingQueue两种有界队列，它们都是基于ReentrantLock实现的，在高并发场景下，锁的效率并不高。</p>
<p>Disruptor是一款性能优异的有界无锁内存队列，由LMAX公司开发。 Disruptor应用广泛，在Log4j2、Spring Messaging、HBase、Storm中都有应用。</p>
<p>Disruptor之所以性能优异，主要有以下几点原因：</p>
<ol>
<li>内存分配更加合理，使用RingBuffer数据结构，数组元素在初始化时一次性全部创建，提升缓存命中率；对象循环利用，避免频繁GC。</li>
<li>能够避免伪共享，提升缓存利用率。</li>
<li>采用无锁算法，避免频繁加锁、解锁的性能消耗。</li>
<li>支持批量消费，消费者可以无锁方式消费多个消息。</li>
</ol>
<p>这里比较难理解的是第二点伪共享（False sharing）。伪共享会使得Cache失效。 伪共享和CPU内部的Cache有关，Cache内部是按照缓存行（Cache Line）管理的，缓存行的大小通常是64个字节。CPU从内存中加载数据X，会同时加载X后面<code>64-size(X)</code>个字节的数据，以填充满Cache Line。如果一行Cache Line中有多个变量，在多线程环境下，可能被预加载进来的其他变量会因为其他线程的写操作而失效，进而需要重新加载。这样的话，就起不到缓存的作用了。</p>
<p>Disruptor在优化并发性能方面可谓是做到了极致，优化的思路大体是两个方面：一个是利用无锁算法避免锁的争用，另外一个则是将硬件（CPU）的性能发挥到极致。尤其是后者，在Java领域基本上属于经典之作了。发挥硬件的能力一般是C这种面向硬件的语言擅长做的事，C语言领域经常通过调整内存布局优化内存占用，而Java领域则用的很少，原因在于Java可以智能地优化内存布局，内存布局对程序员是透明的。这种智能的优化大部分场景是很友好的，但是对于伪共享这种情况，就需要通过填充的方式来避免。</p>
<p>Java8提供了避免伪共享的注解<code>@sun.misc.Contended</code>，通过这个注解可以轻松避免伪共享（需要设置JVM参数 -XX:-RestrictContended），无需手动去填充。需要注意的是避免伪共享是以牺牲内存为代价的。</p>
]]></content>
      <categories>
        <category>草稿</category>
      </categories>
  </entry>
  <entry>
    <title>基于Redis的分布式锁</title>
    <url>/2019/12/30/%E5%9F%BA%E4%BA%8ERedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h1 id="基于Redis的分布式锁"><a href="#基于Redis的分布式锁" class="headerlink" title="基于Redis的分布式锁"></a>基于Redis的分布式锁</h1><a id="more"></a> 

<p>互斥性</p>
<p>防止未执行完，锁就过期（后台启动续命线程）</p>
<p>阻塞和非阻塞</p>
<p>未获取到锁的线程可阻塞（CAS），可非阻塞。</p>
<p>可重入性</p>
<p>加锁之前先查看本线程的锁ID是否已上锁</p>
<p>安全性</p>
<p>防止死锁（1.设置过期时间；2.占用锁与设置过期时间应该为原子操作）</p>
<p>防止锁被其他线程任意释放（使用UUID+线程ID作为锁ID）</p>
<p>高可用</p>
<p>防止Redis单机故障（1.Redis使用集群方案，进行数据分片；2.每次取回多个锁）</p>
<p>Redisson分布式锁使用hash作为底层数据结构，hash的key为lockName，field为UUID+threadId。</p>
<p>为了防止锁被其他线程随意释放，field应该对其他线程保密。</p>
<p>获取锁的线程会启动一个后台线程，该线程用于延长锁的过期时间，每隔10秒重新设置30秒的过期时间。</p>
<p>获取锁</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">'exists'</span>, name) == <span class="number">0</span>) <span class="keyword">then</span> <span class="comment">--判断是否存在锁</span></span><br><span class="line">	redis.call(<span class="string">'hset'</span>, lockName, UUID+threadId, <span class="number">1</span>);</span><br><span class="line">	redis.call(<span class="string">'pexpire'</span>, lockName, expireTime);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">'hexists'</span>, lockName, UUID+threadId) == <span class="number">1</span>) <span class="keyword">then</span> <span class="comment">--判断该锁是否是自己线程的锁</span></span><br><span class="line">	redis.call(<span class="string">'hincrby'</span>, lockName, UUID+threadId, <span class="number">1</span>);</span><br><span class="line">	redis.call(<span class="string">'pexpire'</span>, lockName, expireTime);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">return</span> redis.call(<span class="string">'pttl'</span>, lockName); <span class="comment">--获取锁失败，返回锁的过期时间</span></span><br></pre></td></tr></table></figure>

<p>释放锁</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">'hexists'</span>, lockName, UUID+threadId) == <span class="number">0</span>) <span class="keyword">then</span> <span class="comment">--无锁则不需要释放</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">local</span> counter = redis.call(<span class="string">'hincrby'</span>, lockName, UUID+threadId, <span class="number">-1</span>); <span class="comment">--释放锁</span></span><br><span class="line"><span class="keyword">if</span> (counter &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">	redis.call(<span class="string">'pexpire'</span>, lockName, expireTime); <span class="comment">--因锁的可重入性，还未完全释放</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	redis.call(<span class="string">'del'</span>, lockName); <span class="comment">--完全释放锁</span></span><br><span class="line">	redis.call(<span class="string">'publish'</span>, channelName, message);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br></pre></td></tr></table></figure>

<p>方案缺陷</p>
<p>在CAP理论中，Redis属于AP架构。主从架构下，可能会导致多个客户端拿到锁，失去互斥性。</p>
<p>一个客户端从master拿到了锁，在主从同步完成之前，master宕机，slave晋升为master。由于slave没有锁信息，这时第二个客户端可以进行加锁。</p>
<p>针对这个提问，Redis的作者提出了RedLock。RedLock的思想是使用奇数个Redis master，这些master完全独立，没有哨兵、主从、集群之类的关系。从其中的一个master上获取锁与上述方案一致，只要拿到半数以上的锁，视为获取分布式锁成功。如果其中一台master发生故障，切换为无锁信息的slave，也不会失去互斥性。如果如果同时宕机的数量超过半数以上，那还是会丢失互斥性，只是这种事情发生的概率较低。</p>
<p>分布式锁其他方案</p>
<p>Zookeeper属于CP架构</p>
<p>mysql锁行</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>分布式锁</tag>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2019/12/26/MySQL/</url>
    <content><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>三种常见索引：</p>
<ol>
<li>哈希表：适合等值查询，不适合区间查询；</li>
<li>有序数组：使用二分法查询等值和区间值，复杂度为O(logn)，但只适合静态数据，不再修改的数据；</li>
<li>树：Innodb的索引采用B+树，是一个N叉树，这里N大约为1200.</li>
</ol>
<a id="more"></a> 



<p>B树与B+树的区别：</p>
<ul>
<li>B+树非叶子节点不存数据，只存索引。那么就可以存储更多的索引，减小树的高度；</li>
<li>B+树叶子节点之间用链表关联，方便区间查询。</li>
</ul>
<p>聚簇索引：索引与数据存储在一起；</p>
<p>二级索引（普通索引）：数据不与索引在一起，需要回表查询（即还需要到聚簇索引中再查询一遍）；</p>
<p>联合索引：用多个字段联合建立的索引，可防止回表查询</p>
<p>建议使用自增主键，不要使用业务字段作为主键：</p>
<ol>
<li>性能方面：自增主键有序，不会造成叶子节点的分裂（业务字段往往无序）；</li>
<li>空间方面：自增主键往往占用空间小于业务字段，可减小索引占用空间。</li>
</ol>
<p>Buffer Pool</p>
<p>Innodb会在内存中开辟一块区域用以存放索引和数据。这块区域就是Buffer Pool。这块区域越大，Mysql的性能就越接近内存型数据库（如Redis等）。</p>
<p>Innodb的最小存储单位是page，在旧版本中，一个page的大小是16KB。在新版本中，page的大小可设置。Innodb以页为单位从磁盘读入数据放入Buffer Pool中。Buffer Pool使用改进的LRU算法进行缓存淘汰。主要有两点改进：</p>
<ul>
<li>对缓存进行分区域管理，参数<code>innodb_old_blocks_pct</code>可调整两区域的比例，可对预读进行优化；</li>
<li>对热数据提至头部设置时间阈值，参数<code>innodb_old_blocks_time</code>可调整时间阈值，可对全表扫描进行优化。</li>
</ul>
<p>Buffer Pool被划分为两个区域：new sublist和old sublist。新加入的页会被放到old sublist的头部。若某一页被访问到了，就会被提至new sublist的头部，说明该页是热数据。old sublist的尾部是最冷的数据，随时会被淘汰。</p>
<p><code>innodb_old_blocks_pct</code>：默认为37。该值表示old sublist占整个Buffer Pool的比例。值越小，越接近传统的LRU算法。对于预读，Innodb会将访问数据之后的页也读入Buffer Pool，如果预读的页在后续操作中没使用到，就会挤出宝贵的热点数据。Buffer Pool划分了区域后，无用的预读页对热点数据的影响会降到最低。</p>
<p><code>innodb_old_blocks_time</code>：默认为0。该值表示当新页插入old sublist中，需要停留的时间。过了这个停留时间后的访问才能将该页移动到new sublist头部。设置该参数可防止全表扫描污染热点数据的问题。对于全表扫描，会读入许多页，而这些页在后续的操作中大概率是用不到的，所以这些页不应该被移动到new sublist中。</p>
<p>悲观锁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">select status from goods where id=#&#123;id&#125; for update;</span><br><span class="line">update goods set status=#&#123;status&#125; where id=#&#123;id&#125;;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>排他锁</p>
<p><code>select ... for update</code></p>
<p>共享锁</p>
<p><code>select ... lock in share mode</code></p>
<p>乐观锁</p>
<p>通过版本号实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">select (status,version) from goods where id=#&#123;id&#125;;</span><br><span class="line"></span><br><span class="line">update goods </span><br><span class="line">set statstatus=#&#123;status&#125;, version=version+1 </span><br><span class="line">where id=#&#123;id&#125; and version=#&#123;version&#125;;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>Buffer Pool：<a href="https://dev.mysql.com/doc/refman/5.5/en/innodb-buffer-pool.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.5/en/innodb-buffer-pool.html</a> </p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
        <tag>锁</tag>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2019/12/26/Redis/</url>
    <content><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><ol>
<li>字符串：int、raw、embstr</li>
<li>列表：ziplist和linkedlist</li>
<li>哈希表：ziplist和hashtable</li>
<li>集合：intset和hashtable</li>
<li>有序集合：ziplist和skiplist</li>
</ol>
<p>ziplist是一种经过特殊编码的双向链表，不同于普通的双向链表，ziplist存储在一块连续的内存中。ziplist的特殊编码节省了数据所占用的内存。ziplist的每个数据项上都保存有本项的数据长度和上一项的数据长度。这样可以通过指针的运算跳到上一个或者下一个数据项。</p>
<a id="more"></a> 

<p>由于ziplist在一块连续内存上，对ziplist的追加操作就需要重新分配一块新的内存空间，并把旧数据搬移到新内存。</p>
<p>且对ziplist的查找操作需要遍历，效率较低，所以在数据量比较小的时候适合使用ziplist。</p>
<h2 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h2><p>惰性删除+定期删除</p>
<p>惰性删除：获取键之前检测是否过期</p>
<h2 id="RDB持久"><a href="#RDB持久" class="headerlink" title="RDB持久"></a>RDB持久</h2><p>生成RDB：SAVE和BGSAVE这两个命令都可以生成RDB文件。SAVE会阻塞服务，BGSAVE会fork子进程，在子进程中进行生成RDB。可以设置满足一定条件自动执行BGSAVE。</p>
<p>同时满足两个条件可触发BGSAVE：距离上次SAVE已经过去的时间 &amp;&amp; 距离上次SAVE修改的次数</p>
<p>系统启动时，会优先载入AOF文件，若不存在则载入RDB文件。</p>
<h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><p>AOF文件保存客户端发来的请求。先保存在程序中的缓冲区中</p>
<ol>
<li>写请求命令保存在程序中的aof_buf缓冲区中；</li>
<li>在服务器每个循环事件的结束阶段，调用flushAppendOnlyFile函数将aof写入磁盘中；</li>
<li>由于第二步是调用系统函数write进行写操作，会写到操作系统的page cache中。落盘需要调用fsync函数，具体什么时候落盘，可以通过设置appendfsync来实现。</li>
</ol>
<p><strong>aof重写</strong></p>
<p>aof文件会随着Redis的使用慢慢变大，我们可以通过aof重写来减小aof文件的大小。aof重写通过读取数据库现有数据来实现。</p>
<p>aof重写是后台进程，Redis在重写过程中，客户端可能会有新的写请求进来，这些写请求会被放到重写缓存区中。等到后台aof重写完成后，再把重写缓存区中的写请求追加到重写完成的aof文件中。</p>
<p>系统启动时，会优先载入AOF文件，若不存在则载入RDB文件。</p>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><h3 id="Redis2-8之前的复制"><a href="#Redis2-8之前的复制" class="headerlink" title="Redis2.8之前的复制"></a>Redis2.8之前的复制</h3><ol>
<li>从服务器向主服务器发送SYNC命令；</li>
<li>主服务器收到SYNC命令后开始执行BGSAVE命令以生成RDB文件，并在缓存区中记录生成过程中的写请求；</li>
<li>将RDB文件和缓冲区中的写请求发送给从服务器；</li>
<li>对于后续的写请求，都会传送至从服务器</li>
</ol>
<h3 id="Redis2-8之后的复制"><a href="#Redis2-8之后的复制" class="headerlink" title="Redis2.8之后的复制"></a>Redis2.8之后的复制</h3><p>针对2.8之前版本较为低效的复制，2.8之后的新版本做了改进。</p>
<p>在2.8之前的版本中，如果从服务器因为网络问题断线后重连，那么没有办法只补断线阶段的写请求，需要重新给主服务器发送SYNC命名，重新走一遍流程。主从服务器可以通过各自的偏移量来确定主从是否一致。</p>
<p>在2.8之后的版本中，引入了PSYNC部分同步的命令，从服务器断线重连后，发送PSYNC命令给主服务器。主服务器会将断线期间的命令从缓冲区捞出发给从服务器，若断线期间的数据量太大，导致缓冲区放不下，那么就需要发送SYNC命令，重新开始同步。</p>
<h2 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h2><p>从服务器会定期向主服务器发送心跳包进行心跳检测，有三个作用：</p>
<ol>
<li>检测主从之间的网络状态；</li>
<li>实现min-slaves，即如果少于特定数量的从服务器或者时延太大，主服务器就拒绝写入，只能读；</li>
<li>若由于主从包丢失造成的主从不一致，可进行补发。</li>
</ol>
<h2 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h2><p>在Redis中，用户可以通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制另一个服务器，被复制的服务器为主服务器，而对主服务器进行复制的服务器则被称为从服务器。</p>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>哨兵是Redis高可用的解决方案。哨兵系统由一个或多个哨兵节点组成。可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p>
<p>在主从模式下，若主机发生故障，Redis就无法对外提供服务。这时需要引入哨兵模式。</p>
<h2 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h2><p>Redis Cluster是Redis 3.0之后推出的分布式集群方案。提供数据分片、主从复制、故障转移等功能。若选用Redis Cluster方案，就不需要哨兵了。</p>
<p>一个集群由多个节点组成，整个集群的数据被分为16384个槽，不同的节点分担不同的槽。</p>
<p>在一个完成分片的集群中，我们可以通过命令重新分片。源节点会将相应的槽逐步迁移至目标节点。</p>
<p>由于集群是去中心化的，客户端可以向其中任意一个节点发起请求。客户端请求一个key，若key不在该节点上，该节点会返回MOVED错误，并把正确的节点告知客户端。客户端之后需向正确的节点再次发起请求。</p>
<p>如果请求的节点是重新分片中的源节点且没有发现相应的key，那么该节点会返回ASK错误，并返回目标节点，告知客户端可以去目标节点查询。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>渐进式哈希</tag>
        <tag>跳表</tag>
        <tag>集群</tag>
        <tag>主从</tag>
      </tags>
  </entry>
  <entry>
    <title>IO模型</title>
    <url>/2019/12/25/IO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>在Unix下有5中IO模型</p>
<ul>
<li>同步阻塞IO</li>
<li>同步非阻塞IO</li>
<li>IO多路复用</li>
<li>异步IO</li>
<li>信号驱动IO</li>
</ul>
<a id="more"></a> 

<p>一个输入操作通常包含两个阶段：</p>
<ol>
<li>等待数据。等待网络中的数据分组到达，数据会被拷贝到内核缓冲区中。</li>
<li>获取数据。将数据从内核拷贝到进程。</li>
</ol>
<p>第一阶段等待数据可以区分是否阻塞，第二阶段获取数据可以区分同步或异步。</p>
<p>根据POSIX对同步IO和异步IO的定义，在上述5种IO模型中，除了异步IO，其他都是同步IO。上述四种同步IO在第二阶段都会被阻塞。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>《UNIX网络编程》</p>
]]></content>
      <categories>
        <category>IO模型</category>
      </categories>
      <tags>
        <tag>NIO</tag>
        <tag>BIO</tag>
        <tag>AIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的字符串</title>
    <url>/2019/12/20/String/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在Java中与字符串有关的类有String、StringBuilder、StringBuffer。</p>
<a id="more"></a> 



<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>String类与其中的成员变量value都是final的，value是一个定长数组，代表着String一旦初始化好就不能改变。一切对原String的修改操作都会创建新的String对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以concat和substring为例子说明修改操作都会返回一个新的String对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> otherLen = str.length();</span><br><span class="line">        <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = value.length;</span><br><span class="line">        <span class="keyword">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">        str.getChars(buf, len);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> subLen = value.length - beginIndex;</span><br><span class="line">        <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="keyword">this</span> : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么String是不可变对象"><a href="#为什么String是不可变对象" class="headerlink" title="为什么String是不可变对象"></a>为什么String是不可变对象</h2><ol>
<li>性能。String会被保存到常量池中，相同的String会指向常量池中相同的对象。在保证性能的背景下，String对象需要是不可变的。可变的String会造成线程不安全，例如在HashMap的使用场景中，用String作Key，当该Key被某一线程修改时，其他线程会出现找不到Key和Value的情况。</li>
<li>安全。String在Java中的用处广泛，例如操作某个文件、打开某个连接、加载某个类等，这些操作都会使用String。若String可变的话，在进行这些操作时，文件名、连接名、类名可能会被有意或无意地改动。</li>
<li>省内存。不可变的String保存在常量池中可以节省内存使用。</li>
</ol>
<h1 id="StringBuilder与StringBuffer"><a href="#StringBuilder与StringBuffer" class="headerlink" title="StringBuilder与StringBuffer"></a>StringBuilder与StringBuffer</h1><p>StringBuilder和StringBuffer都继承了抽象类AbstractStringBuilder，在抽象类中，value是一个变长数组，增加字符串时，若char数组空间足够，则直接添加；若空间不够，则会new一个更大的数组，将旧数据搬移过去。由于搬移数据是native方法，使用指针寻址来保证效率。</p>
<p>StringBuilder和StringBuffer的区别就在于，前者是线程不安全的，后者是线程安全的，线程安全的方法就是在整个方法上加<code>synchronized</code>。因此在使用性能上，StringBuilder是好于StringBuffer的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>String、StringBuilder、StringBuffer都是使用<code>char</code>数组来保存字符串，区别是String的<code>char[]</code>是不可变对象，其余两者是可变对象。</p>
<p>另外StringBuilder和StringBuffer的区别是，线程的安全与否，线程安全的类中所有方法都使用<code>synchronized</code>修饰。</p>
]]></content>
      <categories>
        <category>Java知识</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Thread</title>
    <url>/2019/12/20/Thread/</url>
    <content><![CDATA[<h1 id="通用的线程生命周期"><a href="#通用的线程生命周期" class="headerlink" title="通用的线程生命周期"></a>通用的线程生命周期</h1><p>通用的线程生命周期可以用五态模型来描述。这五态分别是：初始状态、可运行状态、运行状态、休眠状态和终止状态。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//五态模型</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  初始状态</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line"><span class="comment">//  可运行状态←---</span></span><br><span class="line"><span class="comment">//    ↑↓        ↑</span></span><br><span class="line"><span class="comment">//  运行状态  →	休眠状态</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line"><span class="comment">//  终止状态</span></span><br></pre></td></tr></table></figure>

<ol>
<li><strong>初始状态</strong>。线程已经被创建，但是还不允许分配CPU执行。这个状态属于编程语言特有的，在操作系统层面，真正的线程还没有创建。</li>
<li><strong>可运行状态</strong>。真正的操作系统线程已经成功创建，线程可以分配 CPU 执行。</li>
<li><strong>运行状态</strong>。当有空闲的CPU时，操作系统会将其分配给一个处于可运行状态的线程，被分配到CPU的线程为、运行状态。</li>
<li><strong>休眠状态</strong>。运行状态的线程如果调用一个阻塞API，那么线程的状态就会转换到休眠状态。</li>
<li><strong>终止状态</strong>。线程执行完或者出现异常就会进入终止状态，终止状态的线程不会切换到其他任何状态，进入终止状态也就意味着线程的生命周期结束了。 </li>
</ol>
<p>在不同的编程语言中，线程状态也不同。在Java中，线程共有6种状态，合并了可运行和运行状态，细化了休眠状态。在Thread类中有枚举来详细定义和说明：</p>
<a id="more"></a> 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Thread.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>NEW</strong> 线程刚创建，还未分配CPU执行；</p>
</li>
<li><p><strong>RUNNABLE</strong> 线程可以分配CPU执行，调用<code>Thread.start()</code>可进入该状态；</p>
</li>
<li><p><strong>BLOCKED</strong> 线程等待进入临界区，只有等待synchronized隐式锁这一个场景，才会使线程进入该状态；</p>
</li>
<li><p><strong>WAITING</strong> 线程在临界区里面等待唤醒，调用<code>Object.wait()</code>、<code>Thread.join()</code>、<code>LockSupport.park()</code>这三个方法会使线程进入该状态；</p>
</li>
<li><p><strong>TIMED_WAITING</strong> 这个状态就是有时间限制的WAITING，调用带时间参数的<code>Objec.wait()</code>、<code>Thread.join()</code>、<code>LockSupport.park()</code>、<code>Thread.sleep()</code>这些方法会使线程进入该状态；</p>
</li>
<li><p><strong>TERMINATED</strong> 线程执行完run()方法或者抛出异常，处于该状态的线程会被GC。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java线程模型</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  初始状态(NEW)</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line"><span class="comment">//  可运行/运行状态(RUNNABLE)←---→休眠状态(BLOCKED/WAITING/TIMED_WAITING)</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line"><span class="comment">//  终止状态(TERMINATED)</span></span><br></pre></td></tr></table></figure>

<p>使用jstack诊断问题（待补充）</p>
<p>死锁、饥饿等情况可以通过跟踪分析线程的状态来解决</p>
]]></content>
      <categories>
        <category>Java知识</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Collection_List_Set</title>
    <url>/2019/12/19/Collection-List-Set/</url>
    <content><![CDATA[<h1 id="Collection、List与Set接口"><a href="#Collection、List与Set接口" class="headerlink" title="Collection、List与Set接口"></a>Collection、List与Set接口</h1><p>Collection代表一群元素的集合，至于这群元素怎么排列、是否可重复、是否有序等特性，Collection接口没有作定义。</p>
<p>List和Set继承了Collection接口，他们都具体描述了这群集合元素的特性。</p>
<p>List描述了这群元素是有序且允许重复元素的，用户可通过序号精准地访问到元素。所以List比Collection多的方法，大多跟index有关，比如<code>void add(int index, E e)</code>。</p>
<p>Set描述了这群元素是无序且没有重复元素的，Set没有扩展Collection的方法，方法与Collection一样。</p>
]]></content>
      <categories>
        <category>Java知识</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>String_intern</title>
    <url>/2019/12/19/String_intern/</url>
    <content><![CDATA[<h1 id="String-intern"><a href="#String-intern" class="headerlink" title="String intern"></a>String intern</h1><p>String类中有个<code>intern()</code>的native，该方法会查询常量池中是否存在该字符串，若存在，则返回；若不存在则加入常量池并返回。在实现细节方面，JDK6又是与JDK7是不一样的。</p>
<a id="more"></a> 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>下面以一段常见的demo来说明问题。</p>
<p>String的创建：</p>
<ol>
<li><p>直接使用双引号声明出来的<code>String</code>对象会直接存储在常量池中。 </p>
</li>
<li><p>使用new关键字创建的<code>String</code>对象存储在堆中。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//出现了字面量"1"，这个会被存储在常量池中</span></span><br><span class="line">    <span class="comment">//s指向的对象在堆中</span></span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为常量池中已存在"1"，所以该语句无影响</span></span><br><span class="line">    s.intern();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//s2指向的对象在常量池中</span></span><br><span class="line">    String s2 = <span class="string">"1"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//false</span></span><br><span class="line">    System.out.println(s == s2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//常量池中已经存在"1"</span></span><br><span class="line">    <span class="comment">//s3指向堆中的对象，值为"11"</span></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//JDK6和7的区别点就在这里</span></span><br><span class="line">    <span class="comment">//JDK6:"11"不存在常量中，创建"11"并放入常量池</span></span><br><span class="line">    <span class="comment">//JDK7:"11"不存在常量中，在常量池中放入s3</span></span><br><span class="line">    s3.intern();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//JDK6:s4指向的对象在常量池中</span></span><br><span class="line">    <span class="comment">//JDK7:s4指向的对象就是s3</span></span><br><span class="line">    String s4 = <span class="string">"11"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//JDK6:false</span></span><br><span class="line">    <span class="comment">//JDK7:true</span></span><br><span class="line">    System.out.println(s3 == s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序在JDK6上的内存结构图</p>




<p>该程序在JDK7上的内存结构图</p>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">    s.intern();</span><br><span class="line">    String s2 = <span class="string">"1"</span>;</span><br><span class="line">    System.out.println(s == s2);</span><br><span class="line">    </span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下两句交换顺序</span></span><br><span class="line">    <span class="comment">//"11"不存在常量池中，于是创建"11"对象放入常量池</span></span><br><span class="line">    <span class="comment">//这里要与intern区分，因为是用字面量创建s4，所以会创建"11"对象</span></span><br><span class="line">    String s4 = <span class="string">"11"</span>;</span><br><span class="line">    s3.intern();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//JDK7:false</span></span><br><span class="line">    System.out.println(s3 == s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序在JDK7上的内存结构图</p>




<p>在不同的JDK中，常量池存放的地方也不同</p>
<p>JDK6：常量池在永久代中</p>
<p>JDK7：常量池在堆中</p>
<p>JDK8：常量池在元空间中</p>
<p>其中<strong>永久代</strong>和<strong>元空间</strong>都是方法区的一种HotSpot VM实现，方法区是JVM所定义的规范。</p>
<p>结合常量池的存放位置，可以更好地理解intern()行为的区别。在JDK6中，永久代和堆不一样，所以常量池无相应字符串时会创建新对象。在JDK7中，由于都在堆中，常量池会引用堆中的字符串对象，不会创建新对象。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html</a> </p>
]]></content>
      <categories>
        <category>Java知识</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程之协作</title>
    <url>/2019/12/10/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%8D%8F%E4%BD%9C/</url>
    <content><![CDATA[<p>并发编程领域可以抽象为3个核心问题：分工、协作、互斥。</p>
<p>本文介绍协作。</p>
<p>在多线程环境中，多个线程之间会有依赖关系，例如该任务完成后如何通知后续任务开始。Java JDK中提供了Semaphore、CountDownLatch、CyclicBarrier等工具来完成线程之间的协作。这些工具是针对特定场景抽象出的解决方案，若遇到某些特殊场景无法使用工具的，则需要自己完成线程之间的协作。这时可以使用<strong>管程（Monitor）</strong>来完成，管程是Java并发领域解决协作问题的核心方法，JDK中线程协作工具的底层实现都是管程。</p>
<a id="more"></a> 



<h1 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h1><h2 id="什么是管程"><a href="#什么是管程" class="headerlink" title="什么是管程"></a>什么是管程</h2><p>管程是操作系统中的概念，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发。管程是解决线程同步和互斥的方法。管程与信号量一样，可以解决所有的并发问题。管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程。管程解决了信号量使用不便的问题。</p>
<p>在管程模型里，共享变量和对共享变量的操作是被封装起来的。进入管程只有一个入口，并且在入口旁边还有一个等待队列。当多个线程同时试图进入管程内部时，只允许一个线程可以获取到互斥锁并进入，其他线程则在入口等待队列中等待。</p>
<p>管程里还引入了条件变量的概念，而且每个条件变量都对应有一个等待队列。假设有个线程T1要执行出队操作，出队操作在队列不为空时才能执行，队列不空这个前提条件就是管程里的条件变量。如果线程T1进入管程后发现队列是空的，就去条件变量对应的等待队列里面等待。线程T1进入条件变量的等待队列后，会释放互斥锁，允许其他线程进入管程。之后另外一个线程T2执行入队操作，入队操作执行成功，队列不为空。线程T1的条件变量已经满足，此时线程T2要通知T1，告诉它条件已经满足。当线程 T1 得到通知后，会从等待队列里面出来，但是出来之后不是马上执行，而是重新进入到入口等待队列里面，获取互斥锁后才能进入管程。</p>
<p>管程中的入口等待队列解决的是线程互斥问题，条件变量解决的是线程同步问题。</p>
<h2 id="Java中的管程"><a href="#Java中的管程" class="headerlink" title="Java中的管程"></a>Java中的管程</h2><p>在Java1.5之前，管程是Java提供的唯一并发原语。</p>
 

<p>Java有两种管程的实现方式：内置的synchronized和并发工具Lock。</p>
<p>内置管程：synchronized配合wait()、notify()、notifyAll()实现管程。synchronized负责线程互斥，被修饰的代码块会在编译期自动生成相关加锁和解锁的代码。wait()、notify()、notifyAll()负责线程同步。我们锁的是哪个对象，后续就应该调用该对象的wait()、notify()方法。另外还需要注意，wait()、notify()方法需要在synchronized同步块中调用。仅支持一个条件变量。</p>
<p>并发包管程：接口Lock、Condition配合实现管程，Lock负责线程互斥，Condition负责线程同步。需要开发人员进行加解锁操作。支持多个条件变量。</p>
<h3 id="内置管程与并发包管程的区别"><a href="#内置管程与并发包管程的区别" class="headerlink" title="内置管程与并发包管程的区别"></a>内置管程与并发包管程的区别</h3><p>在Java1.5之前已经有了synchronized管程，为什么在1.5要引入新的管程工具呢。因为新的管程工具引入了新特性，这些新特性解决了内置管程的一些问题：</p>
<ol>
<li><p>防死锁。死锁的产生需要满足4个条件，只要破坏其中的一个条件，就可以解决死锁。并发包管程破坏了<strong>不可抢占</strong>这个条件。<br><strong>响应中断</strong>。synchronized的问题是，在持有锁A的情况下，如果获取锁B失败，那么线程就进入阻塞状态，一旦发生死锁，就没有任何机会来唤醒阻塞的线程。Lock锁能够响应中断信号，也就是说当我们给阻塞的线程发送中断信号的时候，能够唤醒它，那它就有机会释放锁A。</p>
<p><strong>支持超时</strong>。如果线程在一段时间之内没有获取到锁，不是进入阻塞状态，而是返回一个错误，那这个线程也有机会释放曾经持有的锁。</p>
<p><strong>非阻塞获取锁</strong>。如果尝试获取锁失败，并不进入阻塞状态，而是直接返回，那这个线程也有机会释放曾经持有的锁。</p>
</li>
<li><p>支持公平锁。synchronized管程是非公平的，且不支持公平模式。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java SDK并发包实现的管程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockedQueue</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="comment">// 条件变量：队列不满  </span></span><br><span class="line">  <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">  <span class="comment">// 条件变量：队列不空  </span></span><br><span class="line">  <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入队</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">enq</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (队列已满)&#123;</span><br><span class="line">        <span class="comment">// 等待队列不满 </span></span><br><span class="line">        notFull.await();</span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="comment">// 省略入队操作...</span></span><br><span class="line">      <span class="comment">//入队后,通知可出队</span></span><br><span class="line">      notEmpty.signal();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 出队</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deq</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (队列已空)&#123;</span><br><span class="line">        <span class="comment">// 等待队列不空</span></span><br><span class="line">        notEmpty.await();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 省略出队操作...</span></span><br><span class="line">      <span class="comment">//出队后，通知可入队</span></span><br><span class="line">      notFull.signal();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java内置的管程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(条件不满足)&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        wait();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">      &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消耗资源</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">mothod2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//归还资源</span></span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异步转同步"><a href="#异步转同步" class="headerlink" title="异步转同步"></a>异步转同步</h2><p>在编程领域，异步的场景还是挺多的，比如TCP协议本身就是异步的，但我们在使用RPC调用时，大多数调用过程是同步的。这个TCP协议异步转为RPC同步的过程由RPC框架帮助我们完成。下面是Dubbo的异步转同步的实现方式。使用Lock和Condition实现管程，来达到异步转同步的目的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建锁与条件变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition done = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方通过该方法等待结果</span></span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> timeout)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!isDone()) &#123;</span><br><span class="line">            done.await(timeout);</span><br><span class="line">            <span class="keyword">long</span> cur=System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (isDone() || cur-start &gt; timeout)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isDone()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnFromResponse();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC结果是否已经返回</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> response != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC结果返回时调用该方法，唤醒同步过程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReceived</span><span class="params">(Response res)</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response = res;</span><br><span class="line">        <span class="keyword">if</span> (done != <span class="keyword">null</span>) &#123;</span><br><span class="line">            done.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><h2 id="什么是信号量"><a href="#什么是信号量" class="headerlink" title="什么是信号量"></a>什么是信号量</h2><p>信号量（Semaphore）是由大名鼎鼎的计算机科学家迪杰斯特拉（Dijkstra）于1965年提出，在这之后的 15 年，信号量一直都是并发编程领域的终结者，直到1980年管程被提出来，我们才有了第二选择。</p>
<p>信号量模型还是很简单的，可以简单概括为：一个计数器，一个等待队列，三个方法。这三个方法分别是：init()、down()和up()。其中down()、up()这两个操作历史上最早称为P操作和V操作。</p>
<ul>
<li>init()：设置计数器的初始值。</li>
<li>down()：计数器减 1。如果此时计数器的值小于0，则当前线程将被阻塞，否则当前线程可以继续执行</li>
<li>up()：计数器加1。如果此时计数器的值小于或者等于0，说明有等待的线程，唤醒等待队列中的一个线程。</li>
</ul>
<h2 id="信号量与管程的区别"><a href="#信号量与管程的区别" class="headerlink" title="信号量与管程的区别"></a>信号量与管程的区别</h2><ol>
<li>临界区线程数量不同：信号量允许多个线程进入临界区，管程只允许一个。</li>
<li>唤醒线程数量不同：信号量只能唤醒阻塞中的一个线程，管程可以唤醒多个线程去争抢锁。</li>
<li>是否有条件等待：信号量没有条件变量的概念，管程有条件表里。</li>
</ol>
<p>Semaphore用来控制并发数量，可用作限流器。当数量为1时，Semaphore就退化为普通的锁。Semaphore不可重入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        semaphore.acquire();</span><br><span class="line">        <span class="comment">//do something，控制该资源访问并发数为10</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    semaphore.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="CountDownLatch和CyclicBarrier"><a href="#CountDownLatch和CyclicBarrier" class="headerlink" title="CountDownLatch和CyclicBarrier"></a>CountDownLatch和CyclicBarrier</h1><p>CountDownLatch是一个计数器闭锁，通过它可以完成线程等待的功能，即一个或多个线程一直等待，直到其他线程完成特定操作。CountDownLatch描述的是等待线程与被等待线程之间的关系，这两种线程属于不同任务类型。</p>
<p>CyclicBarrier可以理解为循环使用的栅栏，当有特定数量的线程到达栅栏处时，该栅栏就会放行这些线程。放行后栅栏自动重置，拦截下一批特定数量的线程。CyclicBarrier主要是实现了多个线程之间相互等待，描述多个线程内部相互等待的关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CountDownLatch</span></span><br><span class="line"><span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    latch.countDown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        latch.await();<span class="comment">//需等待线程1完成之后再继续</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CyclicBarrier</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//因为barrier的值为2，那么就会两个线程为一组通过栅栏</span></span><br><span class="line">                    barrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CyclicBarrier经常被拿来与CountDownLatch比较。</p>
<p>他们主要有两点不同：</p>
<ol>
<li>CyclicBarrier会自动重置计数器，可循环使用；CountDownLatch是一次性的。</li>
<li>CyclicBarrier描述的是同种任务线程之间的关系；CountDownLatch描述的是两种不同任务线程之间的关系。</li>
</ol>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>信号量</tag>
        <tag>管程</tag>
      </tags>
  </entry>
  <entry>
    <title>Reference</title>
    <url>/2019/12/06/Reference/</url>
    <content><![CDATA[<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>Reference类有个静态的代码块，在这里面会运行一个后台线程，用于将被回收的对象放入引用队列。将对象放入引用队列便于后续进一步的清理操作。</p>
<a id="more"></a> 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    ReferenceHandler(ThreadGroup g, String name) &#123;</span><br><span class="line">        <span class="keyword">super</span>(g, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">            Reference r;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pending != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    r = pending;</span><br><span class="line">                    Reference rn = r.next;</span><br><span class="line">                    pending = (rn == r) ? <span class="keyword">null</span> : rn;</span><br><span class="line">                    r.next = r;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException x) &#123; &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Fast path for cleaners</span></span><br><span class="line">            <span class="keyword">if</span> (r <span class="keyword">instanceof</span> Cleaner) &#123;</span><br><span class="line">                ((Cleaner)r).clean();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把将要回收的对象放入引用队列</span></span><br><span class="line">            ReferenceQueue q = r.queue;</span><br><span class="line">            <span class="keyword">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class="line">    <span class="keyword">for</span> (ThreadGroup tgn = tg;</span><br><span class="line">         tgn != <span class="keyword">null</span>;</span><br><span class="line">         tg = tgn, tgn = tg.getParent());</span><br><span class="line">    Thread handler = <span class="keyword">new</span> ReferenceHandler(tg, <span class="string">"Reference Handler"</span>);</span><br><span class="line">    handler.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">    handler.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    handler.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java知识</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>GC</title>
    <url>/2019/12/05/GC/</url>
    <content><![CDATA[<h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><a id="more"></a> 

<h2 id="回收谁"><a href="#回收谁" class="headerlink" title="回收谁"></a>回收谁</h2><p>堆</p>
<h2 id="如何判断是否要回收"><a href="#如何判断是否要回收" class="headerlink" title="如何判断是否要回收"></a>如何判断是否要回收</h2><p>从GC root出发，运用可达性分析，若访问不到的对象需要被回收。</p>
<p>GC root：</p>
<ol>
<li><p>本地变量引用的对象</p>
</li>
<li><p>静态变量引用的对象</p>
</li>
<li><p>常量引用的对象</p>
</li>
<li><p>Native方法引用的对象</p>
</li>
</ol>
<p>对于弱引用，GC不会当它为引用，会进行回收</p>
<p>新生代使用复制算法</p>
<p>分为一个Eden区和两个Survivor区，大小为8:1:1。两个Survivor分别为From Survivor和To Survivor，每次GC过后，From和To会交换。新对象都出生在Eden区。</p>
<p>Partial GC：并不收集整个GC堆的模式</p>
<ul>
<li>Young GC：只收集young gen的GC</li>
<li>Old GC：只收集old gen的GC。只有CMS的concurrent collection是这个模式</li>
<li>Mixed GC：收集整个young gen以及部分old gen的GC。只有G1有这个模式</li>
</ul>
<p>Full GC：收集整个堆，包括young gen、old gen、perm gen（如果存在的话）等所有部分的模式。</p>
<p>CMS：</p>
<p>初始标记（STW）单线程</p>
<p>并发标记</p>
<p>重新标记（STW）多线程</p>
<p>清除</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发</title>
    <url>/2019/12/04/%E9%AB%98%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1 id="高并发设计"><a href="#高并发设计" class="headerlink" title="高并发设计"></a>高并发设计</h1><a id="more"></a> 

<p>高并发设计归纳起来有三种方法：</p>
<ol>
<li><p>Scale-out（横向扩展）。</p>
<p>Scale-out指的是将多个机器组成集群。该方案较复杂，需要管理集群。</p>
<p>Scale-up指的是升级单台机器的配置。该方案足够简单，用到业务发展初期。</p>
</li>
<li><p>缓存。CPU内存寻址在ns级别，从网卡上读取数据在us级别，磁盘的寻道时间在ms级别。</p>
</li>
<li><p>异步。调用方不需要等待结果就可以返回以执行其他的逻辑。</p>
</li>
</ol>
<p>架构分层设计</p>
<ol>
<li>不同的人专注做某一层次的事；</li>
<li>分层可以做到很好的复用；</li>
<li>分层可以更好地横向扩展。</li>
</ol>
<p>如何做：可参考《阿里巴巴Java开发手册》</p>
<p>高并发系统有三大目标：<strong>高性能</strong>，<strong>高可用</strong>，<strong>可扩展</strong>。</p>
<h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><p>性能优化：</p>
<ol>
<li>问题导向。不能为了技术而技术，技术服务于业务；</li>
<li>二八原则。抓住主要矛盾去解决。</li>
<li>优化需要用数据说话。</li>
</ol>
<p>阿姆达尔定律<code>加速比=1/(1-p+p/s)</code>，其中p表示任务并行部分占比，s表示并行进程数。从定律看，要想提高加速比，可以通过<strong>增加进程数</strong>、<strong>增加任务并行占比</strong>、<strong>缩短整体任务时间</strong>。</p>
<h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p>分为系统设计和系统运维两个部分。提高系统的可用性有时候会牺牲系统性能。</p>
<h4 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h4><p>“Design for failure”，在有着大量机器的集群中，是一定会出现单台机器故障的情况。针对这个特点，我们可以使用</p>
<ol>
<li><p>failover。在集群情况下将请求转移出去。</p>
</li>
<li><p>超时控制</p>
</li>
<li><p>限流：在极端情况下，损害部分用户体验来保障另一部分用户；</p>
</li>
<li><p>降级：保证核心服务稳定而牺牲非核心服务</p>
</li>
</ol>
<h4 id="系统运维"><a href="#系统运维" class="headerlink" title="系统运维"></a>系统运维</h4><ol>
<li>灰度发布。故障一般发生在系统变更时，做好灰度发布。</li>
<li>故障演练。</li>
</ol>
<h3 id="可扩展"><a href="#可扩展" class="headerlink" title="可扩展"></a>可扩展</h3><p>能通过加机器解决问题的架构是好架构。</p>
<p>机器不是简单地加上去就可以的，机器加上去后，系统瓶颈可能会转移到其他地方。</p>
<p>将系统进行<strong>拆分</strong>，可以清楚地知道目前系统瓶颈在什么地方，这样可以针对性的扩展。</p>
<h4 id="存储层拆分"><a href="#存储层拆分" class="headerlink" title="存储层拆分"></a>存储层拆分</h4><p>按照业务进行垂直拆分。</p>
<p>按照数据特征进行水平拆分。</p>
<h4 id="业务层拆分"><a href="#业务层拆分" class="headerlink" title="业务层拆分"></a>业务层拆分</h4><p>相同的业务拆到单独的业务池：扩容不影响其他业务</p>
<p>每个业务有单独的存储资源：扩容不影响其他业务</p>
<p>区分核心和非核心的业务接口：便于优先扩容核心业务。</p>
<h2 id="池化技术"><a href="#池化技术" class="headerlink" title="池化技术"></a>池化技术</h2><p>JDK原生线程池的特点决定了它比较适合CPU密集型任务。任务数量达到core之后，任务会进队列。</p>
<p>Tomcat的线程池比较适合IO密集型任务。任务数量达到core，会继续创建新线程。</p>
<h3 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a>数据库读写分离</h3><p>基于性能的考虑，在进行写操作时，写完主库就会返回，然后从库会异步更新。</p>
<p>这样会产生读写延迟的问题，写主库之后立马读从库，可能读不到新写入的值。</p>
<ol>
<li>数据冗余。写完主库后，可以将具体内容以MQ的形式发出去，就暂时不需要去读从库了。</li>
<li>使用缓存。但又会带来数据一致性的问题。</li>
<li>查询主库。可以全部请求全部强制走主库，也可以部分请求走主库。比如写操作结束后，可以将刚写的key放入缓存，设置较小的过期时间。读操作时，如果key在缓存中存在，说明可能存在延迟，需要从主库读。如果key不在缓存中，则走从库。</li>
</ol>
<h3 id="数据库分库分表"><a href="#数据库分库分表" class="headerlink" title="数据库分库分表"></a>数据库分库分表</h3><p>按照业务进行垂直拆分。</p>
<p>按照数据特征进行水平拆分：引入分区键，即需要先确认去哪张表里查询。</p>
<p>如果我们要查询的字段不是分区键该怎么办，有以下两个办法：</p>
<ol>
<li>建立以该字段为分区键的拆分存储，这会极大增加存储成本；</li>
<li>建立该字段与分区键的映射表，由于该表字段较少，可以节省存储成本。</li>
</ol>
<h4 id="迁移方案"><a href="#迁移方案" class="headerlink" title="迁移方案"></a>迁移方案</h4><ol>
<li>将新的库配置为源库的从库，那么从库里的数据会慢慢追上源库；</li>
<li>改造业务代码，写操作变为双写源库和新库，读操作还是在源库上。这里要注意的是，改为双写之前需要停止从库与源库之间的数据同步；</li>
<li>校验数据。对比源库和新库里的数据是否一致，是否有漏数据的情况。</li>
<li>灰度切读流量，将流量由源库切到从库。如果切的过程中有问题，可以安全切回至源库，因为这时两个库的数据是一样的。</li>
</ol>
<h2 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h2><h3 id="静态缓存"><a href="#静态缓存" class="headerlink" title="静态缓存"></a>静态缓存</h3><p>可放在CDN、Nginx服务器上</p>
<h3 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h3><p>如Redis</p>
<h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><p>遇到极端热点数据时，可采用本地缓存。如Guava Cache。</p>
<p>如何更新各个服务器上的缓存：</p>
<ol>
<li>使用配置中心</li>
<li>等待缓存过期之后触发加载</li>
</ol>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><ol>
<li>回种空值是一种最常见的解决思路，实现起来也最简单，如果评估空值缓存占据的缓存空间可以接受，那么可以优先使用这种方案；</li>
<li>布隆过滤器会引入一个新的组件，也会引入一些开发上的复杂度和运维上的成本。所以只有在存在海量查询数据库中，不存在数据的请求时才会使用，在使用时也要关注布隆过滤器对内存空间的消耗；</li>
<li>对于极热点缓存数据穿透造成的“狗桩效应”，可以通过设置分布式锁或者后台线程定时加载的方式来解决。</li>
</ol>
<h2 id="Redis高可用"><a href="#Redis高可用" class="headerlink" title="Redis高可用"></a>Redis高可用</h2><p>redis扩展主要两方面。主备方案以及集群方案。</p>
<ul>
<li><p>主备的话可以用redis的sentinel（哨兵）。主要解决redis主节点故障后的自动切换。哨兵负责持续监控主从节点的健康，当主节点挂掉时，自动选择一个最优的从节点切换为主节点。</p>
</li>
<li><p>Redis集群主要涉及数据分片。分片主要有三种方案：客户端分片，中间代理分片，服务端分片。</p>
<p>客户端分片方案不是在多个语言之间复用，而且升级客户端SDK需要推到业务去升级。</p>
<p>中间代理方案可以做到跨语言的使用，该方案有豌豆荚的Codis、Twitter的Twemproxy、FB的Mcrouter等。</p>
<p>服务端分片是Redis3.0推出的官方集群解决方案，在该方案中，redis中共有16384个slot，<code>slot = CRC16(key) % 16384</code>，每个实例负责其中的几个solt。主流方案有codis和官方的cluster。 </p>
</li>
</ul>
<h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><h4 id="发号器"><a href="#发号器" class="headerlink" title="发号器"></a>发号器</h4><p>leaf-segment：基于数据库，可通过id反推出主键数量。</p>
<p>leaf-snowflake：无依赖，时间戳+机器号+递增号</p>
<h2 id="缓存读写策略"><a href="#缓存读写策略" class="headerlink" title="缓存读写策略"></a>缓存读写策略</h2><ol>
<li><p>Cache Aside是我们在使用分布式缓存时最常用的策略。 </p>
<p>对于写操作，先写数据库，再删除缓存。</p>
<p>对于读操作，缓存命中则返回，未命中需读数据库然后回种缓存。</p>
<p>以上是比较标准的Cache Aside模式，实际使用中都会针对性的修改一下。如果采用标准的Cache Aside模式，会出现并发读写导致数据不一致的问题。</p>
</li>
<li><p>Read/Write Through和Write Back策略需要缓存组件的支持，所以比较适合本地缓存，如Guava Cache。</p>
</li>
<li><p>Write Back策略是计算机体系结构中的策略，不过写入策略中的只写缓存，异步写入后端存储的策略倒是有很多的应用场景。 </p>
</li>
</ol>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>高性能</tag>
        <tag>高可用</tag>
        <tag>可扩展</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP</title>
    <url>/2019/12/01/HTTP/</url>
    <content><![CDATA[<p>Http1.1虽然有着pipeline，但响应和请求还是按顺序出现的。如果前面的响应阻塞了，后面的响应也会跟着阻塞。</p>
 <a id="more"></a> 

<p>Http2引入了多路复用，每个响应带有stream id，一个连接里可以穿插着多个stream id，可以不按照顺序出现。Http流量控制可以对单个stream进行。而TCP的流控只能对一个连接进行控制，粒度没有TCP的细。</p>
]]></content>
      <categories>
        <category>网络协议</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>配置中心</title>
    <url>/2019/11/25/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    <content><![CDATA[<h1 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h1><a id="more"></a> 

<h2 id="基于Git的配置中心"><a href="#基于Git的配置中心" class="headerlink" title="基于Git的配置中心"></a>基于Git的配置中心</h2><p>在Spring Cloud中，配置中心是基于Git实现的。config-server是配置服务器，会将配置的相关操作以http的形式暴露出去。client是应用服务器，对于config-server来说，它是client。client在启动时会从config-server加载数据。</p>
<embed src="Config_Git.svg" width="100%" type="image/svg+xml">
图1是较为简单的配置中心，这个配置中心有一个问题：client端的配置不能动态更新。因为client只会在启动时加载配置，后续如果修改了git中的内容，client中的内容不会变。如果期望client获取最新数据，需要按如下步骤：

<ol>
<li>使用git push修改配置；</li>
<li>手动调用client的/bus/refresh接口主动更新配置；</li>
<li>client请求server获取配置；</li>
<li>server请求git获取配置。</li>
</ol>
<p>图2是改进版的配置中心，能够做到client端配置的动态更新。</p>
<ol>
<li>使用git push修改配置；</li>
<li>git服务器发现有push事件，于是调用server的/bus/refresh接口（这项功能需要依赖git hook）；</li>
<li>server将更新消息发送给MQ；</li>
<li>client监听MQ，发现有更新消息；</li>
<li>client请求server获取配置；</li>
<li>server请求git获取配置。</li>
</ol>
<h2 id="基于Zookeeper的配置中心"><a href="#基于Zookeeper的配置中心" class="headerlink" title="基于Zookeeper的配置中心"></a>基于Zookeeper的配置中心</h2><p>zookeeper可以理解为<strong>文件系统+监听机制</strong>，client监听zk上的节点，若节点数据发生变化，会通知client更新配置。</p>
<h2 id="基于Http长轮询的配置中心"><a href="#基于Http长轮询的配置中心" class="headerlink" title="基于Http长轮询的配置中心"></a>基于Http长轮询的配置中心</h2><p>client使用http长轮询连接上server，若配置有变化，可通过http形式推送至client。</p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>限流算法</title>
    <url>/2019/11/23/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h1><a id="more"></a> 

<h3 id="固定窗口算法"><a href="#固定窗口算法" class="headerlink" title="固定窗口算法"></a>固定窗口算法</h3><p>基于固定时间窗口的限流算法是非常简单的。首先需要选定一个时间起点，之后每次接口请求到来都累加计数器。如果在当前时间窗口内，累加访问次数超过限流值，则限流熔断拒绝接口请求。当进入下一个时间窗口之后，计数器清零重新计数。</p>
<p>这种算法的缺点在于：限流策略过于粗略，无法应对两个时间窗口临界时间内的突发流量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//固定窗口示例</span></span><br><span class="line"><span class="comment">//延时计算，在访问时再计算</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> <span class="keyword">throws</span> InternalErrorException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> updatedCount = currentCount.incrementAndGet();</span><br><span class="line">    <span class="keyword">if</span> (updatedCount &lt;= limit) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lock.tryLock(TRY_LOCK_TIMEOUT, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (stopwatch.elapsed(TimeUnit.MILLISECONDS) &gt; TimeUnit.SECONDS.toMillis(<span class="number">1</span>)) &#123;</span><br><span class="line">                    currentCount.set(<span class="number">0</span>);</span><br><span class="line">                    stopwatch.reset();</span><br><span class="line">                &#125;</span><br><span class="line">                updatedCount = currentCount.incrementAndGet();</span><br><span class="line">                <span class="keyword">return</span> updatedCount &lt;= limit;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalErrorException(<span class="string">"tryAcquire() wait lock too long:"</span> + TRY_LOCK_TIMEOUT + <span class="string">"ms"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalErrorException(<span class="string">"tryAcquire() is interrupted by lock-time-out."</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h3><p>滑动时间窗口算法是对固定时间窗口算法的一种改进，流量经过滑动时间窗口算法整形之后，可以保证任意时间窗口内，都不会超过最大允许的限流值。对比固定时间窗口限流算法，滑动时间窗口限流算法的时间窗口是持续滑动的，并且除了需要一个计数器来记录时间窗口内接口请求次数之外，还需要记录在时间窗口内每个接口请求到达的时间点，对内存的占用会比较多。 </p>
<p>实现上可以基于循环队列实现。</p>
<h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p>上面介绍了两种基于时间窗口的限流算法。这两种限流算法都无法应对细时间粒度的突发流量，对流量的整形效果在细时间粒度上不够平滑。</p>
<p>令牌桶算法试一种更滑平滑的限流算法。令牌桶算法大致思路：</p>
<ol>
<li>接口限制 t 秒内最大访问次数为 n，则每隔 t/n 秒会放一个 token 到桶中；</li>
<li>桶中最多可以存放 b 个 token，如果 token 到达时令牌桶已经满了，那么这个 token 会被丢弃；</li>
<li>接口请求会先从令牌桶中取 token，拿到 token 则处理接口请求，拿不到 token 则执行限流。</li>
</ol>
<h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>漏桶算法对流量的整形效果更加好，流量更加平滑，任何突发流量都会被限流。漏桶算法对于取令牌的频率也有限制，要按照 t/n 固定的速度来取令牌。</p>
<p>令牌桶和漏桶算法比较适合阻塞式限流，比如一些后台 job 类的限流，超过了最大访问频率之后，请求并不会被拒绝，而是会被阻塞到有令牌后再继续执行。</p>
<p>基于时间窗口的算法比较适合否决式限流，比如线上接口这种对响应时间比较敏感的限流场景。</p>
<h3 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h3><p>基于Redis+Lua实现集群限流。不需要加锁，Redis+Lua会以原子的方式运行。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> limit = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> current = <span class="built_in">tonumber</span>(redis.call(<span class="string">'incr'</span>, key))</span><br><span class="line"><span class="keyword">if</span> current &gt; limit <span class="keyword">then</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">elseif</span> current == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">   redis.call(<span class="string">'expire'</span>, key, <span class="string">'1'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4MTY5NTk4Ng==&amp;mid=2247488993&amp;idx=1&amp;sn=4b9d5deedd0e626c456744f04b499bbb&amp;source=41#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI4MTY5NTk4Ng==&amp;mid=2247488993&amp;idx=1&amp;sn=4b9d5deedd0e626c456744f04b499bbb&amp;source=41#wechat_redirect</a> </p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>限流</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap</title>
    <url>/2019/11/13/HashMap/</url>
    <content><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><a id="more"></a>

<p>equals()相同的两个对象，hashCode()一定要相同。</p>
<p>equals()不同的两个对象，hashCode()可以相同也可以不同。</p>
<p>Object的hashCode()默认实现是将Object的地址转换为一个int变量。</p>
<p>Object的equals()默认实现是比较两个对象是否指的是一个对象。</p>
<p>比较两个对象时，可以先粗略地用hashCode进行比较，若不一致，则返回结果；若一致，则用==或者equals继续比较。</p>
<h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><ol>
<li><p>对key的原始hash值进行处理，在低位bit上加入高位bit信息，目的是减少小容量map的冲突。</p>
</li>
<li><p>根据table的长度，对处理后的hash值截取低位bit。</p>
</li>
<li><p>若该table槽为null，新增节点放入table；若该table槽不为null，则表明有冲突，HashMap采用拉链法解决冲突。</p>
</li>
</ol>
<h2 id="size"><a href="#size" class="headerlink" title="size"></a>size</h2><p>HashMap有个成员变量size，求size的时间复杂度是O(1)。HashMap在put时size+1，在remove时size-1。</p>
<h2 id="ConcurrentModificationException"><a href="#ConcurrentModificationException" class="headerlink" title="ConcurrentModificationException"></a>ConcurrentModificationException</h2><p>在遍历HashMap的过程中，如果进行了写操作，例如put, remove, clear等。HashMap会报并发修改错误。</p>
<p>这个是通过modCount变量实现的。在每个写操作中，modCount都会+1，表明经过了一次修改。在遍历开始时，当前的modCount会被记录下来记作m，每次遍历到一个元素时会检查当前modCount是否等于m，不相等说明发生了并发修改。</p>
<h2 id="Java-7"><a href="#Java-7" class="headerlink" title="Java 7"></a>Java 7</h2><h3 id="非线程安全"><a href="#非线程安全" class="headerlink" title="非线程安全"></a>非线程安全</h3><p>大家都知道HashMap是非线程安全的，在多线程情况下使用会出现问题，但具体会出现什么问题呢。下面我们来看一下多线程下，HashMap会出现的两个比较典型的问题：死循环和数据丢失。其实这两个问题并不是全部，由于多线程下，HashMap在各个地方都会出现问题，问题多多，所以这里就拿这两个例子来说明。</p>
<h4 id="链表成环"><a href="#链表成环" class="headerlink" title="链表成环"></a>链表成环</h4><p>当两个线程都在进程扩容时，容易发生链表成环。线程A运行过语句<code>Entry&lt;K,V&gt; next = e.next;</code>之后就挂起。此时<strong>e和next在一个链表上且顺序相反</strong>。CPU开始运行线程B，线程B完成扩容后将CPU让出（图1）。图2\图3\图4去掉了与线程B相关的东西，专注在线程A的行为上。它们演示了经过3个循环，链表最终成环。</p>
<h4 id="数据丢失"><a href="#数据丢失" class="headerlink" title="数据丢失"></a>数据丢失</h4><p>我们调换一下原始节点在链表中的顺序，使得扩容后<strong>e和next分布在两个链表上</strong>，这样的话，e之前的节点都会丢失。</p>
<h2 id="Java-8的改进"><a href="#Java-8的改进" class="headerlink" title="Java 8的改进"></a>Java 8的改进</h2><h3 id="链表优化为树"><a href="#链表优化为树" class="headerlink" title="链表优化为树"></a>链表优化为树</h3><p>java8对table[]后面的链表进行了优化，当链表中节点个数≥8的时候，链表就会变为红黑树。当节点个数小于等于6的时候，红黑树又会变为链表。</p>
<ul>
<li>为什么是8：当节点个数小于8的时候，链表遍历的平均时间复杂度(n/2，n=8时，需遍历4个节点)高于红黑树(O(logn)，n=8时，需遍历3个节点）。</li>
<li>为什么是6：为防止节点个数频繁变化导致的链表与红黑树相互转化，该值不能设置为8，设置为6比较合适。</li>
</ul>
<h3 id="对原始hash值的处理"><a href="#对原始hash值的处理" class="headerlink" title="对原始hash值的处理"></a>对原始hash值的处理</h3><p>在java8中，对原始hash值的处理相对简单很多。较为简单的处理会导致冲突加剧，即截取低位bit后的节点会分布不均匀。那么较为严重的冲突所带来的查找效率低下可以被红黑树所缓解一些。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java7</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//java8</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="rehash逻辑变化"><a href="#rehash逻辑变化" class="headerlink" title="rehash逻辑变化"></a>rehash逻辑变化</h3><p>在java7中，扩容时rehash，采用<code>hash &amp; (length-1)</code>计算出新的数组下标，该值是绝对值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java7扩容rehash</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在java8中，采用<code>hash &amp; oldCap</code>计算出新的数组下标的相对值。rehash其实就是在原有hash基础上往高位再多取1bit。该bit位为0，rehash后数组下标不变；该bit位为1，rehash后数组下标需要加上原数组的大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java8扩容rehash（链表情况下）</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    next = e.next;</span><br><span class="line">    <span class="comment">//rehash后节点所在的数组下标不变</span></span><br><span class="line">    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">            loHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            loTail.next = e;</span><br><span class="line">        loTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//rehash后节点所在的数组下标需要加上原数组长度</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">            hiHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hiTail.next = e;</span><br><span class="line">        hiTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">    loTail.next = <span class="keyword">null</span>;</span><br><span class="line">    newTab[j] = loHead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">    hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">    newTab[j + oldCap] = hiHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩容时倒序优化为顺序"><a href="#扩容时倒序优化为顺序" class="headerlink" title="扩容时倒序优化为顺序"></a>扩容时倒序优化为顺序</h3><p>在多线程对HashMap进行扩容时，链表rehash到新的数组后，顺序与原链表相反。这样子会造成链表成环，get()元素的时候进入死循环。HashMap是非线程安全的，虽然它的实现没有问题，是使用者错误使用了HashMap，但作者还是对这个点进行了优化，这个优化减少了错误使用HashMap时的问题。   </p>
<embed src="java7_HashMap.svg" width="100%" type="image/svg+xml">

<embed src="java7_HashMap_loop.svg" width="100%" type="image/svg+xml">
<embed src="java7_HashMap_miss.svg" width="100%" type="image/svg+xml">
<embed src="java8_HashMap.svg" width="100%" type="image/svg+xml">
<embed src="扩容.svg" width="100%" type="image/svg+xml">
]]></content>
      <categories>
        <category>Java知识</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap</title>
    <url>/2019/11/12/ConcurrentHashMap/</url>
    <content><![CDATA[<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><h2 id="java7"><a href="#java7" class="headerlink" title="java7"></a>java7</h2><p>java7中的ConcurrentHashMap主要使用分段锁保证线程安全。只能有一个线程对segment中的table[]进行写操作，读操作不加锁。</p>
<a id="more"></a>

<embed src="java7_ConcurrentHashMap.svg" width="100%" type="image/svg+xml">
### put

<ol>
<li>对原始hash值进行处理，目的是减少冲突</li>
<li>取处理之后的hash值最高几位当做segment数组下标</li>
<li>用CAS对segment进行初始化</li>
<li>使用非阻塞的方式对segment尝试加锁，成功加锁则可以往里写；加锁失败则等待释放锁</li>
<li>插入链表头部</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap的put方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);<span class="comment">//处理原始hash值</span></span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;<span class="comment">//计算segment的数组下标</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject</span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>)</span><br><span class="line">        s = ensureSegment(j);<span class="comment">//初始化segment</span></span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//segment的put方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">    scanAndLockForPut(key, hash, value);<span class="comment">//写操作前对segment加锁</span></span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="comment">//需要遍历链表确认是否有相同的key</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若无相同的key，则将新节点插入链表头部</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回相应数组下标的segment，若不存在则新建</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    <span class="comment">//检查segment是否已存在</span></span><br><span class="line">    <span class="comment">//后续还会对这一点进行多次检查。在每次new之前都会检查一遍，目的是防止资源浪费</span></span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>];<span class="comment">//segment[0]在最开始已经初始化</span></span><br><span class="line">        <span class="keyword">int</span> cap = proto.table.length;</span><br><span class="line">        <span class="keyword">float</span> lf = proto.loadFactor;</span><br><span class="line">        <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">        <span class="comment">//再次检查</span></span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">            == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            <span class="comment">//while搭配CAS使用，只允许一个线程新建segment</span></span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                   == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//尝试加锁失败，则等待释放锁，在等待时还可以提前先把Node创建起来</span></span><br><span class="line"><span class="comment">//用自旋的方式等待，自旋一定次数后，若还没释放，则挂起线程等待</span></span><br><span class="line"><span class="comment">//若自旋时发现链表头结点发生变化，则重新遍历链表并重新自旋????????为什么这么设计</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>遍历segment，把每个segment中的数量累加起来。这样的遍历做两次，对比这两次的modCount结果是否一致（任何一个写操作都会使得modCount变量+1，modCount只增不减，类似于版本号）。时间复杂度为O(n)，n为segment的数量。</p>
<ul>
<li>若一致，说明没有并发操作，这个size准确。</li>
<li>若不一致，说明有并发写操作，需要做第三次的遍历。第三次的modCount结果若与第二次相同，则返回size。若不相同，说明有并发，此时会获取全部segment的锁，再计算size。这时是进行不了任何写操作的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">    <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//循环3遍，都有并发干扰计算结果，此时需要锁全部segment</span></span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock();</span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0L</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//遍历全部segment，累加每个segment的size</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//modCount不变，说明无并发干扰，可以返回结果</span></span><br><span class="line">            <span class="keyword">if</span> (sum == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="java8"><a href="#java8" class="headerlink" title="java8"></a>java8</h2><p>java8中的ConcurrentHashMap去掉了分段锁，采用了粒度更细的锁。写操作对单个链表或树进行加锁。</p>
<embed src="java8_ConcurrentHashMap.svg" width="100%" type="image/svg+xml">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());<span class="comment">//对原始hash值进行处理</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//如果table数组中该槽为空，则使用CAS新增</span></span><br><span class="line">        <span class="comment">//新增成功则返回；新增失败需要重新进入循环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果处于扩容状态，该线程会帮忙进行扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="comment">//已经存在链表或树，需要锁住头节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                              value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="size-1"><a href="#size-1" class="headerlink" title="size"></a>size</h3><p>java8推荐使用mappingCount()方法，用于代替size()。mappingCount()返回long型，范围比size()的int型要大。</p>
<p>如果ConcurrentHashMap在非并发环境下进行写操作，那么元素的计数结果都会体现在baseCount成员变量上。如果出现并发，那么就会将计数结果更新到CounterCell[]数组，每个并发线程都在数组里拥有一个自己的槽。所以整个Map的元素数量就是baseCount+CounterCell[]数组中的数。</p>
<p>需要注意的是，mappingCount()和size()计算出来的是近似数，可能在过程中，还有线程在累加CounterCell[]，这个结果未能反映到最终结果中。</p>
<p>而java7中ConcurrentHashMap的size()求得的结果就不是近似值，是准确值。因为它能保证在方法的“调用时刻”和“返回时刻”之间，无写操作进入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">mappingCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0L</span>) ? <span class="number">0L</span> : n; <span class="comment">// ignore transient negative values</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与LongAdder原理类似</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于java8的ConcurrentHashMap的size()计算与LongAdder原理类似，这里就简单介绍一下LongAdder。</p>
<p>LongAdder是java8并发包中新引入的原子类，解决的是AtomicLong在高并发情况下的性能问题。原子类中有个value的成员变量，对value的CAS操作是一个自旋锁，在冲突严重的情况下，该锁会运行较长时间。</p>
<p>LongAdder的基本思路就是<strong>分散热点</strong>，将value值分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的long值，只要将各个槽中的变量值累加返回。 </p>
<h1 id="ConcurrentHashMap扩容"><a href="#ConcurrentHashMap扩容" class="headerlink" title="ConcurrentHashMap扩容"></a>ConcurrentHashMap扩容</h1><embed src="java8_ConcurrentHashMap扩容.svg" width="100%" type="image/svg+xml">
## java7

<p>segment数组的大小在初始化后就不会改变，默认为16。只有segment里面的table可以扩容，table扩容时，会获取ReentrantLock，后续的写操作会阻塞。</p>
<p>接下来的扩容与HashMap类似。</p>
<h2 id="java8-1"><a href="#java8-1" class="headerlink" title="java8"></a>java8</h2><p>扩容时，会新建一个容量为原来2倍的nextTable数组，这个数组是多个线程共享的。</p>
<ol>
<li>A、B线程同时对table[0]进行转移，由于synchronized锁的保障，A线程在转移的同时，B线程会被synchronized锁阻塞 。</li>
<li>table[0]转移结束后，原来table[0]的地方会变为ForwardingNode(fwd，转发节点)，fwd用于表明该节点已处理完毕。对于读操作，fwd还能指引到新数组进行读操作。</li>
<li>A线程开始处理table[1]。</li>
<li>A线程处理完毕，将table[1]改为fwd。</li>
<li>B线程准备处理table[1]，发现该节点为fwd，表明已经被处理过，跳过该节点。</li>
<li>A线程处理table[2]，发现是null，于是可以直接将fwd放入table[2]。</li>
</ol>
]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>BigDecimal</title>
    <url>/2019/11/06/BigDecimal/</url>
    <content><![CDATA[<h1 id="BigDecimal和BigInteger"><a href="#BigDecimal和BigInteger" class="headerlink" title="BigDecimal和BigInteger"></a>BigDecimal和BigInteger</h1><p>在商业上进行计算的时候，如果使用float、double型变量，会造成丢失精度的问题。这种情况下应该使用BigDecimal。</p>
<a id="more"></a> 

<h2 id="double"><a href="#double" class="headerlink" title="double"></a>double</h2><p>以双精度为例，单精度原理相同。</p>
<p>64bit的双精度浮点数分为以下三个部分：</p>
<ul>
<li><p>sign bit(符号): 用来表示正负号。</p>
</li>
<li><p>exponent(指数): 用来表示次方数。</p>
</li>
<li><p>mantissa(尾数): 用来表示精确度。</p>
</li>
</ul>
<p>一个双精度浮点数的数值为：sign × 2^(exponent - 0x3ff) × 1.mantissa</p>
<p>mantissa从左到右第N位表示2^-N，从大到小依次为0.5、0.25、0.125….</p>
<p>浮点数的小数部分由2^-N组成，2^-N精度有限，并不能表示所有的小数。</p>
<h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><p>BigDecimal采用小数变整数的方法解决精度问题。既然小数不能精确表示，那么就将小数点去掉，变为整数。整数可以用二进制精确表示。整数由intCompact体现，被丢掉的小数点由scale体现。</p>
 <img src="/2019/11/06/BigDecimal/BigDecimal.png" title="BigDecimal"> 



<h2 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h2><p>如果我们要使用的数超过了long的值范围，可以使用BigInteger类。BigInteger里有int数组，它所表示的数就是由数组中的int连接起来。</p>
]]></content>
      <categories>
        <category>Java知识</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Pigeon</title>
    <url>/2019/11/05/Pigeon/</url>
    <content><![CDATA[<h1 id="Pigeon"><a href="#Pigeon" class="headerlink" title="Pigeon"></a>Pigeon</h1><p>调用者会有以下的配置，ReferenceBean是代理类，被代理的是远程服务。</p>
<a id="more"></a> 

<embed src="Pigeon.svg" width="100%" type="image/svg+xml">
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"echoService"</span> <span class="attr">class</span>=<span class="string">"com.dianping.pigeon.remoting.invoker.config.spring.ReferenceBean"</span> <span class="attr">init-method</span>=<span class="string">"init"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 服务全局唯一的标识url，默认是服务接口类名，必须设置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"http://service.dianping.com/demoService/echoService_1.0.0"</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 接口名称，必须设置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interfaceName"</span> <span class="attr">value</span>=<span class="string">"com.dianping.pigeon.demo.EchoService"</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 超时时间，毫秒，默认5000，建议自己设置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeout"</span> <span class="attr">value</span>=<span class="string">"2000"</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 序列化，hessian/fst/protostuff，默认hessian，可不设置--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serialize"</span> <span class="attr">value</span>=<span class="string">"hessian"</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 调用方式，sync/future/callback/oneway，默认sync，可不设置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"callType"</span> <span class="attr">value</span>=<span class="string">"sync"</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 失败策略，快速失败failfast/失败转移failover/失败忽略failsafe/并发取最快返回forking，默认failfast，可不设置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cluster"</span> <span class="attr">value</span>=<span class="string">"failfast"</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 是否超时重试，默认false，可不设置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeoutRetry"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 重试次数，默认1，可不设置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"retries"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ReferenceBean代理类的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(interfaceName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"invalid interface:"</span> + interfaceName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.objType = ClassUtils.loadClass(<span class="keyword">this</span>.classLoader, <span class="keyword">this</span>.interfaceName.trim());</span><br><span class="line">    InvokerConfig&lt;?&gt; invokerConfig = <span class="keyword">new</span> InvokerConfig(<span class="keyword">this</span>.objType, <span class="keyword">this</span>.url, <span class="keyword">this</span>.timeout, <span class="keyword">this</span>.callType,</span><br><span class="line">                                                       <span class="keyword">this</span>.serialize, <span class="keyword">this</span>.callback, <span class="keyword">this</span>.suffix, <span class="keyword">this</span>.writeBufferLimit, <span class="keyword">this</span>.loadBalance, <span class="keyword">this</span>.cluster,</span><br><span class="line">                                                       <span class="keyword">this</span>.retries, <span class="keyword">this</span>.timeoutRetry, <span class="keyword">this</span>.vip, <span class="keyword">this</span>.version, <span class="keyword">this</span>.protocol);</span><br><span class="line">    invokerConfig.setClassLoader(classLoader);</span><br><span class="line">    invokerConfig.setSecret(secret);</span><br><span class="line">    invokerConfig.setRegionPolicy(regionPolicy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(methods)) &#123;</span><br><span class="line">        Map&lt;String, InvokerMethodConfig&gt; methodMap = <span class="keyword">new</span> HashMap&lt;String, InvokerMethodConfig&gt;();</span><br><span class="line">        invokerConfig.setMethods(methodMap);</span><br><span class="line">        <span class="keyword">for</span> (InvokerMethodConfig method : methods) &#123;</span><br><span class="line">            methodMap.put(method.getName(), method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    checkMock(); <span class="comment">// 降级配置检查</span></span><br><span class="line">    invokerConfig.setMock(mock);</span><br><span class="line">    checkRemoteAppkey();</span><br><span class="line">    invokerConfig.setRemoteAppKey(remoteAppKey);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取被代理的服务</span></span><br><span class="line">    <span class="keyword">this</span>.obj = ServiceFactory.getService(invokerConfig);</span><br><span class="line">    configLoadBalance(invokerConfig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取被代理的服务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proxyRequest</span><span class="params">(InvokerConfig&lt;?&gt; invokerConfig)</span> <span class="keyword">throws</span> SerializationException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(ClassUtils.getCurrentClassLoader(invokerConfig.getClassLoader()),</span><br><span class="line">                                  <span class="keyword">new</span> Class[] &#123; invokerConfig.getServiceInterface() &#125;,</span><br><span class="line">                                  <span class="keyword">new</span> ServiceInvocationProxy(invokerConfig,InvokerProcessHandlerFactory.selectInvocationHandler(invokerConfig)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端请求的发送是责任链模式，发送前会经过许多的Filter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isInitialized) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Constants.MONITOR_ENABLE) &#123;</span><br><span class="line">            registerBizProcessFilter(<span class="keyword">new</span> RemoteCallMonitorInvokeFilter());</span><br><span class="line">        &#125;</span><br><span class="line">        registerBizProcessFilter(<span class="keyword">new</span> TraceFilter());</span><br><span class="line">        registerBizProcessFilter(<span class="keyword">new</span> FaultInjectionFilter());<span class="comment">//模拟故障</span></span><br><span class="line">        registerBizProcessFilter(<span class="keyword">new</span> DegradationFilter());<span class="comment">//降级</span></span><br><span class="line">        registerBizProcessFilter(<span class="keyword">new</span> ClusterInvokeFilter());</span><br><span class="line">        registerBizProcessFilter(<span class="keyword">new</span> GatewayInvokeFilter());</span><br><span class="line">        registerBizProcessFilter(<span class="keyword">new</span> ContextPrepareInvokeFilter());</span><br><span class="line">        registerBizProcessFilter(<span class="keyword">new</span> SecurityFilter());</span><br><span class="line">        registerBizProcessFilter(<span class="keyword">new</span> RemoteCallInvokeFilter());<span class="comment">//调用远程服务</span></span><br><span class="line">        bizInvocationHandler = createInvocationHandler(bizProcessFilters);</span><br><span class="line">        isInitialized = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端接收响应</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveResponse</span><span class="params">(InvocationResponse response)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//同个客户端可能同时会有多个请求在等待结果，那么如何区分返回的结果是哪个请求的呢</span></span><br><span class="line">    <span class="comment">//每个请求发送出去都会带有一个唯一标识，在响应返回时会带上这个标识</span></span><br><span class="line">    <span class="comment">//标识相同说明请求和响应是一对的</span></span><br><span class="line">    <span class="comment">//标识的实现是原子变量，在JVM维度中是唯一的</span></span><br><span class="line">    <span class="comment">//标识在集群是会重复的，但不影响配对。因为通信协议会保证响应返回对应的机器。</span></span><br><span class="line">    RemoteInvocationBean invocationBean = invocations.get(response.getSequence());<span class="comment">//</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callback callback = invocationBean.callback;</span><br><span class="line">        callback.callback(response);</span><br><span class="line">        callback.run();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        invocations.remove(response.getSequence());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock配合Condition实现等待。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SYNC、FUTURE都会使用到以下等待方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> InvocationResponse <span class="title">waitResponse</span><span class="params">(<span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!isDone()) &#123;</span><br><span class="line">            condition.await(timeoutLeft, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送请求都是调用netty的channel.write()，该方法是异步的，会在另一个线程里运行，待io结束之后会调用用户写好的listener。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//io结束，netty进行回调，释放条件锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.done = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (condition != <span class="keyword">null</span>) &#123;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
        <tag>IO模型</tag>
      </tags>
  </entry>
  <entry>
    <title>责任链模式</title>
    <url>/2019/11/03/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><p>责任链模式的定义：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系， 将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。这里就不再过多的介绍什么是责任链模式，主要来说说java中如何编写。主要从下面3个框架中的代码中介绍。</p>
<ul>
<li>servlet中的filter</li>
<li>dubbo中的filter</li>
<li>mybatis中的plugin 这3个框架在实现责任链方式不尽相同。</li>
</ul>
<h2 id="servlet中的Filter"><a href="#servlet中的Filter" class="headerlink" title="servlet中的Filter"></a>servlet中的Filter</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationFilterChain</span> <span class="keyword">implements</span> <span class="title">FilterChain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pos = <span class="number">0</span>; <span class="comment">//当前执行filter的offset</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n; <span class="comment">//当前filter的数量</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationFilterConfig[] filters;  <span class="comment">//filter配置类，通过getFilter()方法获取Filter</span></span><br><span class="line">    <span class="keyword">private</span> Servlet servlet</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; n) &#123;</span><br><span class="line">            ApplicationFilterConfig filterConfig = filters[pos++];</span><br><span class="line">            Filter filter = filterConfig.getFilter();</span><br><span class="line">            filter.doFilter(request, response, <span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// filter都处理完毕后，执行servlet</span></span><br><span class="line">            servlet.service(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码还算简单，结构也比较清晰，定义一个Chain，里面包含了Filter列表和servlet，达到在调用真正servlet之前进行各种filter逻辑。</p>
<h2 id="Dubbo中的Filter"><a href="#Dubbo中的Filter" class="headerlink" title="Dubbo中的Filter"></a>Dubbo中的Filter</h2><p>Dubbo在创建Filter的时候是另外一个方法，通过把Filter封装成 Invoker的匿名类，通过链表这样的数据结构来完成责任链，核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">buildInvokerChain</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; invoker, String key, String group)</span> </span>&#123;</span><br><span class="line">    Invoker&lt;T&gt; last = invoker;</span><br><span class="line">    <span class="comment">//只获取满足条件的Filter</span></span><br><span class="line">    List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);</span><br><span class="line">    <span class="keyword">if</span> (filters.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = filters.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            <span class="keyword">final</span> Filter filter = filters.get(i);</span><br><span class="line">            <span class="keyword">final</span> Invoker&lt;T&gt; next = last;</span><br><span class="line">            last = <span class="keyword">new</span> Invoker&lt;T&gt;() &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> filter.invoke(next, invocation);</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Mybatis中的Plugin"><a href="#Mybatis中的Plugin" class="headerlink" title="Mybatis中的Plugin"></a>Mybatis中的Plugin</h2><p>Mybatis可以配置各种Plugin，无论是官方提供的还是自己定义的，Plugin和Filter类似，就在执行Sql语句的时候做一些操作。Mybatis的责任链则是通过动态代理的方式，使用Plugin代理实际的Executor类。（这里实际还使用了组合模式，因为Plugin可以嵌套代理），核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plugin</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="keyword">private</span> Interceptor interceptor;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;      </span><br><span class="line">        <span class="keyword">if</span> (满足代理条件) &#123;</span><br><span class="line">            <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> Invocation(target, method, args));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);     </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//对传入的对象进行代理，可能是实际的Executor类，也可能是Plugin代理类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">        Class&lt;?&gt; type = target.getClass();</span><br><span class="line">        Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">        <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                    type.getClassLoader(),</span><br><span class="line">                    interfaces,</span><br><span class="line">                    <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.cnblogs.com/z-test/p/9319116.html" target="_blank" rel="noopener">https://www.cnblogs.com/z-test/p/9319116.html</a> </p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>责任链模式</tag>
        <tag>Servlet</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Guava限流</title>
    <url>/2019/10/31/Guava%E9%99%90%E6%B5%81/</url>
    <content><![CDATA[<h1 id="Guava限流"><a href="#Guava限流" class="headerlink" title="Guava限流"></a>Guava限流</h1><p>在Guava中提供的限流算法是令牌桶算法。默认是SmoothBursty模式。</p>
<a id="more"></a> 

<p>Guava实现与理论会有点不同。从理论上来看，令牌会定时地被加入到桶中，而在Guava的实现中，并没有定时器在运行，因为定时器这种实现方式太浪费资源。Guava使用的是基于时间差的令牌延时生成算法，具体来说，有以下两点：</p>
<ol>
<li><strong>延时</strong>：只有到需要使用限流器时，才去计算。如果新建了限流器，但一直没使用，这个限流器是不会去生成令牌的。</li>
<li><strong>时间差</strong>：需要生成令牌时，会拿当前时间与最后一次生成的时间做一个是时间差，然后根据生成速率可以计算出这段时间应该有多少个令牌生成。</li>
</ol>
<p>另外，Guava提供的限流器是不保证公平的。因为Guava使用synchronized来锁操作，而synchronized锁是非公平的。</p>
<p>创建限流器的时候会启动一个计时器，记录下创建时的时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//限流器获取令牌</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将令牌数转换为需要等待的时间</span></span><br><span class="line">    <span class="comment">//返回0代表不需要等待</span></span><br><span class="line">    <span class="keyword">long</span> microsToWait = reserve(permits);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果需要等待，会调用Thread.sleep(time)进行休眠</span></span><br><span class="line">    stopwatch.sleepMicrosUninterruptibly(microsToWait);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * microsToWait / SECONDS.toMicros(<span class="number">1L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//限流器核心流程</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserveEarliestAvailable</span><span class="params">(<span class="keyword">int</span> requiredPermits, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//生产令牌</span></span><br><span class="line">    resync(nowMicros);</span><br><span class="line">    <span class="keyword">long</span> returnValue = nextFreeTicketMicros;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算本次需消耗多少令牌</span></span><br><span class="line">    <span class="keyword">double</span> storedPermitsToSpend = min(requiredPermits, <span class="keyword">this</span>.storedPermits);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算本次需等待多少令牌</span></span><br><span class="line">    <span class="keyword">double</span> freshPermits = requiredPermits - storedPermitsToSpend;</span><br><span class="line">    <span class="keyword">long</span> waitMicros = storedPermitsToWaitTime(<span class="keyword">this</span>.storedPermits, storedPermitsToSpend)</span><br><span class="line">        + (<span class="keyword">long</span>) (freshPermits * stableIntervalMicros);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.nextFreeTicketMicros = LongMath.checkedAdd(nextFreeTicketMicros, waitMicros);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">        <span class="keyword">this</span>.nextFreeTicketMicros = Long.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.storedPermits -= storedPermitsToSpend;</span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//令牌生成</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resync</span><span class="params">(<span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nowMicros &gt; nextFreeTicketMicros) &#123;</span><br><span class="line">        <span class="comment">//生产令牌，用时间差除以生产速率，可以得到现在应该有多少令牌</span></span><br><span class="line">        storedPermits = min(maxPermits,</span><br><span class="line">                            storedPermits</span><br><span class="line">                            + (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros());</span><br><span class="line">        nextFreeTicketMicros = nowMicros;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Guava</tag>
        <tag>限流</tag>
      </tags>
  </entry>
  <entry>
    <title>algorithms</title>
    <url>/2019/10/20/algorithms/</url>
    <content><![CDATA[<h2 id="摊还分析法"><a href="#摊还分析法" class="headerlink" title="摊还分析法"></a>摊还分析法</h2> <a id="more"></a> 

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p><strong>常见题目</strong>：实现浏览器前进后退功能，表达式求解，括号匹配</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列可用在池化技术中，用于请求的排队等待</p>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>实现的要点是确定好队满和队空的判定条件</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>生产者-消费者模型</p>
<h3 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h3><p>基于CAS实现无锁并发队列</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>满足以下三个条件的问题可以使用递归：</p>
<ol>
<li><p>一个问题可以分解为多个子问题</p>
</li>
<li><p>该问题与子问题的数据规模不一样，但解决思路一样</p>
</li>
<li><p>存在递归终止条件</p>
</li>
</ol>
<p>我们找出问题与子问题的关系，写出<strong>递推公式</strong>，找出<strong>终止条件</strong>，根据这两项就可以直接得出代码。</p>
<p>我们思考递归时，不用去想每一层的调用关系和每一个步骤，因为这样的思考人脑很难去抽象。我们需要去<strong>假定子问题已经被解决</strong>，在子问题被解决的基础上去思考新问题。</p>
<p>递归是借助栈来实现的，所以用递归实现的地方都能改为迭代循环的方式来实现。</p>
<p><strong>常见题目</strong>：斐波那契数列、跳蛙跳台阶、二叉树遍历</p>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>a&amp;(a-1)：相当于将a最右边的1变成0</p>
<p><strong>常见题目</strong>：统计二进制中1的个数、判断是否2的幂次、m变成n需要变动几个二进制</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>当我们对数组内的元素进行删除时，可以不去删除和搬移元素，可以先标记该元素已被删除，等到数组没有更多空间时再一起处理。</p>
<p>这个思想与JVM标记清除的GC算法一样。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>写完链表代码后，需要检查边界条件是否正确：</p>
<ol>
<li>链表为空</li>
<li>链表只有1个节点</li>
<li>链表只有2个节点</li>
<li>代码处理头尾节点是否正确</li>
</ol>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>单链表的操作比较简单，遍历只能单向从头到尾。</p>
<p><strong>快慢指针</strong>常作为单链表解决问题的辅助手段。</p>
<p><strong>常见题目</strong>：链表反转，环的检测，求入环点，有序链表合并，求倒数第k个节点，回文单链表，求链表中间节点</p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p> <strong>常见问题</strong>：约瑟夫问题</p>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>工程中双向链表较为常用，因为它能在O(1)时间找到前驱节点。</p>
<p>例如Java中的LinkedList、LinkedHashMap中都涉及到双向链表。</p>
<p><strong>常见题目</strong>：LRU缓存（LinkedHashMap与LRU缓存原理是一样的，实现上有个小技巧：双端链表加一个header，双端链表其实是一个循环链表，这么做就不用判断表头表尾，相当于哨兵）</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>可以利用稳定排序算法对多个字段排序。比如对订单按照时间先后排序，相同时间的订单按照金额大小再排序。可以先按照金额进行排序，再按照时间进行稳定排序。</p>
<h3 id="O-n-2"><a href="#O-n-2" class="headerlink" title="O(n^2)"></a>O(n^2)</h3><ul>
<li>插入排序。工程上针对小规模数据较常用，相比冒泡排序，插入有着较少的交换次数；相比选择排序，插入是稳定的。</li>
<li>冒泡排序。比较并交换相邻两个元素。</li>
<li>选择排序。</li>
</ul>
<h3 id="O-n-logn"><a href="#O-n-logn" class="headerlink" title="O(n*logn)"></a>O(n*logn)</h3><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>优点是不管什么情况下，时间复杂度都稳定在O(n*logn)。缺点是空间复杂度为O(n)，需要辅助空间，工程中较少使用。</p>
<p><strong>*常见题目</strong>： 现在有10个接口访问日志文件，每个日志文件大小约300MB，每个文件里的日志都是按照时间戳从小到大排序的。希望将这10个较小的日志文件，合并为1个日志文件，合并之后的日志仍然按照时间戳从小到大排列。机器内存只有1GB。 </p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>工程上较为常用。分区点的选择是关键，如果每次都能选择到中间节点，时间复杂度是O(n*logn)。如果每次分区点都是头尾节点，那么时间复杂度就会退化为O(n^2)。工程中可以使用三数取中法或者随机法选择分区点。</p>
<p><strong>常见题目</strong>：求第K大的数</p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><h3 id="O-n"><a href="#O-n" class="headerlink" title="O(n)"></a>O(n)</h3><p>排序能做到线性时间是因为这些排序不是基于比较的。</p>
<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p>桶排序对排序数据的要求非常严格，要求数据能平均地分配到各个桶中。</p>
<p>桶排序比较适合用在外部排序中。</p>
<p><strong>常见题目</strong>： 有10GB的订单数据，希望按订单金额进行排序，但是内存有限，只有几百MB，没办法一次性把10GB的数据都加载到内存中。</p>
<p>根据年龄给100万用户排序。</p>
<h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p>计数排序属于桶排序，这里把它单独拎出来是因为它是特殊的桶排序。</p>
<p>相比于桶排序，计数排序中桶的粒度更小，小到只有一个单位，就省去了桶内排序。</p>
<p>计数排序适用于数据范围不大的情况。</p>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>基数排序要求数据可以分割出“位”来比较，且“位”的数据范围不能太大。对每一“位”使用桶排序，从低位一直排序到高位。</p>
<p><strong>常见题目</strong>：对10万个手机号码从小到大排序</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>二分查找对数据有以下要求：</p>
<ol>
<li>数据需要是有序的</li>
<li>数据存储在数组中</li>
<li>数据集太小（顺序遍历即可）或太大（数组占用连续空间）都不合适二分查找</li>
</ol>
<p>二分查找时间复杂度是O(logn)，对数级有时比常数级还要高效，因为常数级中的常数可能会很大。</p>
<p>能用二分查找解决的问题，一般也能用动态数据结构散列表和二叉树解决，他们有一个区别是：二分查找由于依赖数组，因此它的占用内存会小一点，不需要存储指针等额外数据。</p>
<p>如果用链表来实现二分查找，时间复杂度会是O(n)。</p>
<p>二分查找适合查找近似的数值，它有4种变体问题：</p>
<ol>
<li>查找第一个值等于给定值的元素</li>
<li>查找最后一个值等于给定值的元素</li>
<li>查找第一个大于等于给定值的元素</li>
<li>查找最后一个小于等于给定值的元素</li>
</ol>
<p><strong>常见题目</strong>： 有12万条IP区间与归属地的对应关系，如何快速定位出一个IP地址的归属地。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[202.102.133.0, 202.102.133.255]  山东东营市 </span><br><span class="line">[202.102.135.0, 202.102.136.255]  山东烟台</span><br></pre></td></tr></table></figure>

<p>循环数据的二分查找</p>
<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>跳表可以理解为链表版的“二分”查找。时间复杂度为O(logn)，空间复杂度为O(n)。跳表出现得比红黑树晚，在类库中有现成的红黑树代码，但没有跳表。</p>
<p><strong>常见题目</strong>：为什么redis使用跳表而不是红黑树。（1.跳表实现比较简单；2.在区间查找上，跳表效率比红黑树高）</p>
<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>散列表来源于数组，它借助散列函数对数组这种数据结构进行扩展。散列表有三个核心问题：<strong>散列函数设计</strong>、<strong>散列冲突解决</strong>、<strong>扩容策略</strong>。 </p>
<p>冲突解决方法：开放寻址法和链表法。</p>
<p>当数据量比较小、装载因子小的时候，适合采用开放寻址法。</p>
<p>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表</p>
<p> ThreadLocalMap通过线性探测的开放寻址解决冲突。</p>
<p><strong>常见题目</strong>：</p>
<ol>
<li>Word单词拼写检查</li>
<li>假设有10万条URL访问日志，如何按照访问次数给URL排序</li>
<li>有两个字符串数组，每个数组大约有10万条字符串，如何快速找出两个数组中相同的字符串</li>
<li>LRU缓存</li>
<li>配合跳表组成Redis有序集合</li>
</ol>
<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>哈希算法有以下特点：</p>
<ul>
<li>从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；</li>
<li>对输入数据非常敏感，哪怕原始数据只修改了一个Bit，最后得到的哈希值也大不相同；</li>
<li>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；</li>
<li>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。</li>
</ul>
<p>常用的哈希算法有MD5、SHA、DES、AES等。根据鸽巢原理，哈希算法一定是会有冲突的。</p>
<p>哈希算法有以下几点应用：</p>
<ol>
<li><p>安全加密</p>
</li>
<li><p>唯一标识</p>
</li>
<li><p>数据校验</p>
</li>
<li><p>散列函数</p>
</li>
<li><p>负载均衡。同一客户端请求路由到同一机器。</p>
</li>
<li><p>数据分片。</p>
<p>统计1T的搜索词日志，计算每个搜索词被搜索次数。</p>
<p>判断某张图片是否在图库中，图库有1亿张图片。</p>
</li>
<li><p>分布式存储。</p>
<p>对数据提取哈希，决定存储在哪台机器上。若新增机器，所有的数据都需要重新计算哈希。为了解决这个问题，可以使用一致性哈希算法，该算法不需要搬移全部数据，只需要将某几个小区间的数据搬移到新机器中。</p>
</li>
</ol>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p>除叶子节点外，每个节点都有左右两个子节点。</p>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>有一种二叉树，叶子节点都在最底下两层，最后一层叶子节都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做完全二叉树。 </p>
<p>完全二叉树比较适合用数组来存储，由于不需要存储左右子节点，比较节省空间。单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。</p>
<h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</p>
<p>二叉查找树相比散列表的优势：</p>
<ol>
<li>散列表是无序的，二叉查找树中序遍历可输出有序。</li>
<li>散列表需要扩容。</li>
<li>在冲突较严重的情况下，散列表性能不稳定。</li>
<li>散列表的构造比二叉树复杂，要考虑散列函数、扩容、缩容、冲突解决等，而二叉树只需要考虑平衡性。</li>
<li>由于装载因子的存在，散列表较为消耗空间。</li>
</ol>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于1。 </p>
<h3 id="平衡二叉查找树"><a href="#平衡二叉查找树" class="headerlink" title="平衡二叉查找树"></a>平衡二叉查找树</h3><p>结合平衡树和查找树的二叉树就是平衡查找二叉树了。 平衡二叉查找树是为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的。 </p>
<p>最先被发明的平衡二叉查找树是<strong>AVL树</strong>，它严格符合平衡二叉查找树的定义。</p>
<p>在工程中，红黑树要比AVL树更加常用。红黑树不是严格的平衡树。它的根节点到各个叶子节点的最长路径，有可能会比最短路径大一倍。</p>
<p>红黑树做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比AVL树要低。</p>
<p><strong>常见题目</strong>：</p>
<ol>
<li>前中后序遍历；</li>
<li>层序遍历（用队列）；</li>
<li>按层输出（用队列，且使用两个辅助变量）；</li>
<li></li>
</ol>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆是一种特殊的数，满足以下两个条件的树可以称之为堆：</p>
<ol>
<li>堆是一个完全二叉树；</li>
<li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。 </li>
</ol>
<p>既然堆是完全二叉树，那么堆就适合使用数组存储。从下标为1开始，假设一个节点下标为n，那么左右两个子节点的下标分别为2n和2n+1.</p>
<p>堆排序可分为两个阶段：<strong>建堆</strong>和<strong>排序</strong>。堆排序的时间复杂度是O(n*logn)</p>
<p>建堆：可以采用从下至上的<strong>插入数据</strong>的方法，假设刚开始数组里只有一个元素，每次往里插入一个元素，然后堆化。</p>
<p>排序：可以采用从上至下的<strong>删除数据</strong>的方法，将堆顶数据与最末尾的数据交换，然后重新堆化。</p>
<p>在工程中，堆排序没有快速排序快，有以下原因：</p>
<ol>
<li>堆排序是跳着访问元素的，对CPU缓存不友好；</li>
<li>由于堆排序需要建堆，建堆后的数据可能比之前更加无序。所以堆排序需要的交换次数会大于快速排序</li>
</ol>
<p>优先级队列是堆的一个应用方向。Java中PriorityQueue就是基于堆实现的。 </p>
<p><strong>常见题目</strong>：</p>
<ol>
<li><p>topK</p>
<p>维护一个大小为K的堆，每次新来数据就堆化数组，每次插入时间复杂度为O(logn)，取topK时间复杂度为O(1)（需要区别Partition方法的求第K大数）。</p>
</li>
<li><p>数据流的中位数</p>
<p>不仅仅可以求中位数，只要改变两个堆中的数据比例，就可以求类似“接口99响应时间”等问题了。</p>
</li>
<li><p>合并有序小文件</p>
<p>有100个小文件，每个文件的大小是100MB，每个文件中存储的都是有序的字符串。希望将这些100个小文件合并成一个有序的大文件。</p>
</li>
</ol>
<h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h2><h3 id="单模式匹配"><a href="#单模式匹配" class="headerlink" title="单模式匹配"></a>单模式匹配</h3><h4 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h4><p>BF算法中的BF是Brute Force，暴力匹配。时间复杂度是O(n*m)，其中n是主串长度，m是模式串长度。</p>
<p>BF算法简单简单朴素，效率低，但在实际开发中却较为常用。因为实际使用场景下，一般的字符串都比较小，选用BF效率影响不大。且BF算法简单不易出错。</p>
<h4 id="RK算法"><a href="#RK算法" class="headerlink" title="RK算法"></a>RK算法</h4><p>RK算法的全称叫Rabin-Karp算法，是由它的两位发明者Rabin和Karp的名字来命名的。 </p>
<p> RK算法的思路是这样的：我们通过哈希算法对主串中的n-m+1个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。哈希算法的选择很重要，理想情况下，时间复杂度是O(n)，n为主串长度。</p>
<h4 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h4><p>BM（Boyer-Moore）算法是一种非常高效的字符串匹配算法，在工程非常常用。有实验统计，它的性能是著名的KMP算法的3到4倍。我们可以在BF算法的基础上理解BM算法。</p>
<p>在BF算法中，模式串在匹配失败后会往后移动一位。BM算法就是找到规律，让模式串每次多往后移动几位，减少不必要的字符比较。</p>
<p>BM算法的时间复杂度分析起来是非常复杂，这篇论文“<a href="http://dl.acm.org/citation.cfm?id=127830" target="_blank" rel="noopener">Tight bounds on the complexity of the Boyer-Moore string matching algorithm</a>”证明了在最坏情况下，BM算法的比较次数上限是3n。 </p>
<p><strong>常见题目</strong>：文本编辑器的查找功能。</p>
<h4 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h4><p>KMP算法是根据三位作者（D.E.Knuth，J.H.Morris和V.R.Pratt）的名字来命名的。KMP算法的核心思想，跟BM算法非常相近。在模式串与主串匹配的过程中，当遇到不可匹配的字符的时候，我们希望找到一些规律，可以将模式串往后多滑动几位。</p>
<p>KMP算法的时间复杂度就是O(m+n) 。</p>
<h3 id="多模式匹配"><a href="#多模式匹配" class="headerlink" title="多模式匹配"></a>多模式匹配</h3><h4 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h4><p>Trie树，也叫“字典树”。顾名思义，它是一个树形结构。它是一种专门处理字符串匹配的数据结构， 用来解决<strong>在一组字符串集合中快速查找某个字符串</strong>的问题。Trie树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起。构建Tire树的时间复杂度是O(m)，m表示所有字符串的长度和。</p>
<p>将多个模式串构建成Tire树。Tire树构建完成后，就可以用主串来走这个Tire树了。时间复杂度为O(n)，n为要查询的主串长度。</p>
<p>Tire的存储是比较浪费空间的，我们需要在效率和空间中找到平衡。</p>
<p>实际上，字符串的匹配问题，笼统上讲，其实就是数据的查找问题。对于支持动态数据高效操作的数据结构，比如散列表、红黑树、跳表等等。这些数据结构也可以实现在一组字符串中查找字符串的功能。我们拿散列表和红黑树，跟Trie树比较一下。Tire树对多个模式串有一定的要求，若不满足以下要求，Tire树的空间消耗会比较大：</p>
<ol>
<li><p>字符串中包含的字符集尽量要小；</p>
</li>
<li><p>字符串的前缀重合尽量要多。</p>
</li>
</ol>
<p>Trie树更加适合查找前缀匹配的字符串问题。散列表或者红黑树更加适合精确匹配查找问题。</p>
<p><strong>常见题目</strong>：</p>
<ol>
<li>手机英文输入自动提示单词（ACM题目：POJ1451 T9 <a href="http://poj.org/problem?id=1451）；" target="_blank" rel="noopener">http://poj.org/problem?id=1451）；</a></li>
<li>搜索引擎的搜索关键词提示功能</li>
</ol>
<h4 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h4><p>AC自动机算法，全称是Aho-Corasick算法。其实，Trie树跟AC自动机之间的关系，就像单串匹配中朴素的串匹配BF算法，跟KMP算法之间的关系一样。<strong>AC自动机实际上就是在Trie树之上，加了类似KMP的next数组，只不过此处的next数组是构建在树上罢了</strong>。AC自动机适合大量文本中多模式串的精确匹配查找，时间复杂度可以到O(n*len)。len是模式串的平均长度。</p>
<p><strong>常见题目</strong>：论坛中的敏感词过滤。 </p>
<p>动态数据结构：散列表、二叉树、跳表</p>
<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><p>子问题之间没有相关性</p>
<p><strong>常见题目</strong>：求逆序对数量（借助归并排序）</p>
<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>回溯是一种在一组可能的解中，找到符合要求解的算法。剪枝操作可以增加回溯的效率。</p>
<p><strong>常见问题</strong>：深度优先遍历、01背包、8皇后、旅行商问题、全排列等。</p>
<h2 id="位运算-1"><a href="#位运算-1" class="headerlink" title="位运算"></a>位运算</h2><p>二进制1的个数（n&amp;(n-1)）</p>
<h2 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h2><p>杨氏矩阵是否存在某树（leetcode 74）</p>
<p>单峰值数组寻找峰值</p>
<p>多峰值数组寻找峰值</p>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>字符串翻转（单词，旋转）</p>
<h2 id="堆-1"><a href="#堆-1" class="headerlink" title="堆"></a>堆</h2><p>数据流中位数</p>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>二维矩阵中找字符串，不能重复（leetcode 79）</p>
<p>全排列</p>
<h2 id="二叉树-1"><a href="#二叉树-1" class="headerlink" title="二叉树"></a>二叉树</h2><ol>
<li><p>二叉树深度（leetcode 104后序遍历）</p>
</li>
<li><p>判断是否平衡二叉树（leetcode 110后序遍历）</p>
</li>
<li><p>判断是否为另一棵树的子结构（leetcode 572）</p>
</li>
<li><p>判断是否镜像树（leetcode 101）</p>
</li>
<li><p>二叉树的最大直径（与深度有关）</p>
</li>
<li><p>合并二叉树</p>
</li>
<li><p>求两个节点的最低公共祖先（leetcode 236）</p>
</li>
<li><p>前中后序遍历</p>
</li>
<li><p>中序遍历的下一个节点（优先考虑右子树最左节点，若不存在，则考虑父节点）</p>
</li>
</ol>
<h2 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h2><ol>
<li>判断是否单链表回文</li>
<li>奇偶链表反转</li>
<li>两个链表的第一个交叉点（交换遍历）</li>
</ol>
<h2 id="Bit-Map"><a href="#Bit-Map" class="headerlink" title="Bit Map"></a>Bit Map</h2><ol>
<li>使用10MB内存，找出40亿个整数的中位数</li>
<li>40亿个非负整数中找到出现两次的数</li>
<li>40亿个非负整数中找到没出现的数</li>
</ol>
<h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><p>连续子数组的最大和（DP）</p>
<p>下一个排列</p>
<ol>
<li>范围[1,n]共n+1个数，找唯一一个重复的数（使用环检测）</li>
<li>范围[0,n-1]共n个数，找重复的数（下标位置互换）</li>
<li>滑动窗口中的最大值</li>
<li>数组中找第K大的数（使用快排中的partition，O(n)，特例：找出出现次数超过一半的数，计数法？）</li>
<li>数组中找出TopK（1.使用partition，会修改数组；2.使用堆O(n*logk)，不会修改数组，适合大数据）</li>
<li>某数字在排序数组中出现的次数（两次二分查找找头尾，O(logn)）</li>
<li>数组中只出现一次的数/数组中出现两次的数（使用异或位运算）</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>MESI</title>
    <url>/2019/10/19/MESI/</url>
    <content><![CDATA[<h1 id="MESI"><a href="#MESI" class="headerlink" title="MESI"></a>MESI</h1><p>CPU运算速度很快，内存运算速度很慢，它们在运算速度上有着较大的差距，如果让CPU等待内存处理完数据再进行下一步操作，会造成CPU资源浪费，为了解决这个问题，CPU高速缓存应运而生。</p>
<a id="more"></a> 

<p>在多核CPU系统中，就会存在多个一级缓存，那么相同的数据就会出现副本，可能会造成缓存数据不一致，为了不让系统数据混乱。这里引入MESI来协议保证系统正常运行。</p>
<p>MESI是4种状态的首字母，它们分别是修改态（Modified）、独占态（Exclusive）、共享态（Shared）、无效态（Invalid）。代表了缓存中数据可能处于的状态。</p>
<h3 id="双核读取"><a href="#双核读取" class="headerlink" title="双核读取"></a>双核读取</h3><p>①CPU A发出了一条指令，从主内存中读取x：<br>    CPU A从主内存通过bus读取到 cache a中并将该cache line设置为E状态。<br>②CPU B发出了一条指令，从主内存中读取x：<br>    CPU B试图从主内存中读取x时，CPU A检测到了地址冲突，将x标记为S状态。此时x存储于cache a和cache b中，其状态都为S。</p>
<img src="/2019/10/19/MESI/1.png" title="双核读取"> 



<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>①CPU A发指令修改x：<br>    CPU A将x设置为M状态并通知缓存了x的CPU B，CPU B将cache b中的x设置为I状态。<br>    CPU A对x进行赋值。</p>
<img src="/2019/10/19/MESI/2.png" title="修改数据"> 



<h3 id="同步数据"><a href="#同步数据" class="headerlink" title="同步数据"></a>同步数据</h3><p>①CPU B发出指令读取x：<br>    CPU B通知CPU A，CPU A将修改后的数据同步到主内存和CPU B的cache，x的状态变为S。</p>
<img src="/2019/10/19/MESI/3.png" title="同步数据"> 



<p>MESI的状态转移中有两个需要特别注意的地方：</p>
<p>1.<strong>I–&gt;M，S–&gt;M</strong>。当CPU A对S状态的数据进行写操作时，需要在总线上发送invalidate请求，并等待其他CPU的invalidate acknowledge。同样地，对I状态的数据进行写操作，需要发送read invalidate请求并等待结果。这会降低CPU A的性能。</p>
<p>2.<strong>MES–&gt;I</strong>。CPU A发送invalidate请求给CPU B，CPU B收到请求后，并不能立即回复invalidate acknowledge，主要原因是invalidate cacheline的操作没有那么快完成，特别是cache比较繁忙的时候。这时，CPU往往进行密集的loading和storing的操作，而来自其他CPU的，对本CPU local cacheline的操作需要和本CPU密集的cache操作进行竞争，只要完成了invalidate操作之后，本CPU才会发送invalidate acknowledge。</p>
<p>针对以上两个地方，MESI协议使用Store Buffer和Invalidate Queue来优化性能。</p>
<img src="/2019/10/19/MESI/4.png" title="Store Buffer与Invalidate Queue"> 



<h4 id="Store-Buffer"><a href="#Store-Buffer" class="headerlink" title="Store Buffer"></a>Store Buffer</h4><p>一旦增加了Store Buffer，那么CPU A无需等待其他CPU的响应，只需要将要修改的内容放入Store Buffer，然后就可以继续执行。当cacheline完成bus transaction后，就可以将修改的数据将从Store Buffer写进cacheline。</p>
<h5 id="引入Store-Buffer之后的问题"><a href="#引入Store-Buffer之后的问题" class="headerlink" title="引入Store Buffer之后的问题"></a>引入Store Buffer之后的问题</h5><ol>
<li><p>CPU A运行foo()，CPU B运行bar()，a在CPU A中，b在CPU B中。</p>
</li>
<li><p>CPU A将a=1写进Store Buffer，发送read invalidate请求，然后执行b=1。</p>
</li>
<li><p>CPU B通过read请求读到b=1，循环。</p>
</li>
<li><p>在CPU B这端，a的值为0，并不是预期的1。这时invalidate请求还未到达CPU B，a不会变成I状态。</p>
</li>
</ol>
<p>具体过程可参考文献。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CPU A</span></span><br><span class="line"><span class="comment">//cacheline b</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CPU B</span></span><br><span class="line"><span class="comment">//cacheline a</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    assert(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Invalidate-Queues"><a href="#Invalidate-Queues" class="headerlink" title="Invalidate Queues"></a>Invalidate Queues</h4><p>CPU在响应invalidate请求时，其实不需要完成invalidate操作就可以回送acknowledgement消息。CPU可以将invalidate message放入Invalidate Queues，然后直接回应acknowledgement，表示自己已经收到请求，随后会慢慢处理。当然，再慢也要有一个度，例如在对x变量的invalidate处理完成之前，不会发送有关x的请求出去。</p>
<h5 id="引入Invalidate-Queues之后的问题"><a href="#引入Invalidate-Queues之后的问题" class="headerlink" title="引入Invalidate Queues之后的问题"></a>引入Invalidate Queues之后的问题</h5><p>与Store Buffer所带来的问题类似。在CPU B这端，invalidate操作并没有被真正执行，所以变量a的值为0且状态有效，并不会得到预期的1.</p>
<h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>硬件工程师为了将CPU性能发挥到极致，引入了Store Buffer和Invalidate Queues，那么相应地也带来了可见性和有序性的问题。于是硬件工程师又加入了Memory Barrier指令来解决上述问题。</p>
<p>看到这里，可能会有一个问题：硬件为什么不把这些底层的信息屏蔽掉呢，帮我们自动加上Memory Barrier就可以了？回答是不能的，因为软件经过编译处理变成硬件指令，硬件是不知道顶层业务逻辑的。</p>
<h4 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h4><p>CPU收到写Memory Barrier指令，要等到收到invalidate ack，并将store buffer中所有数据写到cacheline之后才会执行后续指令。</p>
<h3 id="读屏障"><a href="#读屏障" class="headerlink" title="读屏障"></a>读屏障</h3><p>CPU收到读Memory Barrier指令，要等到执行完Invalidate Queue中的所有invalidate命令之后才会执行后续指令。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CPU A</span></span><br><span class="line"><span class="comment">//cacheline b</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//写屏障</span></span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CPU B</span></span><br><span class="line"><span class="comment">//cacheline a</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">//读屏障</span></span><br><span class="line">    assert(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><p>MESI：<a href="https://www.cnblogs.com/yanlong300/p/8986041.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanlong300/p/8986041.html</a></p>
</li>
<li><p>Linux内核同步机制之（三）: <a href="http://www.wowotech.net/kernel_synchronization/memory-barrier.html" target="_blank" rel="noopener">http://www.wowotech.net/kernel_synchronization/memory-barrier.html</a></p>
</li>
<li><p>《Memory Barriers: a Hardware View for Software Hackers》</p>
</li>
<li><p>《Memory Barriers: a Hardware View for Software Hackers》翻译：<a href="http://www.wowotech.net/kernel_synchronization/Why-Memory-Barriers.html" target="_blank" rel="noopener">http://www.wowotech.net/kernel_synchronization/Why-Memory-Barriers.html</a></p>
</li>
<li><p>《深入理解并行编程》作者Paul E. McKenney：<a href="http://www2.rdrop.com/users/paulmck/" target="_blank" rel="noopener">http://www2.rdrop.com/users/paulmck/</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java知识</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>CPU缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>CAS</title>
    <url>/2019/10/16/CAS/</url>
    <content><![CDATA[<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>比较并交换(CompareAndSwap, CAS)是原子性更新变量的一种方式。Java中将对变量的原子性操作封装成原子类。</p>
<a id="more"></a> 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AtomicInteger.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//valueOffset是偏移地址</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndSetInt(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Unsafe.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSetInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//获取旧值var5,compareAndSwapInt是个native方法</span></span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么<code>this.compareAndSwapInt(var1, var2, var5, var4)</code>再往下是什么呢？</p>
<p>最终在这个目录（<code>/hotspot/src/os_cpu/linux_x86/vm/atomic_linux_x86.inline.hpp</code>）可以看到compareAndSwapInt使用了CPU的底层指令。以下是linux_x86平台的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果是多核处理器的环境，需要在指令前加lock前缀</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) <span class="meta-string">"cmp $0, "</span> #mp <span class="meta-string">"; je 1f; lock; 1: "</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> jint Atomic::cmpxchg (jint exchange_value, <span class="keyword">volatile</span> jint* dest, jint compare_value) &#123;</span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  __<span class="function">asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>) <span class="string">"cmpxchgl %1,(%3)"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"=a"</span> (exchange_value)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"r"</span> (exchange_value), <span class="string">"a"</span> (compare_value), <span class="string">"r"</span> (dest), <span class="string">"r"</span> (mp)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于Intel平台，CPU使用cmpxchgl指令来完成该功能，但它并不是原子的。在多核环境下，需要加lock指令来保证原子性。那么lock指令会产生什么动作呢。在老CPU上面（486 &lt; CPU &lt; P6），Lock指令会锁总线，这样来自其他处理器的请求会被阻塞；在新CPU上面（CPU &gt; P6），Lock指令不会锁总线，而是会使用缓存一致性协议（MESI）来保证原子性。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>Intel开发手册：<a href="https://software.intel.com/en-us/articles/intel-sdm" target="_blank" rel="noopener">https://software.intel.com/en-us/articles/intel-sdm</a></p>
]]></content>
      <categories>
        <category>Java知识</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2019/10/16/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式，即对于一个类，只能有一个实例。由于构造函数可以新增实例，所以在所有的单例实现中，构造函数必须是private。以下列出四种常见的单例模式的实现方式。</p>
<a id="more"></a> 

<h2 id="1、枚举"><a href="#1、枚举" class="headerlink" title="1、枚举"></a>1、枚举</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类经过编译也会生成一个类，一个class文件。这个类会继承抽象类Enum，由于java不能多继承，所以枚举类是不能继承别的类的。枚举类中的枚举值，会变成该类中的静态常量，有几个枚举值，就会有几个静态常量。枚举能实现单例，本质上是使用了静态常量来达成的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反编译Singleton.class</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//编译器新增的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态代码块，非延时加载</span></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> Singleton(<span class="string">"INSTANCE"</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、静态常量"><a href="#2、静态常量" class="headerlink" title="2、静态常量"></a>2、静态常量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非延时加载，会浪费内存。</p>
<h2 id="3、静态内部类"><a href="#3、静态内部类" class="headerlink" title="3、静态内部类"></a>3、静态内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>延时加载，对内存友好。</p>
<h2 id="4、双重检查"><a href="#4、双重检查" class="headerlink" title="4、双重检查"></a>4、双重检查</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意变量singleton需要用volatile修饰，保证不被重排序和对其他线程的可见性。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
        <tag>volatile关键字</tag>
        <tag>synchronized关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>LockSupport</title>
    <url>/2019/10/15/LockSupport/</url>
    <content><![CDATA[<h1 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h1><a id="more"></a> 

<p>LockSupport类是基本的线程阻塞组件，在锁和其他同步器中都会使用到。park和unpark是它最核心的两个方法。</p>
<p>LockSupport替代了Thread.suspend和Thread.resume的功能，Thread的suspend和resume方法已经在JDK2中被弃用，原因是suspend方法在挂起线程时，并不会释放该线程持有的锁，这样可能会导致死锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LockSupport.java</span></span><br><span class="line"><span class="comment">//挂起</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">        UNSAFE.unpark(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果已经存在一个许可的话（这里的许可可以通过调用unpark获取），调用park会立即返回。</p>
<p>如果没有许可的话，调用park会阻塞，需等待其他地方调用unpark唤醒。</p>
<p>许可不能累加，也就是说如果多次调用unpark，许可还是只有一个，只能允许后面一个park调用立即返回，第二个park会阻塞。</p>
<p>park方法应该放在一个循环中使用，因为会存在虚假唤醒的情况。</p>
<p>在LockSupport的实现中，UNSAFE.park()和UNSAFE.unpark()是native方法。在openjdk/hotspot/src/share/vm/prims/unsafe.cpp可以找到UNSAFE的实现（<code>thread-&gt;parker()-&gt;park(isAbsolute != 0, time);</code>）UNSAFE调用了Parker类的方法。以下为linux下park、unpark的实现。有关许可的部分，是借助了_counter变量来实现的。</p>
<p>该实现主要使用了Pthread中的互斥锁和条件变量。有关Pthread可参考。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//openjdk/hotspot/src/os/linux/vm/os_linux.cpp</span></span><br><span class="line"><span class="comment">//已删去本次不关注的部分</span></span><br><span class="line"><span class="keyword">void</span> Parker::park(<span class="keyword">bool</span> isAbsolute, jlong time) &#123;</span><br><span class="line">  <span class="comment">//检查是否调用过unpark唤醒，若是，则不阻塞</span></span><br><span class="line">  <span class="keyword">if</span> (Atomic::xchg(<span class="number">0</span>, &amp;_counter) &gt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//条件等待时，需要加锁</span></span><br><span class="line">  <span class="keyword">if</span> (Thread::is_interrupted(thread, <span class="literal">false</span>) || pthread_mutex_trylock(_mutex) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//再次检查是否调用过unpark</span></span><br><span class="line">  <span class="keyword">int</span> status ;</span><br><span class="line">  <span class="keyword">if</span> (_counter &gt; <span class="number">0</span>)  &#123;</span><br><span class="line">    <span class="comment">//之前调用过unpark，存在一个许可，可立即返回</span></span><br><span class="line">    _counter = <span class="number">0</span>;</span><br><span class="line">    status = pthread_mutex_unlock(_mutex);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//进行条件等待</span></span><br><span class="line">  <span class="keyword">if</span> (time == <span class="number">0</span>) &#123;</span><br><span class="line">    status = pthread_cond_wait (&amp;_cond[_cur_index], _mutex) ;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    status = os::Linux::safe_cond_timedwait (&amp;_cond[_cur_index], _mutex, &amp;absTime) ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//等待到某个条件，释放锁</span></span><br><span class="line">  _counter = <span class="number">0</span> ;</span><br><span class="line">  status = pthread_mutex_unlock(_mutex) ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Parker::unpark() &#123;</span><br><span class="line">  <span class="comment">//加锁</span></span><br><span class="line">  status = pthread_mutex_lock(_mutex);</span><br><span class="line">  s = _counter;</span><br><span class="line">  <span class="comment">//将_counter设置为1，即使unpark在park之前被调用，park阻塞的线程也能被唤醒</span></span><br><span class="line">  _counter = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (s &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//如果s&lt;1，说明有线程阻塞，需要发信号唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (_cur_index != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (WorkAroundNPTLTimedWaitHang) &#123;</span><br><span class="line">        status = pthread_cond_signal (&amp;_cond[_cur_index]);</span><br><span class="line">        status = pthread_mutex_unlock(_mutex);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        status = pthread_mutex_unlock(_mutex);</span><br><span class="line">        status = pthread_cond_signal (&amp;_cond[_cur_index]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pthread_mutex_unlock(_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//s&gt;=1，说明当前无线程阻塞</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pthread_mutex_unlock(_mutex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parker</span> :</span> <span class="keyword">public</span> os::PlatformParker &#123;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> _counter ;  </span><br><span class="line">  ...  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">bool</span> isAbsolute, jlong time)</span></span>;  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unpark</span><span class="params">()</span></span>;  </span><br><span class="line">  ...  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlatformParker</span> :</span> <span class="keyword">public</span> CHeapObj&lt;mtInternal&gt; &#123;  </span><br><span class="line">  <span class="keyword">protected</span>:  </span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> _mutex [<span class="number">1</span>] ;  </span><br><span class="line">    <span class="keyword">pthread_cond_t</span>  _cond  [<span class="number">1</span>] ;  </span><br><span class="line">    ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个Java线程持有一个Parker实例，每个Parker实例中持有一个条件变量和互斥锁，因此当调用unpark唤醒的时候，是可以指定唤醒哪个线程的。</p>
]]></content>
      <categories>
        <category>Java知识</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS原理</title>
    <url>/2019/10/13/AQS%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><h2 id="AQS的设计"><a href="#AQS的设计" class="headerlink" title="AQS的设计"></a>AQS的设计</h2><p>AQS（AbstractQueuedSynchronizer）是JDK1.5并发包引入的一个小型框架。它为并发包中的许多同步器提供了底层实现。</p>
 <a id="more"></a> 

<p>同步器的基本思路很简单，它有两个基本操作：获取锁和释放锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">获取锁(acquire):</span><br><span class="line"><span class="keyword">while</span> (synchronization state does not allow acquire) &#123;</span><br><span class="line">	enqueue current thread <span class="keyword">if</span> not already queued;</span><br><span class="line">	possibly block current thread;</span><br><span class="line">&#125;</span><br><span class="line">dequeue current thread <span class="keyword">if</span> it was queued;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">释放锁(release):</span><br><span class="line">update synchronization state;</span><br><span class="line"><span class="keyword">if</span> (state may permit a blocked thread to acquire)</span><br><span class="line">	unblock one or more queued threads;</span><br></pre></td></tr></table></figure>

<embed src="AQS_queue.svg" width="100%" type="image/svg+xml">

<p>AQS需要以下三个重要的部分协调工作：</p>
<h3 id="同步状态"><a href="#同步状态" class="headerlink" title="同步状态"></a>同步状态</h3><p>AQS类中有一个int型的变量，该变量是volatile的，保证了同步状态在线程间的可见性。AQS提供了三个方法来操作同步状态：getState、setState、compareAndSetState。</p>
<h3 id="线程阻塞"><a href="#线程阻塞" class="headerlink" title="线程阻塞"></a>线程阻塞</h3><p>AQS使用LockSupport.park阻塞线程，使用LockSupport.unpark解锁线程。有关LockSupport的详情，具体可参考这里。</p>
<h3 id="线程队列"><a href="#线程队列" class="headerlink" title="线程队列"></a>线程队列</h3><p>队列是AQS的核心，该队列是FIFO队列（FIFO队列不支持对线程进行优先级排序），用于维护处于等待锁状态的线程。关于队列，有CLH队列和MCS队列，两种队列的详情可参考这里。因为CLH队列能比较好地处理timeout和cancel线程这两种情况，因此AQS以CLH队列为基础，对其进行了改造。</p>
<p>CLH队列在刚被提出时，是用于自旋锁的，而在AQS中，它不再用于自旋锁。AQS对CLH做的最大的修改是新增了指向后继节点的变量。因为AQS在线程释放锁时，需要显式地去唤醒下一个在等待的线程。</p>
<p>修改后的队列就变成了双向链表。在不加锁的情况下，无法原子性地操作双向链表的前、后节点，那么可能会存在next指向null的情况，这个时候就需要从tail往前找。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>在AQS中，有以下方法可以被重写，且重写这些方法是唯一使用AQS的方法。AQS是一个抽象类，但其中没有抽象方法，它作为抽象类是希望有子类去继承它并重写以下几个方法。以下几个方法都不是抽象方法，如果把他们都定为抽象方法的话，每个子类都需要重写全部5个方法，但对于某些锁而言，只要重写其中tryAcquire和tryRelease两个方法即可。</p>
<ul>
<li>tryAcquire</li>
<li>tryRelease</li>
<li>tryAcquireShared</li>
<li>tryReleaseShared</li>
<li>isHeldExclusively</li>
</ul>
<p>除了以上几个方法外，AQS中其他都是final方法，表示不能被子类修改。这么设计的原因是，AQS是一个整体性的框架，只修改其中某个方法没有意义，会使得整个框架无法按照预期工作。</p>
<p>下面是一个使用AQS实现互斥锁Mutex的例子。在类中新建内部类Sync继承AQS，这是一种比较建议的方法。这样的话，不会把AQS的细节对外暴露，而且对外暴露的公有方法可以取合适的名字。比如CountDownLatch的await()、ReentrantLock的lock()、Semaphore的acquire()。</p>
<p>tryAcquire:当能获取同步状态时，该方法需返回true</p>
<p>tryRelease:当新的同步状态可以被别的线程获取，该方法需返回true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> ignore)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> compareAndSetState(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> ignore)</span> </span>&#123;</span><br><span class="line">            setState(<span class="number">0</span>); <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; sync.acquire(<span class="number">0</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; sync.release(<span class="number">0</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>《The java.util.concurrent Synchronizer Framework》</p>
]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal</title>
    <url>/2019/09/09/ThreadLocal/</url>
    <content><![CDATA[<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><a id="more"></a> 

<p>ThreadLocal类提供了thread-local的变量，即每个线程都持有一份各自独立的变量。每个Thread类中有一个ThreadLocalMap类型的变量。</p>
<p>具体的ThreadLocalMap实例并不是ThreadLocal持有的，而是每个Thread持有，且不同的Thread持有不同的ThreadLocalMap实例, 因此它们不存在竞争。每个ThreadLocal只存一个数据，要在同个线程中存多个数据需要多个ThreadLocal。</p>
<p>下面是ThreadLocal对象引用图，下面的内容参考这张图看会更加容易理解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">    	map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建议使用static的ThreadLocal。既然是给整个线程使用的，那么将ThreadLocal定义成static就比较合理。</p>
<p>当使用局部变量结束后，ref指向ThreadLocal这个引用会消失，相应Entry的key会被回收。如果我们要再次使用ThreadLocal，那么就会new一个Entry。旧的Entry会在后续的操作中被回收。</p>
<p>ThreadLocal典型的应用是在web上。对于一个用户请求，web服务器会使用一个线程来服务这个请求。在web服务器中，线程的使用方式一般是线程池。我们一般可以在ThreadLocal中保存该用户的相关信息。</p>
<h2 id="为什么使用弱引用"><a href="#为什么使用弱引用" class="headerlink" title="为什么使用弱引用"></a>为什么使用弱引用</h2><p>ThreadLocalMap中的key是弱引用，value是强引用。使用弱引用的原因是提高内存利用率，防止内存泄露（只能防止特定情况下的内存泄露）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        Object value;</span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果key和value都是强引用的话，那么在整个线程活动中，Map中的对象是一直存在的，不能回收。换成弱引用的话，如果ThreadLocal ref这个强引用（如方法中的局部变量）消失的话，那么Map中的key就会被回收，key变为null。在后续对ThreadLocal的操作中（set/get/remove），ThreadLocal会检查key为null的Entry，并清除该Entry。但是，如果后续不对ThreadLocal进行操作，那个Entry中的value就会一直滞留，造成内存泄露。</p>
<p>如果使用了static的ThreadLocal，那么这条强引用就会一直存在，Entry中的弱引用就不会产生作用。</p>
<h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><h3 id="线程池的场景"><a href="#线程池的场景" class="headerlink" title="线程池的场景"></a>线程池的场景</h3><p><strong>在线程池场景下，必须使用remove</strong>。在该场景下，线程使用完毕并不会销毁，而是会回到池中等待下一次使用。如果在每次使用都set新对象的话，那么在Map中存储的值就会越来越多。由于指向Entry中的value的引用链一直是可到达的，旧的value不能回收，新的value不断往里放，导致内存泄露。</p>
<h3 id="非线程池的场景"><a href="#非线程池的场景" class="headerlink" title="非线程池的场景"></a>非线程池的场景</h3><p><strong>在非线程池的场景下，可以不使用remove</strong>。在该场景下，线程使用完毕会销毁，指向Entry的引用链不可达，这条链上的对象都会被回收。</p>
<embed src="ThreadLocal.svg" width="100%" type="image/svg+xml">]]></content>
      <categories>
        <category>Java知识</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>JDK源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven依赖</title>
    <url>/2019/08/05/Maven%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<h1 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h1><a id="more"></a> 

<h2 id="依赖传递性"><a href="#依赖传递性" class="headerlink" title="依赖传递性"></a>依赖传递性</h2><p>一般情况下，一个项目的依赖会从它的parent pom和dependency中得到。在允许依赖传递的情况下，整个项目的依赖关系会膨胀得非常快。以下几个因素为影响依赖的传递：</p>
<ol>
<li>依赖仲裁：一个artifact有多个版本的情况下，Maven会选择距离本项目最近的版本，如果两个依赖的距离是一样的，那么就选择第一个加载的依赖（这个加载顺序视情况而定）。A -&gt; B(1.0)和A -&gt; C -&gt; B(2.0)，这两种情况下，项目A会使用依赖B1.0版本。</li>
<li><em>Dependency management</em>： A -&gt; B和A -&gt; C -&gt; B，如果我们在A中新增Dependency management，不管这两个B使用什么版本，都以Dependency management中的版本为准。</li>
<li><em>Dependency scope</em>: 我们可以为依赖指定scope，每个scope的依赖传递性不同。</li>
<li><em>Excluded dependencies</em>: 我们可以Exclude掉依赖的依赖。</li>
<li><em>Optional dependencies</em>: 如果将一个pom A中的依赖B指定为optional，那么在其他项目中引用pom A，依赖B不会被自动引入，需要显式地引入B。</li>
</ol>
<h2 id="Dependency-management"><a href="#Dependency-management" class="headerlink" title="Dependency management"></a>Dependency management</h2><p>Dependency management主要用于统一管理依赖的版本。在项目中要引用Dependency management里面的依赖，最小的坐标是<strong>{groupId, artifactId, type, classifier}</strong>，在默认情况下，type=jar，classifier=null。一般情况下使用<strong>{groupId, artifactId}</strong>即可。</p>
<p>由于一个pom只有一个parent，在小规模项目中，可以在parent pom中设置Dependency management。对于多模块项目，就不能引入多个parent pom了。可以利用scope的import引入多个Dependency management。这里的每个pom可以被称为”bill of materials” (BOM)，我们将一组相关的依赖打包成bom pom。下面例举了两个项目的bom以及他们的使用方法。对于import的scope，只是将该依赖用该依赖的内容进行替换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-framework-bom&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.0.1.RELEASE&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.jboss.bom&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jboss-javaee-6.0-with-tools&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;some.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>效率工具</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven依赖</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/2019/06/28/Spring/</url>
    <content><![CDATA[<h1 id="Spring中如何避免bean别名循环依赖"><a href="#Spring中如何避免bean别名循环依赖" class="headerlink" title="Spring中如何避免bean别名循环依赖"></a>Spring中如何避免bean别名循环依赖</h1><p>在Spring bean的配置中，可以为bean配置一个别名。但在配置别名时，开发人员可能会不小心将别名配置成一个循环。Spring会检测出这种情况并且抛出一个异常。</p>
<a id="more"></a> 

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这种循环的别名配置会抛异常 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"demoService"</span> <span class="attr">alias</span>=<span class="string">"alias1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"alias1"</span> <span class="attr">alias</span>=<span class="string">"alias2"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"alias2"</span> <span class="attr">alias</span>=<span class="string">"demoService"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名"></a>设置别名</h2><p>在Spring中，与此相关的有两个Map。一个用于保存beanName与BeanDefinition的映射信息，一个用于保存aliasName与beanName的映射信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Map of bean definition objects, keyed by bean name. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Map from alias to canonical name. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; aliasMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>例如，当我们需要为A新增一个别名B时，为避免成环，会检测A是否是B的别名。若是的话，则会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Determine whether the given name has the given alias registered.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> name the name to check</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> alias the alias to look for</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 4.2.1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasAlias</span><span class="params">(String name, String alias)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : <span class="keyword">this</span>.aliasMap.entrySet()) &#123;</span><br><span class="line">        String registeredName = entry.getValue();</span><br><span class="line">        <span class="keyword">if</span> (registeredName.equals(name)) &#123;</span><br><span class="line">            String registeredAlias = entry.getKey();</span><br><span class="line">            <span class="keyword">if</span> (registeredAlias.equals(alias) || hasAlias(registeredAlias, alias)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h2><p>bean的别名可能会组成一列，即A的别名是B，B的别名是C。Spring用以下方式去找到别名的正式名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Determine the raw name, resolving aliases to canonical names.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> name the user-specified name</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the transformed name</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">canonicalName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    String canonicalName = name;</span><br><span class="line">    <span class="comment">// Handle aliasing...</span></span><br><span class="line">    String resolvedName;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        resolvedName = <span class="keyword">this</span>.aliasMap.get(canonicalName);</span><br><span class="line">        <span class="keyword">if</span> (resolvedName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            canonicalName = resolvedName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (resolvedName != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> canonicalName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>别名依赖</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2019/06/18/git/</url>
    <content><![CDATA[<h1 id="合并多个commit"><a href="#合并多个commit" class="headerlink" title="合并多个commit"></a>合并多个commit</h1> <a id="more"></a> 

<h2 id="在push之前合并"><a href="#在push之前合并" class="headerlink" title="在push之前合并"></a>在push之前合并</h2><p>情景：查看master分支的commit历史信息，会看到不同feature分支合并进来的许多commit。这么多粒度较小的commit，我们怎么知道哪些commit属于同一个feature。如果在master分支上，一个feature一个commit，这样会清晰很多，feature对外屏蔽掉开发过程中各种细小的commit，对外就体现出一个大commit。</p>
<p>假设目前的commit如下图所示，我们希望将这三个commit合并成一个commit（代码不改变）。例如我们在向开源社区提交一个较大的PR时，不可避免地会出现许多修修补补的commit，这些commit如果提交到master上面会非常难看且没有重点。因此，我们需要将开发过程中的多个commit合并成一个有明确含义的commit提交给reviewer。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">commit b2acc4d4aa5ca9bb21c0a62cd36de1911a3a2931 (HEAD -&gt; develop)</span><br><span class="line">Date:   Thu Jun 13 09:35:48 2019 +0800</span><br><span class="line"></span><br><span class="line">    develop33</span><br><span class="line"></span><br><span class="line">commit 329f9878306ed7f1d37638f9a32564f393347811</span><br><span class="line">Date:   Thu Jun 13 09:35:35 2019 +0800</span><br><span class="line"></span><br><span class="line">    develop22</span><br><span class="line"></span><br><span class="line">commit d6a56b89d4f6c7312837625766d6679aefe59816</span><br><span class="line">Date:   Thu Jun 13 09:20:46 2019 +0800</span><br><span class="line"></span><br><span class="line">    develop11</span><br></pre></td></tr></table></figure>

<p>下面我们使用<code>git rebase -i HEAD~3</code>将最近的3个commit合并成一个，<code>-i</code>表明这是一个交互的操作，接下去需要我们去指示要如何操作这3个commit。一般场景下，推荐使用以下操作：将最早的commit（最上方）标识为r，代表修改commit信息，将其他较新的commit标识为fixup，代表丢弃commit信息，且代码合并进之前的commit。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">r develop11  d6a56</span><br><span class="line">fixup develop22  329f9</span><br><span class="line">fixup develop33  b2acc</span><br></pre></td></tr></table></figure>

<p>合并完成后会生成一个新的commit，这个commit包含了以上3个commit的所有改动，且会生成一个全新的hash，不同于以上被合并的3个commit。</p>
<h2 id="在push之后合并"><a href="#在push之后合并" class="headerlink" title="在push之后合并"></a>在push之后合并</h2><p>情景：在提交PR之后，同事进行Code Review，给出了一些修改意见。我在本地修改后，会多出一个commit。使用上述方法可以将其合并，这时使用<code>git push</code>，会提示错误。提示本地分支落后于远程分支，这时我们可以使用<code>git push -f</code>强制更新远程分支。</p>
<h1 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h1><p>这里我们可以拿git merge和git rebase来做对比。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">M1--M2--M3(master)</span><br><span class="line">     \</span><br><span class="line">      \</span><br><span class="line">       D1(develop)</span><br></pre></td></tr></table></figure>

<h2 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h2><p>这个时候如果在develop分支上使用<code>git merge master</code>，则会将master分支合并至develop分支，且会保留原记录，形成非线性的commit记录。这种方式不太推荐。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">M1--M2----M3--D2(develop)</span><br><span class="line">        \    /</span><br><span class="line">         \  /</span><br><span class="line">          D1</span><br></pre></td></tr></table></figure>

<h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h2><p><code>git rebase master</code>，会将master分支合并进develop分支，且记录是线性的，新生成的D1’这个commit的hash不同于D1。可以理解为D1’这个分支是基于M3进行修改的，而不是基于M2。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">M1--M2--M3--D1&apos;(develop)</span><br></pre></td></tr></table></figure>

<h1 id="拉取新分支"><a href="#拉取新分支" class="headerlink" title="拉取新分支"></a>拉取新分支</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull = git fetch + git merge FETCH_HEAD </span><br><span class="line">git pull --rebase =  git fetch + git rebase FETCH_HEAD</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>效率工具</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习笔记之构造函数</title>
    <url>/2017/04/21/JS-NewObject/</url>
    <content><![CDATA[<p>我们选择new一个函数的时候，会经历以下3个步骤，以<code>new Foo()</code>为例：</p>
<a id="more"></a>

<ol>
<li>创建一个新对象，继承自<code>Foo.prototype</code></li>
<li>执行构造函数，并将this指向新对象</li>
<li>返回新对象（若构造函数没有返回值，也照样返回新对象）</li>
</ol>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JS构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习笔记之闭包</title>
    <url>/2017/04/19/JS-Closures/</url>
    <content><![CDATA[<h2 id="1-什么是闭包"><a href="#1-什么是闭包" class="headerlink" title="1. 什么是闭包"></a>1. 什么是闭包</h2><p>简单的说，闭包是指<strong>一个函数</strong>和<strong>这个函数的执行环境</strong>。下面是一个最简单的闭包。函数test()根据作用域链的规则访问到了函数外面的value变量。</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="string">"pxz"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述例子跟我们常见的闭包不太一样，常见的闭包形式是<strong>函数嵌套函数</strong>并且<strong>返回函数</strong>。我们再看上面那个例子，变量value赋给了全局对象，我们希望避免全局变量污染，就要把这个闭包放进函数中。如果是一次性的函数，就写成立即执行函数；如果需要调用，就写成返回函数形式。</p>
<p>一般创建闭包的方式，是在一个函数中创建另一个函数，<strong>并将该函数作为返回值返回</strong>。一般情况下，一个函数返回了，那么这个函数的活动对象（变量对象）就会被销毁，这个变量对象就不在当前作用域链上了，但是闭包跟一般情况不同。</p>
<h2 id="2-闭包用途"><a href="#2-闭包用途" class="headerlink" title="2.闭包用途"></a>2.闭包用途</h2><p>闭包可用来实现私有变量，具体可参考JS学习笔记——私有变量。</p>
<h2 id="3-一个闭包常见的错误"><a href="#3-一个闭包常见的错误" class="headerlink" title="3.一个闭包常见的错误"></a>3.一个闭包常见的错误</h2><p>在<strong>1.经典闭包例子</strong>中，test函数的返回值是一个匿名函数组ary，咋一看，匿名函数组里的每一个函数返回各自的索引值。但其实并不是这样的。匿名函数组里的每一个函数返回的值一样且都为n。我们调用了test函数，返回还是函数，赋给fun。在fun里可以访问到fun外test函数中的变量，比如<code>var i</code>，即使此时已经从test函数中返回。我们可以形象地把这个过程理解为<strong>返回函数ary闭包了外层函数的变量i</strong>。由于变量i在外层函数只有一份拷贝，所以函数组ary返回的i都是一个i，test函数执行完毕后，i变成了n。</p>
<p>要使得返回的函数组里的每个函数都不一样，我们需要为每个返回函数拷贝一份变量i。在<strong>2.立即执行函数</strong>中，没有直接使用外层函数变量i，而是将i作为函数参数传入，这样就能在函数内部拷贝一份变量了。</p>
<p>在<strong>3.返回函数</strong>中，我们在<strong>2.立即执行函数</strong>的基础上外包一层函数，使得满足闭包要求，返回函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//1.经典闭包例子</span><br><span class="line">function test(n) &#123;</span><br><span class="line">    ary = [];</span><br><span class="line">    for(var i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        ary[i] = function() &#123;return i;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return ary;</span><br><span class="line">&#125;</span><br><span class="line">var fun = test(5)[4];</span><br><span class="line">console.log(fun());//5</span><br><span class="line"></span><br><span class="line">//2.立即执行函数-拷贝变量</span><br><span class="line">//每一份i都有拷贝，但这不是闭包，返回值不是函数</span><br><span class="line">function test(n) &#123;</span><br><span class="line">    ary = [];</span><br><span class="line">    for(var i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        ary[i] = (function(x) &#123;return x;&#125;)(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return ary;</span><br><span class="line">&#125;</span><br><span class="line">console.log(test(5)[4]);//4</span><br><span class="line"></span><br><span class="line">//3.返回函数</span><br><span class="line">//在2的基础上，在外面套一层函数</span><br><span class="line">function test(n) &#123;</span><br><span class="line">    ary = [];</span><br><span class="line">    for(var i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        ary[i] = (function(x) &#123;</span><br><span class="line">        	return function() &#123;</span><br><span class="line">        		return x;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;)(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return ary;</span><br><span class="line">&#125;</span><br><span class="line">console.log(test(5)[4]());//4</span><br></pre></td></tr></table></figure>

<p>【Reference】</p>
<ol>
<li>《javascript高级程序设计》（第3版）</li>
<li>大部分人都会做错的经典JS闭包面试题 <a href="http://www.cnblogs.com/xxcanghai/p/4991870.html" target="_blank" rel="noopener">http://www.cnblogs.com/xxcanghai/p/4991870.html</a></li>
<li>「每日一题」JS 中的闭包是什么？ <a href="https://zhuanlan.zhihu.com/p/22486908" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/22486908</a></li>
</ol>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习笔记之跨域</title>
    <url>/2017/04/17/JS-CrossOrigin/</url>
    <content><![CDATA[<p>现在的web应用越来越丰富，一个web上的内容往往会抓取其他web上的数据。在默认情况下，web上的交互需要遵循同源策略（Same-origin policy），即同协议、同域名、同端口。在URL<code>http://store.company.com/dir2/other.html</code>中，协议是Http、域名是store.company.com，端口是80。当不符合同源策略时，这时的通信就可以叫做跨域通信。跨域通信有许多奇奇怪怪的方法可以做到，这里就简单介绍几种。</p>
<a id="more"></a>

<h3 id="document-domain-iframe"><a href="#document-domain-iframe" class="headerlink" title="document.domain + iframe"></a>document.domain + iframe</h3><p><code>http://www.a.com</code>和<code>http://script.a.com</code>的交互是跨域交互，因为两者域名不同，虽然主域名都为<code>a.com</code>。
对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决。具体的做法是可以在<a href="http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上`document.domain" target="_blank" rel="noopener">http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上`document.domain</a> = ‘a.com’<code>；然后通过在a.html文件中创建一个</code><iframe>`，去控制iframe的contentDocument，这样两个js文件就可以跨域通信了。当然这种办法只能解决主域相同而二级域名不同的情况。</iframe></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//www.a.com/a.html</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'a.com'</span>;</span><br><span class="line"><span class="keyword">var</span> ifr = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">ifr.src = <span class="string">'http://script.a.com/b.html'</span>;</span><br><span class="line">ifr.style.display = <span class="string">'none'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(ifr);</span><br><span class="line">ifr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> doc = ifr.contentDocument || ifr.contentWindow.document;</span><br><span class="line">    <span class="comment">// 在这里操纵script.a.com/b.html，可以对doc进行各种DOM操作</span></span><br><span class="line">    alert(doc.getElementsByTagName(<span class="string">"h1"</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//script.a.com/b.html</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'a.com'</span>;</span><br></pre></td></tr></table></figure>

<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP(JSON with padding)利用<code>&lt;script&gt;</code>跨域加载脚本的原生能力来做到跨域通信。</p>
<p>我们知道，如果要引用JQuery库，除了下载到本地引入外，还可以这么引入：<code>&lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;</code>，这个就是JSONP的基本原理。JSONP是一种非正式的传输协议，可以说是劳动人民的智慧。在JSONP的跨域通信中，客户端和服务器都需要遵循一定的规则。</p>
<p><code>&lt;script&gt;</code>的src属性应该填入所需服务的URL，URL中有查询字符串<code>code=CA998&amp;jsoncallback=callbackFunction</code>，<code>code=CA998</code>是传送给服务器的数据，<code>jsoncallback=callbackFunction</code>是传送给服务器的回调函数。前者jsoncallback由服务器定义，可能是callback、callbackFunc等等，双方约定好即可。后者callbackFunction由客户端定义，这是一个回调函数。将这样一个查询字符串发送给服务器之后，服务器会做两件事：1.根据查询字符串中的数据，准备好客户端需要的结果数据；2.将数据传入回调函数，把执行函数的字符串返回给客户端。客户端加载入这样一个js文件后，会执行该js文件中的执行语句。</p>
<p>服务器返回了带有执行语句的js，在客户端这边，需要定义或者声明这个回调函数<code>callbackFunction()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callbackFunction</span>(<span class="params">data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"http://www.runoob.com/try/ajax/jsonp.php?jsoncallback=callbackFunction"</span>;</span><br><span class="line"><span class="comment">// 创建script标签，设置其属性</span></span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">script.setAttribute(<span class="string">'src'</span>, url);</span><br><span class="line"><span class="comment">// 把script标签加入head，此时调用开始</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(script);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务器根据查询字符串的请求，用服务器端的语言，生成并返回js文件，该js文件大概内容如下</span></span><br><span class="line">callbackFunction([<span class="string">"customername1"</span>, <span class="string">"customername2"</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="HTML5-postMessage"><a href="#HTML5-postMessage" class="headerlink" title="HTML5 postMessage"></a>HTML5 postMessage</h3><p>HTML5为window对象新增了一个postMessage方法，该方法用于解决跨域通信的问题。<br>在<code>http://test.com</code>下，向<code>http://lslib.com</code>发送信息的步骤：<br>1.在发送方建立<code>&lt;iframe&gt;</code>，<code>src</code>属性填写接收方的url<br>2.调用frame的postMessage()方法，该方法接收两个参数：<br>message：只支持字符串信息，若要发送对象，可用JSON.stringify转换成字符串；<br>targetOrigin：目标域<br>3.在接收端为window对象绑定message事件，MessageEvent对象有三个重要的属性：<br>data：获取字符串<br>source：发送消息的窗口对象<br>origin：发送消息的源</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">http://test.com/index.html</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://lsLib.com/lsLib.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.frames[<span class="number">0</span>].postMessage(<span class="string">'getcolor'</span>,<span class="string">'http://lslib.com'</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">http://lslib.com/lslib.html</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//e.data = "getcolor"</span></span></span><br><span class="line"><span class="javascript">    &#125;,<span class="literal">false</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="图像ping"><a href="#图像ping" class="headerlink" title="图像ping"></a>图像ping</h3><p>一个网页可以从其他任何网页中加载图，那么图像ping主要通过<code>&lt;img&gt;</code>标签的src属性来进行跨域。客户端的请求通过查询查询字符串发送给服务器。这种方式主要有两点不足：1.只能用Get请求；2.只能进行客户端至服务器的单向通信（通过查询字符串），无法访问服务器的响应文本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var img = new Image();</span><br><span class="line">img.onload = function() &#123;</span><br><span class="line">    alert(&quot;onload!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">img.onerror = function() &#123;</span><br><span class="line">    alert(&quot;onerror!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//img.src=&quot;http://xxx.jpg&quot;;</span><br><span class="line">img.src=&quot;http://www.example.com/test?name=pxz&quot;;//name=pxz是就是客户端发送给服务器的请求</span><br></pre></td></tr></table></figure>

<p>【Reference】</p>
<ol>
<li><a href="https://earthsplitter.github.io/2017/03/21/%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96%E4%B8%8E%E8%B7%A8%E5%9F%9F%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener"> 同源政策与跨域详解 </a></li>
<li>说说JSON和JSONP，也许你会豁然开朗，含jQuery用例  <a href="http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html" target="_blank" rel="noopener">http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html</a></li>
<li><a href="http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html#m3" target="_blank" rel="noopener">http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html#m3</a></li>
</ol>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习笔记之ajax</title>
    <url>/2017/04/16/JS-AJAX/</url>
    <content><![CDATA[<p>Ajax（Asynchronous JavaScript + XML）在2005年被Jesse James Garrett引入，他综合了许多当时现有技术，产生了ajax。ajax使得浏览器可以额外地向服务器请求数据而不用重新刷新页面，ajax从服务器或许到数据后，可用javascript操作DOM以改变页面。虽然ajax中的x代表XML，但目前JSON的使用要更加广泛一点。JSON更加轻量级以及是原生javascript的一部分。</p>
<a id="more"></a>

<p>实现ajax的核心是XMLHttpRequest对象，其使用主要是<code>open()</code>、<code>send()</code>等函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//1.new</span><br><span class="line">//2.event</span><br><span class="line">//3.open</span><br><span class="line">//4.send</span><br><span class="line"></span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">//为了兼容性，事件回调需在open之前定义</span><br><span class="line">xhr.onreadystatechange = function() &#123;</span><br><span class="line">    if(xhr.readyState == 4) &#123;</span><br><span class="line">        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 | xhr.status == 304) &#123;</span><br><span class="line">            alert(xhr.responseText);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            alert(&quot;Request was failed.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//以get的方式请求example.txt，这里用相对路径，相对当前页面；最后一个参数代表是否异步。调用open之后，请求并没有发送，只是启动一个请求以备发送。</span><br><span class="line">xhr.open(&quot;get&quot;, &quot;example.txt&quot;, true);</span><br><span class="line"></span><br><span class="line">//请求主体无数据。调用send之后，请求就会被发送出去。</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure>

<p>对象xhr中有一个readyState属性，这个属性表示目前ajax处于哪个状态，一般我们多使用<code>4:已经接收到全部响应数据</code>。当readyState状态改变时，会触发<code>readystatechange事件</code>。我们将该事件以DOM0级的方式添加到xhr对象上。在这个事件中，我们要检测readyState是否等于4，还要检测status。<br>还有一个在使用上比readystatechange事件要简单一点的是<code>load事件</code>，该事件就是在响应接收完毕后触发的，也就没有必要去检测readyState了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xhr.onload = function() &#123;</span><br><span class="line">    if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 | xhr.status == 304) &#123;</span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        alert(&quot;Request was failed.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习笔记之私有变量</title>
    <url>/2017/04/15/JS-PrivateValue/</url>
    <content><![CDATA[<h2 id="0-本章提要"><a href="#0-本章提要" class="headerlink" title="0.本章提要"></a>0.本章提要</h2><ul>
<li><p>使用立即执行函数实现块级作用域</p>
</li>
<li><p>使用<code>构造函数</code>实现<strong>实例</strong>私有变量：私有变量函数和公有特权方法每个实例都有独立的一份</p>
</li>
<li><p>使用<code>原型模式+块级作用域</code>实现<strong>静态</strong>私有变量：私有变量函数和公有特权方法每个实例都共享一份</p>
</li>
</ul>
<a id="more"></a>

<h2 id="1-块级作用域"><a href="#1-块级作用域" class="headerlink" title="1.块级作用域"></a>1.块级作用域</h2><p>javascript不像其他语言有块级作用域，比如C、java的块级作用域。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C、java块级作用域</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;...&#125;</span><br><span class="line"><span class="comment">//i无效</span></span><br></pre></td></tr></table></figure>

<p>javascript是以函数进行区分作用域的（具体可参考JS学习笔记——作用域链）。如果需要使用到像java一样的块级作用域，可以用函数的形式实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i;</span><br><span class="line">    ...</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>这个函数是立即执行函数，变量i的作用域仅限于匿名函数内，就不会对全局造成污染。而且该立即执行函数没有引用，一经执行完，作用域链就可以立即销毁。</p>
<h2 id="2-实例私有变量"><a href="#2-实例私有变量" class="headerlink" title="2.实例私有变量"></a>2.实例私有变量</h2><p>javascript没有像java一样的对象成员访问权限的设置（private、public等）。如果要实现私有变量，可以通过构造函数的方式。下面是一种实现实例私有变量的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;<span class="comment">//name私有变量</span></span><br><span class="line">    <span class="keyword">var</span> privateVar;<span class="comment">//私有变量</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunc</span>(<span class="params"></span>)</span>&#123;...&#125;<span class="comment">//私有函数</span></span><br><span class="line">    <span class="keyword">this</span>.getName() &#123;<span class="comment">//特权方法</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.setName(value) &#123;<span class="comment">//特权方法</span></span><br><span class="line">        name = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Season"</span>);</span><br></pre></td></tr></table></figure>

<p>将需要私有的变量和函数放到函数作用域中，外界就认为是私有的了，但我们需要一种手段去访问它们，于是<code>特权方法(privileged method)</code>就出现了，它是有权访问私有变量和函数的公有方法。<br>私有变量或函数使用表达式定义时，一定要加<code>var</code>，不然这个变量或函数就会被加到全局作用域中，就不是私有变量了。其中函数也可以使用函数声明，因为函数声明只会提升到当前作用域，不会到全局作用域中。<br>我们使用<code>this</code>把公有的特权方法定义成对象的成员，可供函数作用域外的变量访问。<br>任何函数都可以被用作构造函数，只要使用了new操作符。<code>Person()</code>函数中的私有变量没有赋值给this对象，那么这些私有变量就是局部变量，通过闭包的方式被特权方法访问，被放入到其作用域链中。所以每次new之后，特权方法和私有变量都会被再复制一份，前者属于this对象，当然会复制一份；后者通过闭包被加入到特权方法的作用域链中，也会复制一份。</p>
<h2 id="3-静态私有变量"><a href="#3-静态私有变量" class="headerlink" title="3.静态私有变量"></a>3.静态私有变量</h2><p>使用<code>原型模式+块级作用域</code>实现<strong>静态</strong>私有变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    var privateVar = 0;</span><br><span class="line">    function privateFunc()&#123;return false;&#125;</span><br><span class="line">    MyObject = function()&#123;&#125;;</span><br><span class="line">    MyObject.prototype.publicMethod = function()&#123;</span><br><span class="line">        privateVar++;</span><br><span class="line">        return privateFunc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">var Obj = new MyObject();</span><br></pre></td></tr></table></figure>

<p>这个立即执行的匿名函数不会随着new的执行而执行，因此私有变量和函数只有一份，它们的作用域仅限于匿名函数内。<code>MyObject</code>定义的时候不能加<code>var</code>，否则匿名函数外就访问不到了。特权方法定义在<code>MyObject</code>的原型上，因此特权方法也只有一个。</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JS私有变量</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习笔记之数据类型</title>
    <url>/2017/04/13/JS-DataType/</url>
    <content><![CDATA[<h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h2><p>ECMAScript一共有6种数据类型：<strong>5种</strong>基本数据类型和<strong>1种</strong>引用数据类型。<br>基本数据类型：Number\String\Boolean\Null\Undefined<br>引用数据类型：Object</p>
<a id="more"></a>

<h2 id="2-tyepof操作符"><a href="#2-tyepof操作符" class="headerlink" title="2.tyepof操作符"></a>2.tyepof操作符</h2><p>typeof是操作符，不是函数。typeof返回<strong>字符串</strong>。使用typeof返回的数据类型跟第1节是不一样的。typeof一共返回6种，也是6种，只不过是<strong>4种</strong>基本数据类型和<strong>2种</strong>引用数据类型。Null被归为Object，原本属于Object的Function被单独拎出来。</p>
<p>基本数据类型：Number\String\Boolean\Undefined<br>引用数据类型：Object\Function</p>
<h2 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h2><h3 id="3-1-声明变量时显式初始化"><a href="#3-1-声明变量时显式初始化" class="headerlink" title="3.1 声明变量时显式初始化"></a>3.1 声明变量时显式初始化</h3><p>已声明未赋值变量<code>myTest</code>与未声明变量<code>test</code>的值都是<code>undefined</code>。这是两个本质不一样的变量，typeof之后的值却是一样的，我们应该避免这种情况的出现：声明变量的时候显式地初始化变量，让上述<code>typeof(test)</code>的情况不要出现，所以只要出现undefined，我们就可以认为这是一个未声明的变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//var test;</span><br><span class="line">var myTest;</span><br><span class="line">console.log(typeof(test));//undefined</span><br><span class="line">console.log(typeof(myTest));//undefined</span><br></pre></td></tr></table></figure>

<h3 id="3-2-对象变量显式初始化为null"><a href="#3-2-对象变量显式初始化为null" class="headerlink" title="3.2 对象变量显式初始化为null"></a>3.2 对象变量显式初始化为null</h3><p>如果声明的变量将来要用来保存对象的，应该初始化成<code>null</code>(之前我一直初始化成<code>{}</code>，这样是不好的)</p>
<h3 id="3-3-undefined-null是关键字-可当变量用"><a href="#3-3-undefined-null是关键字-可当变量用" class="headerlink" title="3.3 undefined\null是关键字 可当变量用"></a>3.3 undefined\null是关键字 可当变量用</h3><p>我们可以显式地把变量初始化为undefined<code>var test = undefined</code>，表示把test赋值成基本数据类型中的undefined。这里不是把undefined字符串赋值给变量，<code>undefined</code>是关键字，所以可以当做变量来用，如果写<code>var test = myundefined</code>是会报错的。js会认为myundefined是变量，然后去找，发现未定义。如果myundefined加上引号就是String，赋值就不会报错了。</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JS数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习笔记之对象属性判断</title>
    <url>/2017/04/12/JS-ObjectProperty/</url>
    <content><![CDATA[<h2 id="1-判断对象是否为空"><a href="#1-判断对象是否为空" class="headerlink" title="1. 判断对象是否为空"></a>1. 判断对象是否为空</h2><p>我们可以使用<code>fon-in</code>语句来枚举对象的属性，属性被枚举是没有顺序的。使用for-in语句就可以判断对象是否为空，<code>for-in</code>语句还会枚举对象<strong>原型</strong>上的属性。当对象是<code>null</code>或者<code>undefined</code>时，函数<code>isEptObj()</code>也返回true，表示对象是空的。</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEptObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> t <span class="keyword">in</span> o) &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">s1 = <span class="literal">null</span>;</span><br><span class="line">s2 = <span class="literal">undefined</span>;</span><br><span class="line">s3 = [];</span><br><span class="line">s4 = &#123;&#125;;</span><br><span class="line">isEptObj(s1);<span class="comment">//true</span></span><br><span class="line">isEptObj(s2);<span class="comment">//true</span></span><br><span class="line">isEptObj(s3);<span class="comment">//true</span></span><br><span class="line">isEptObj(s4);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.age = <span class="number">24</span>;</span><br><span class="line">isEptObj(s1);<span class="comment">//true</span></span><br><span class="line">isEptObj(s2);<span class="comment">//true</span></span><br><span class="line">isEptObj(s3);<span class="comment">//flase</span></span><br><span class="line">isEptObj(s4);<span class="comment">//flase</span></span><br></pre></td></tr></table></figure>

<h2 id="2-判断对象是否包含某属性"><a href="#2-判断对象是否包含某属性" class="headerlink" title="2. 判断对象是否包含某属性"></a>2. 判断对象是否包含某属性</h2><p>使用对象的<code>hasOwnProperty()</code>方法可以判断属性是否在实例上。如果该属性不在实例上，会有两种情况：1.该属性在原型上； 2.该属性不在原型上。所以我们还要配合<code>in</code>语句（<code>for-in</code>的非循环版本）继续判断该属性，进而可以得出该属性在实例上，在原型上，还是都不在。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">s1 = &#123;&#125;;</span><br><span class="line">s1.name = <span class="string">"abc"</span>;</span><br><span class="line"><span class="built_in">Object</span>.prototype.age = <span class="number">24</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s1.hasOwnProperty(<span class="string">'age'</span>)); <span class="comment">// flase</span></span><br><span class="line"><span class="built_in">console</span>.log(s1.hasOwnProperty(<span class="string">'name'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(s1.hasOwnProperty(<span class="string">'salary'</span>)); <span class="comment">// flase</span></span><br></pre></td></tr></table></figure>

<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>配合使用<code>in</code>语句和<code>hasOwnProperty()</code>函数，可以判断属性在实例上，在原型上，还是都不在。</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JS对象判断</tag>
      </tags>
  </entry>
</search>
